<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: /home/user/_my/code/bwauth-related/tor/src/or/buffers.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97b64286d42c5ef1697cb5f17129db19.html">tor</a></li><li class="navelem"><a class="el" href="dir_3cb0ba3f4b82dbe34a1a06276e96bc8d.html">src</a></li><li class="navelem"><a class="el" href="dir_386635fabd7f6c74e9d9c7a8604514a0.html">or</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">buffers.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for <a class="el" href="buffers_8c.html" title="Implements a generic buffer interface. ">buffers.c</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;testsupport.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for buffers.h:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2buffers_8h" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2buffers_8h" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2buffers_8h">
<area shape="rect" id="node2" href="testsupport_8h_source.html" title="testsupport.h" alt="" coords="30,109,129,136"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h__dep__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2buffers_8hdep" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2buffers_8hdep" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2buffers_8hdep">
<area shape="rect" id="node2" href="buffers_8c.html" title="Implements a generic buffer interface. " alt="" coords="411,109,559,165"/>
<area shape="rect" id="node3" href="connection_8h.html" title="Header file for connection.c. " alt="" coords="1937,109,2085,165"/>
<area shape="rect" id="node10" href="connection_8c.html" title="General high&#45;level functions to handle reading and writing on connections. " alt="" coords="5,213,153,269"/>
<area shape="rect" id="node11" href="connection__edge_8c.html" title="Handle edge streams. " alt="" coords="177,213,349,269"/>
<area shape="rect" id="node12" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. " alt="" coords="374,213,529,269"/>
<area shape="rect" id="node13" href="control_8c.html" title="Implementation for Tor&#39;s control&#45;socket interface. " alt="" coords="553,213,701,269"/>
<area shape="rect" id="node14" href="directory_8c.html" title="Code to send and fetch directories and router descriptors via HTTP. Directories use dirserv..." alt="" coords="725,213,873,269"/>
<area shape="rect" id="node15" href="dirserv_8c.html" title="Directory server core implementation. Manages directory contents and generates directories. " alt="" coords="897,213,1045,269"/>
<area shape="rect" id="node21" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop..." alt="" coords="3829,213,3977,269"/>
<area shape="rect" id="node23" href="relay_8c.html" title="Handle relay cell encryption/decryption, plus packaging and receiving from circuits, plus queuing on circuits. " alt="" coords="4001,213,4149,269"/>
<area shape="rect" id="node4" href="channeltls_8c.html" title="A concrete subclass of channel_t using or_connection_t to transfer cells between Tor instances..." alt="" coords="2453,213,2601,269"/>
<area shape="rect" id="node5" href="circuitbuild_8c.html" title="Implements the details of building circuits (by chosing paths, constructing/sending create/extend cel..." alt="" coords="2625,213,2773,269"/>
<area shape="rect" id="node6" href="circuitlist_8c.html" title="Manage the global circuit list, and looking up circuits within it. " alt="" coords="2797,213,2945,269"/>
<area shape="rect" id="node7" href="circuituse_8c.html" title="Launch the right sort of circuits and attach streams to them. " alt="" coords="2969,213,3117,269"/>
<area shape="rect" id="node8" href="command_8c.html" title="Functions for processing incoming cells. " alt="" coords="3141,213,3289,269"/>
<area shape="rect" id="node9" href="config_8c.html" title="Code to parse and interpret configuration files. " alt="" coords="3313,213,3461,269"/>
<area shape="rect" id="node16" href="dns_8c.html" title="Implements a local cache for DNS results for Tor servers. This is implemented as a wrapper around Ada..." alt="" coords="3485,213,3633,269"/>
<area shape="rect" id="node17" href="dnsserv_8c.html" title="Implements client&#45;side DNS proxy server code. Note: this is the DNS Server code, not the Server DNS c..." alt="" coords="3657,213,3805,269"/>
<area shape="rect" id="node18" href="entrynodes_8c.html" title="Code to manage our fixed first nodes for various functions. " alt="" coords="1069,213,1217,269"/>
<area shape="rect" id="node19" href="ext__orport_8c.html" title="Code implementing the Extended ORPort. " alt="" coords="1241,213,1389,269"/>
<area shape="rect" id="node20" href="hibernate_8c.html" title="Functions to close listeners, stop allowing new circuits, etc in preparation for closing down or goin..." alt="" coords="1413,213,1561,269"/>
<area shape="rect" id="node22" href="networkstatus_8c.html" title="Functions and structures for handling network status documents as a client or cache. " alt="" coords="1585,213,1741,269"/>
<area shape="rect" id="node24" href="rendclient_8c.html" title="Client code to access location&#45;hidden services. " alt="" coords="1765,213,1913,269"/>
<area shape="rect" id="node25" href="router_8c.html" title="Miscellaneous relay functionality, including RSA key maintenance, generating and uploading server des..." alt="" coords="1937,213,2085,269"/>
<area shape="rect" id="node26" href="routerlist_8c.html" title="Code to maintain and access the global list of routerinfos for known servers. " alt="" coords="2109,213,2257,269"/>
<area shape="rect" id="node27" href="statefile_8c.html" title="Handles parsing and encoding the persistent &#39;state&#39; file that carries miscellaneous persistent state ..." alt="" coords="2281,213,2429,269"/>
</map>
</div>
</div>
<p><a href="buffers_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2792d274b6e45707b54d36697b575cd5"><td class="memItemLeft" align="right" valign="top">buf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a2792d274b6e45707b54d36697b575cd5">buf_new</a> (void)</td></tr>
<tr class="separator:a2792d274b6e45707b54d36697b575cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25596a2194d00f8015a2a454ad0deede"><td class="memItemLeft" align="right" valign="top">buf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a25596a2194d00f8015a2a454ad0deede">buf_new_with_capacity</a> (size_t size)</td></tr>
<tr class="separator:a25596a2194d00f8015a2a454ad0deede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccdeb5d1807ead1cf47df6fdd78267f"><td class="memItemLeft" align="right" valign="top"><a id="a0ccdeb5d1807ead1cf47df6fdd78267f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>buf_get_default_chunk_size</b> (const buf_t *buf)</td></tr>
<tr class="separator:a0ccdeb5d1807ead1cf47df6fdd78267f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198f56649de692ac03c807c8406e4a00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a198f56649de692ac03c807c8406e4a00">buf_free</a> (buf_t *buf)</td></tr>
<tr class="separator:a198f56649de692ac03c807c8406e4a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5f6af679f4b6ead9ba2aca03941931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a1d5f6af679f4b6ead9ba2aca03941931">buf_clear</a> (buf_t *buf)</td></tr>
<tr class="separator:a1d5f6af679f4b6ead9ba2aca03941931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698473a00b89755b994e4f9b83817e98"><td class="memItemLeft" align="right" valign="top">buf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a698473a00b89755b994e4f9b83817e98">buf_copy</a> (const buf_t *buf)</td></tr>
<tr class="separator:a698473a00b89755b994e4f9b83817e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec7016d94d6a9481baae254319676db"><td class="memItemLeft" align="right" valign="top"><a id="abec7016d94d6a9481baae254319676db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (size_t, buf_datalen,(const buf_t *buf))</td></tr>
<tr class="separator:abec7016d94d6a9481baae254319676db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364f8af28dc3b92ec93bf5c433a44209"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a364f8af28dc3b92ec93bf5c433a44209">buf_allocation</a> (const buf_t *buf)</td></tr>
<tr class="separator:a364f8af28dc3b92ec93bf5c433a44209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8042b5333db20f4e1198817d96ba0be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#aa8042b5333db20f4e1198817d96ba0be">buf_slack</a> (const buf_t *buf)</td></tr>
<tr class="separator:aa8042b5333db20f4e1198817d96ba0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69be7777203d7b3f1626f62dea75cc61"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a69be7777203d7b3f1626f62dea75cc61">buf_get_oldest_chunk_timestamp</a> (const buf_t *buf, uint32_t now)</td></tr>
<tr class="separator:a69be7777203d7b3f1626f62dea75cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed3d5a6dbe1161f151d342e4f32f29c"><td class="memItemLeft" align="right" valign="top"><a id="aeed3d5a6dbe1161f151d342e4f32f29c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>buf_get_total_allocation</b> (void)</td></tr>
<tr class="separator:aeed3d5a6dbe1161f151d342e4f32f29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486bc6925bb8ae53ca546f716096333e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a486bc6925bb8ae53ca546f716096333e">read_to_buf</a> (tor_socket_t s, size_t at_most, buf_t *buf, int *reached_eof, int *socket_error)</td></tr>
<tr class="separator:a486bc6925bb8ae53ca546f716096333e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8210656ac6aaa79c7216c0675508524"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#ab8210656ac6aaa79c7216c0675508524">read_to_buf_tls</a> (tor_tls_t *tls, size_t at_most, buf_t *buf)</td></tr>
<tr class="separator:ab8210656ac6aaa79c7216c0675508524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af267b3ef237ecb964046aed3b1d2afa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#af267b3ef237ecb964046aed3b1d2afa2">flush_buf</a> (tor_socket_t s, buf_t *buf, size_t sz, size_t *buf_flushlen)</td></tr>
<tr class="separator:af267b3ef237ecb964046aed3b1d2afa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6561415a56da7c03881f2c453dac2a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#af6561415a56da7c03881f2c453dac2a3">flush_buf_tls</a> (tor_tls_t *tls, buf_t *buf, size_t sz, size_t *buf_flushlen)</td></tr>
<tr class="separator:af6561415a56da7c03881f2c453dac2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ec6a70255dc260a166de964a56874"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a7c2ec6a70255dc260a166de964a56874">write_to_buf</a> (const char *string, size_t string_len, buf_t *buf)</td></tr>
<tr class="separator:a7c2ec6a70255dc260a166de964a56874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13ed2ec4453c0a1d8a46aa2566b0530"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#ab13ed2ec4453c0a1d8a46aa2566b0530">write_to_buf_zlib</a> (buf_t *buf, <a class="el" href="structtor__zlib__state__t.html">tor_zlib_state_t</a> *state, const char *data, size_t data_len, int done)</td></tr>
<tr class="separator:ab13ed2ec4453c0a1d8a46aa2566b0530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be89c5c69293eab984961565d23288d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a7be89c5c69293eab984961565d23288d">move_buf_to_buf</a> (buf_t *buf_out, buf_t *buf_in, size_t *buf_flushlen)</td></tr>
<tr class="separator:a7be89c5c69293eab984961565d23288d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eaa6d554d8f3806529be908761c0b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#ac0eaa6d554d8f3806529be908761c0b6">fetch_from_buf</a> (char *string, size_t string_len, buf_t *buf)</td></tr>
<tr class="separator:ac0eaa6d554d8f3806529be908761c0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485df8a6961e83b9102bc3eb9ddb149f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a485df8a6961e83b9102bc3eb9ddb149f">fetch_var_cell_from_buf</a> (buf_t *buf, <a class="el" href="structvar__cell__t.html">var_cell_t</a> **out, int linkproto)</td></tr>
<tr class="separator:a485df8a6961e83b9102bc3eb9ddb149f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c180fbc5977d558988ab676dd87c1de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a1c180fbc5977d558988ab676dd87c1de">fetch_from_buf_http</a> (buf_t *buf, char **headers_out, size_t max_headerlen, char **body_out, size_t *body_used, size_t max_bodylen, int force_complete)</td></tr>
<tr class="separator:a1c180fbc5977d558988ab676dd87c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf3c3ffa8cdb33c72236cdfbacafacc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsocks__request__t.html">socks_request_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#aacf3c3ffa8cdb33c72236cdfbacafacc">socks_request_new</a> (void)</td></tr>
<tr class="separator:aacf3c3ffa8cdb33c72236cdfbacafacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d88eae643ab99ae0fa364974dd43077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a9d88eae643ab99ae0fa364974dd43077">socks_request_free</a> (<a class="el" href="structsocks__request__t.html">socks_request_t</a> *req)</td></tr>
<tr class="separator:a9d88eae643ab99ae0fa364974dd43077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6953fec5d68167570512aa9f2876b052"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a6953fec5d68167570512aa9f2876b052">fetch_from_buf_socks</a> (buf_t *buf, <a class="el" href="structsocks__request__t.html">socks_request_t</a> *req, int log_sockstype, int safe_socks)</td></tr>
<tr class="separator:a6953fec5d68167570512aa9f2876b052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9068d877362a26c2e920b0a0e43c3d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#ad9068d877362a26c2e920b0a0e43c3d1">fetch_from_buf_socks_client</a> (buf_t *buf, int state, char **reason)</td></tr>
<tr class="separator:ad9068d877362a26c2e920b0a0e43c3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6d40f0e53e9bf0b10107d58c168072"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#adc6d40f0e53e9bf0b10107d58c168072">fetch_from_buf_line</a> (buf_t *buf, char *data_out, size_t *data_len)</td></tr>
<tr class="separator:adc6d40f0e53e9bf0b10107d58c168072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8c9bd7065eb165b5d7f64ab5094a6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#adf8c9bd7065eb165b5d7f64ab5094a6d">peek_buf_has_control0_command</a> (buf_t *buf)</td></tr>
<tr class="separator:adf8c9bd7065eb165b5d7f64ab5094a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49ccbac869f3d8d8fb0263ab009232b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#ae49ccbac869f3d8d8fb0263ab009232b">fetch_ext_or_command_from_buf</a> (buf_t *buf, <a class="el" href="structext__or__cmd__t.html">ext_or_cmd_t</a> **out)</td></tr>
<tr class="separator:ae49ccbac869f3d8d8fb0263ab009232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27eb7c3c9dcc484cbd276fbfb2a0791"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#ad27eb7c3c9dcc484cbd276fbfb2a0791">buf_set_to_copy</a> (buf_t **output, const buf_t *input)</td></tr>
<tr class="separator:ad27eb7c3c9dcc484cbd276fbfb2a0791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a28c1010eb8964040d016f403f9b68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffers_8h.html#a46a28c1010eb8964040d016f403f9b68">assert_buf_ok</a> (buf_t *buf)</td></tr>
<tr class="separator:a46a28c1010eb8964040d016f403f9b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for <a class="el" href="buffers_8c.html" title="Implements a generic buffer interface. ">buffers.c</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a46a28c1010eb8964040d016f403f9b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a28c1010eb8964040d016f403f9b68">&#9670;&nbsp;</a></span>assert_buf_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assert_buf_ok </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log an error and exit if <b>buf</b> is corrupted. </p>

</div>
</div>
<a id="a364f8af28dc3b92ec93bf5c433a44209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364f8af28dc3b92ec93bf5c433a44209">&#9670;&nbsp;</a></span>buf_allocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t buf_allocation </td>
          <td>(</td>
          <td class="paramtype">const buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total length of all chunks used in <b>buf</b>. </p>

</div>
</div>
<a id="a1d5f6af679f4b6ead9ba2aca03941931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5f6af679f4b6ead9ba2aca03941931">&#9670;&nbsp;</a></span>buf_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_clear </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all data from <b>buf</b>. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a1d5f6af679f4b6ead9ba2aca03941931_icgraph.png" border="0" usemap="#buffers_8h_a1d5f6af679f4b6ead9ba2aca03941931_icgraph" alt=""/></div>
<map name="buffers_8h_a1d5f6af679f4b6ead9ba2aca03941931_icgraph" id="buffers_8h_a1d5f6af679f4b6ead9ba2aca03941931_icgraph">
<area shape="rect" id="node2" href="buffers_8h.html#a198f56649de692ac03c807c8406e4a00" title="buf_free" alt="" coords="128,5,197,32"/>
<area shape="rect" id="node3" href="buffers_8h.html#ad27eb7c3c9dcc484cbd276fbfb2a0791" title="buf_set_to_copy" alt="" coords="245,5,364,32"/>
</map>
</div>

</div>
</div>
<a id="a698473a00b89755b994e4f9b83817e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698473a00b89755b994e4f9b83817e98">&#9670;&nbsp;</a></span>buf_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_t* buf_copy </td>
          <td>(</td>
          <td class="paramtype">const buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new copy of <b>buf</b> </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a698473a00b89755b994e4f9b83817e98_cgraph.png" border="0" usemap="#buffers_8h_a698473a00b89755b994e4f9b83817e98_cgraph" alt=""/></div>
<map name="buffers_8h_a698473a00b89755b994e4f9b83817e98_cgraph" id="buffers_8h_a698473a00b89755b994e4f9b83817e98_cgraph">
<area shape="rect" id="node2" href="buffers_8c.html#a2792d274b6e45707b54d36697b575cd5" title="buf_new" alt="" coords="128,5,199,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a698473a00b89755b994e4f9b83817e98_icgraph.png" border="0" usemap="#buffers_8h_a698473a00b89755b994e4f9b83817e98_icgraph" alt=""/></div>
<map name="buffers_8h_a698473a00b89755b994e4f9b83817e98_icgraph" id="buffers_8h_a698473a00b89755b994e4f9b83817e98_icgraph">
<area shape="rect" id="node2" href="buffers_8h.html#ad27eb7c3c9dcc484cbd276fbfb2a0791" title="buf_set_to_copy" alt="" coords="128,5,247,32"/>
</map>
</div>

</div>
</div>
<a id="a198f56649de692ac03c807c8406e4a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198f56649de692ac03c807c8406e4a00">&#9670;&nbsp;</a></span>buf_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_free </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release storage held by <b>buf</b>. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a198f56649de692ac03c807c8406e4a00_cgraph.png" border="0" usemap="#buffers_8h_a198f56649de692ac03c807c8406e4a00_cgraph" alt=""/></div>
<map name="buffers_8h_a198f56649de692ac03c807c8406e4a00_cgraph" id="buffers_8h_a198f56649de692ac03c807c8406e4a00_cgraph">
<area shape="rect" id="node2" href="buffers_8c.html#a1d5f6af679f4b6ead9ba2aca03941931" title="buf_clear" alt="" coords="123,5,197,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a198f56649de692ac03c807c8406e4a00_icgraph.png" border="0" usemap="#buffers_8h_a198f56649de692ac03c807c8406e4a00_icgraph" alt=""/></div>
<map name="buffers_8h_a198f56649de692ac03c807c8406e4a00_icgraph" id="buffers_8h_a198f56649de692ac03c807c8406e4a00_icgraph">
<area shape="rect" id="node2" href="buffers_8h.html#ad27eb7c3c9dcc484cbd276fbfb2a0791" title="buf_set_to_copy" alt="" coords="123,5,241,32"/>
</map>
</div>

</div>
</div>
<a id="a69be7777203d7b3f1626f62dea75cc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69be7777203d7b3f1626f62dea75cc61">&#9670;&nbsp;</a></span>buf_get_oldest_chunk_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t buf_get_oldest_chunk_timestamp </td>
          <td>(</td>
          <td class="paramtype">const buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the age of the oldest chunk in the buffer <b>buf</b>, in milliseconds. Requires the current monotonic time, in truncated msec, as its input <b>now</b>. </p>

</div>
</div>
<a id="a2792d274b6e45707b54d36697b575cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2792d274b6e45707b54d36697b575cd5">&#9670;&nbsp;</a></span>buf_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_t* buf_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and return a new buffer with default capacity. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a2792d274b6e45707b54d36697b575cd5_icgraph.png" border="0" usemap="#buffers_8h_a2792d274b6e45707b54d36697b575cd5_icgraph" alt=""/></div>
<map name="buffers_8h_a2792d274b6e45707b54d36697b575cd5_icgraph" id="buffers_8h_a2792d274b6e45707b54d36697b575cd5_icgraph">
<area shape="rect" id="node2" href="buffers_8h.html#a25596a2194d00f8015a2a454ad0deede" title="buf_new_with_capacity" alt="" coords="124,5,283,32"/>
<area shape="rect" id="node3" href="buffers_8h.html#a698473a00b89755b994e4f9b83817e98" title="buf_copy" alt="" coords="166,56,241,83"/>
<area shape="rect" id="node4" href="buffers_8h.html#ad27eb7c3c9dcc484cbd276fbfb2a0791" title="buf_set_to_copy" alt="" coords="331,56,449,83"/>
</map>
</div>

</div>
</div>
<a id="a25596a2194d00f8015a2a454ad0deede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25596a2194d00f8015a2a454ad0deede">&#9670;&nbsp;</a></span>buf_new_with_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_t* buf_new_with_capacity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and return a new buf with default chunk capacity <b>size</b>. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a25596a2194d00f8015a2a454ad0deede_cgraph.png" border="0" usemap="#buffers_8h_a25596a2194d00f8015a2a454ad0deede_cgraph" alt=""/></div>
<map name="buffers_8h_a25596a2194d00f8015a2a454ad0deede_cgraph" id="buffers_8h_a25596a2194d00f8015a2a454ad0deede_cgraph">
<area shape="rect" id="node2" href="buffers_8c.html#a2792d274b6e45707b54d36697b575cd5" title="buf_new" alt="" coords="250,5,321,32"/>
<area shape="rect" id="node3" href="buffers_8c.html#a1ab1849b985a5ac9f2bf4e56d40d19f3" title="preferred_chunk_size" alt="" coords="212,56,359,83"/>
</map>
</div>

</div>
</div>
<a id="ad27eb7c3c9dcc484cbd276fbfb2a0791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27eb7c3c9dcc484cbd276fbfb2a0791">&#9670;&nbsp;</a></span>buf_set_to_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int buf_set_to_copy </td>
          <td>(</td>
          <td class="paramtype">buf_t **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const buf_t *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set *<b>output</b> to contain a copy of the data in *<b>input</b> </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_ad27eb7c3c9dcc484cbd276fbfb2a0791_cgraph.png" border="0" usemap="#buffers_8h_ad27eb7c3c9dcc484cbd276fbfb2a0791_cgraph" alt=""/></div>
<map name="buffers_8h_ad27eb7c3c9dcc484cbd276fbfb2a0791_cgraph" id="buffers_8h_ad27eb7c3c9dcc484cbd276fbfb2a0791_cgraph">
<area shape="rect" id="node2" href="buffers_8c.html#a198f56649de692ac03c807c8406e4a00" title="buf_free" alt="" coords="175,5,244,32"/>
<area shape="rect" id="node4" href="buffers_8c.html#a698473a00b89755b994e4f9b83817e98" title="buf_copy" alt="" coords="172,56,247,83"/>
<area shape="rect" id="node3" href="buffers_8c.html#a1d5f6af679f4b6ead9ba2aca03941931" title="buf_clear" alt="" coords="295,5,369,32"/>
<area shape="rect" id="node5" href="buffers_8c.html#a2792d274b6e45707b54d36697b575cd5" title="buf_new" alt="" coords="297,56,367,83"/>
</map>
</div>

</div>
</div>
<a id="aa8042b5333db20f4e1198817d96ba0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8042b5333db20f4e1198817d96ba0be">&#9670;&nbsp;</a></span>buf_slack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t buf_slack </td>
          <td>(</td>
          <td class="paramtype">const buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of bytes that can be added to <b>buf</b> without performing any additional allocation. </p>

</div>
</div>
<a id="ae49ccbac869f3d8d8fb0263ab009232b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49ccbac869f3d8d8fb0263ab009232b">&#9670;&nbsp;</a></span>fetch_ext_or_command_from_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fetch_ext_or_command_from_buf </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structext__or__cmd__t.html">ext_or_cmd_t</a> **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read <b>buf</b>, which should contain an Extended ORPort message from a transport proxy. If well-formed, create and populate <b>out</b> with the Extended ORport message. Return 0 if the buffer was incomplete, 1 if it was well-formed and -1 if we encountered an error while parsing it. </p>

</div>
</div>
<a id="ac0eaa6d554d8f3806529be908761c0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eaa6d554d8f3806529be908761c0b6">&#9670;&nbsp;</a></span>fetch_from_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fetch_from_buf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove <b>string_len</b> bytes from the front of <b>buf</b>, and store them into <b>string</b>. Return the new buffer size. <b>string_len</b> must be &lt;= the number of bytes on the buffer. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_ac0eaa6d554d8f3806529be908761c0b6_icgraph.png" border="0" usemap="#buffers_8h_ac0eaa6d554d8f3806529be908761c0b6_icgraph" alt=""/></div>
<map name="buffers_8h_ac0eaa6d554d8f3806529be908761c0b6_icgraph" id="buffers_8h_ac0eaa6d554d8f3806529be908761c0b6_icgraph">
<area shape="rect" id="node2" href="buffers_8h.html#a7be89c5c69293eab984961565d23288d" title="move_buf_to_buf" alt="" coords="191,5,313,32"/>
<area shape="rect" id="node3" href="connection_8h.html#ae60601e7b7dcca8ff9b8afbf86437f18" title="connection_fetch_from_buf" alt="" coords="163,56,341,83"/>
</map>
</div>

</div>
</div>
<a id="a1c180fbc5977d558988ab676dd87c1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c180fbc5977d558988ab676dd87c1de">&#9670;&nbsp;</a></span>fetch_from_buf_http()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fetch_from_buf_http </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>headers_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_headerlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>body_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>body_used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_bodylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>force_complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There is a (possibly incomplete) http statement on <b>buf</b>, of the form "\%s\\r\\n\\r\\n\%s", headers, body. (body may contain NULs.) If a) the headers include a Content-Length field and all bytes in the body are present, or b) there's no Content-Length field and all headers are present, then:</p>
<ul>
<li>strdup headers into <b>*headers_out</b>, and NUL-terminate it.</li>
<li>memdup body into <b>*body_out</b>, and NUL-terminate it.</li>
<li>Then remove them from <b>buf</b>, and return 1.</li>
<li>If headers or body is NULL, discard that part of the buf.</li>
<li>If a headers or body doesn't fit in the arg, return -1. (We ensure that the headers or body don't exceed max len, <em>even if</em> we're planning to discard them.)</li>
<li>If force_complete is true, then succeed even if not all of the content has arrived.</li>
</ul>
<p>Else, change nothing and return 0. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a1c180fbc5977d558988ab676dd87c1de_icgraph.png" border="0" usemap="#buffers_8h_a1c180fbc5977d558988ab676dd87c1de_icgraph" alt=""/></div>
<map name="buffers_8h_a1c180fbc5977d558988ab676dd87c1de_icgraph" id="buffers_8h_a1c180fbc5977d558988ab676dd87c1de_icgraph">
<area shape="rect" id="node2" href="connection_8h.html#a173a993b4f9bcc7522f35c56e65b615f" title="connection_fetch_from\l_buf_http" alt="" coords="192,5,347,47"/>
</map>
</div>

</div>
</div>
<a id="adc6d40f0e53e9bf0b10107d58c168072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6d40f0e53e9bf0b10107d58c168072">&#9670;&nbsp;</a></span>fetch_from_buf_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fetch_from_buf_line </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to read a single LF-terminated line from <b>buf</b>, and write it (including the LF), NUL-terminated, into the *<b>data_len</b> byte buffer at <b>data_out</b>. Set *<b>data_len</b> to the number of bytes in the line, not counting the terminating NUL. Return 1 if we read a whole line, return 0 if we don't have a whole line yet, and return -1 if the line length exceeds *<b>data_len</b>. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_adc6d40f0e53e9bf0b10107d58c168072_icgraph.png" border="0" usemap="#buffers_8h_adc6d40f0e53e9bf0b10107d58c168072_icgraph" alt=""/></div>
<map name="buffers_8h_adc6d40f0e53e9bf0b10107d58c168072_icgraph" id="buffers_8h_adc6d40f0e53e9bf0b10107d58c168072_icgraph">
<area shape="rect" id="node2" href="connection_8h.html#aabfe46bcf87eebc470a965412b5fca8e" title="connection_fetch_from\l_buf_line" alt="" coords="189,5,344,47"/>
</map>
</div>

</div>
</div>
<a id="a6953fec5d68167570512aa9f2876b052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6953fec5d68167570512aa9f2876b052">&#9670;&nbsp;</a></span>fetch_from_buf_socks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fetch_from_buf_socks </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsocks__request__t.html">socks_request_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>log_sockstype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>safe_socks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There is a (possibly incomplete) socks handshake on <b>buf</b>, of one of the forms</p><ul>
<li>socks4: "socksheader username\\0"</li>
<li>socks4a: "socksheader username\\0 destaddr\\0"</li>
<li>socks5 phase one: "version #methods methods"</li>
<li>socks5 phase two: "version command 0 addresstype..." If it's a complete and valid handshake, and destaddr fits in MAX_SOCKS_ADDR_LEN bytes, then pull the handshake off the buf, assign to <b>req</b>, and return 1.</li>
</ul>
<p>If it's invalid or too big, return -1.</p>
<p>Else it's not all there yet, leave buf alone and return 0.</p>
<p>If you want to specify the socks reply, write it into <b>req-&gt;reply</b> and set <b>req-&gt;replylen</b>, else leave <b>req-&gt;replylen</b> alone.</p>
<p>If <b>log_sockstype</b> is non-zero, then do a notice-level log of whether the connection is possibly leaking DNS requests locally or not.</p>
<p>If <b>safe_socks</b> is true, then reject unsafe socks protocols.</p>
<p>If returning 0 or -1, <b>req-&gt;address</b> and <b>req-&gt;port</b> are undefined. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a6953fec5d68167570512aa9f2876b052_cgraph.png" border="0" usemap="#buffers_8h_a6953fec5d68167570512aa9f2876b052_cgraph" alt=""/></div>
<map name="buffers_8h_a6953fec5d68167570512aa9f2876b052_cgraph" id="buffers_8h_a6953fec5d68167570512aa9f2876b052_cgraph">
<area shape="rect" id="node2" href="buffers_8c.html#a7edd798450e4be4093e3e0f581037334" title="buf_pullup" alt="" coords="204,5,285,32"/>
</map>
</div>

</div>
</div>
<a id="ad9068d877362a26c2e920b0a0e43c3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9068d877362a26c2e920b0a0e43c3d1">&#9670;&nbsp;</a></span>fetch_from_buf_socks_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fetch_from_buf_socks_client </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inspect a reply from SOCKS server stored in <b>buf</b> according to <b>state</b>, removing the protocol data upon success. Return 0 on incomplete response, 1 on success and -1 on error, in which case <b>reason</b> is set to a descriptive message (free() when finished with it).</p>
<p>As a special case, 2 is returned when user/pass is required during SOCKS5 handshake and user/pass is configured. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_ad9068d877362a26c2e920b0a0e43c3d1_cgraph.png" border="0" usemap="#buffers_8h_ad9068d877362a26c2e920b0a0e43c3d1_cgraph" alt=""/></div>
<map name="buffers_8h_ad9068d877362a26c2e920b0a0e43c3d1_cgraph" id="buffers_8h_ad9068d877362a26c2e920b0a0e43c3d1_cgraph">
<area shape="rect" id="node2" href="buffers_8c.html#a7edd798450e4be4093e3e0f581037334" title="buf_pullup" alt="" coords="204,13,285,39"/>
</map>
</div>

</div>
</div>
<a id="a485df8a6961e83b9102bc3eb9ddb149f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485df8a6961e83b9102bc3eb9ddb149f">&#9670;&nbsp;</a></span>fetch_var_cell_from_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fetch_var_cell_from_buf </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvar__cell__t.html">var_cell_t</a> **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linkproto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check <b>buf</b> for a variable-length cell according to the rules of link protocol version <b>linkproto</b>. If one is found, pull it off the buffer and assign a newly allocated <a class="el" href="structvar__cell__t.html">var_cell_t</a> to *<b>out</b>, and return 1. Return 0 if whatever is on the start of buf_t is not a variable-length cell. Return 1 and set *<b>out</b> to NULL if there seems to be the start of a variable-length cell on <b>buf</b>, but the whole thing isn't there yet. </p>

</div>
</div>
<a id="af267b3ef237ecb964046aed3b1d2afa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af267b3ef237ecb964046aed3b1d2afa2">&#9670;&nbsp;</a></span>flush_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flush_buf </td>
          <td>(</td>
          <td class="paramtype">tor_socket_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_flushlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data from <b>buf</b> to the socket <b>s</b>. Write at most <b>sz</b> bytes, decrement *<b>buf_flushlen</b> by the number of bytes actually written, and remove the written bytes from the buffer. Return the number of bytes written on success, -1 on failure. Return 0 if write() would block. </p>

</div>
</div>
<a id="af6561415a56da7c03881f2c453dac2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6561415a56da7c03881f2c453dac2a3">&#9670;&nbsp;</a></span>flush_buf_tls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flush_buf_tls </td>
          <td>(</td>
          <td class="paramtype">tor_tls_t *&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>flushlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_flushlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="buffers_8c.html#af267b3ef237ecb964046aed3b1d2afa2">flush_buf()</a>, but writes data to a TLS connection. Can write more than <b>flushlen</b> bytes. </p>

</div>
</div>
<a id="a7be89c5c69293eab984961565d23288d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be89c5c69293eab984961565d23288d">&#9670;&nbsp;</a></span>move_buf_to_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int move_buf_to_buf </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_flushlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move up to *<b>buf_flushlen</b> bytes from <b>buf_in</b> to <b>buf_out</b>, and modify *<b>buf_flushlen</b> appropriately. Return the number of bytes actually copied. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a7be89c5c69293eab984961565d23288d_cgraph.png" border="0" usemap="#buffers_8h_a7be89c5c69293eab984961565d23288d_cgraph" alt=""/></div>
<map name="buffers_8h_a7be89c5c69293eab984961565d23288d_cgraph" id="buffers_8h_a7be89c5c69293eab984961565d23288d_cgraph">
<area shape="rect" id="node2" href="buffers_8c.html#ac0eaa6d554d8f3806529be908761c0b6" title="fetch_from_buf" alt="" coords="176,5,285,32"/>
<area shape="rect" id="node3" href="buffers_8c.html#a7c2ec6a70255dc260a166de964a56874" title="write_to_buf" alt="" coords="184,56,277,83"/>
</map>
</div>

</div>
</div>
<a id="adf8c9bd7065eb165b5d7f64ab5094a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8c9bd7065eb165b5d7f64ab5094a6d">&#9670;&nbsp;</a></span>peek_buf_has_control0_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int peek_buf_has_control0_command </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 1 iff buf looks more like it has an (obsolete) v0 controller command on it than any valid v1 controller command. </p>

</div>
</div>
<a id="a486bc6925bb8ae53ca546f716096333e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486bc6925bb8ae53ca546f716096333e">&#9670;&nbsp;</a></span>read_to_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_to_buf </td>
          <td>(</td>
          <td class="paramtype">tor_socket_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>at_most</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>reached_eof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>socket_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from socket <b>s</b>, writing onto end of <b>buf</b>. Read at most <b>at_most</b> bytes, growing the buffer as necessary. If recv() returns 0 (because of EOF), set *<b>reached_eof</b> to 1 and return 0. Return -1 on error; else return the number of bytes read. </p>

</div>
</div>
<a id="ab8210656ac6aaa79c7216c0675508524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8210656ac6aaa79c7216c0675508524">&#9670;&nbsp;</a></span>read_to_buf_tls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_to_buf_tls </td>
          <td>(</td>
          <td class="paramtype">tor_tls_t *&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>at_most</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As read_to_buf, but reads from a TLS connection, and returns a TLS status value rather than the number of bytes read.</p>
<p>Using TLS on OR connections complicates matters in two ways.</p>
<p>First, a TLS stream has its own read buffer independent of the connection's read buffer. (TLS needs to read an entire frame from the network before it can decrypt any data. Thus, trying to read 1 byte from TLS can require that several KB be read from the network and decrypted. The extra data is stored in TLS's decrypt buffer.) Because the data hasn't been read by Tor (it's still inside the TLS), this means that sometimes a connection "has stuff to read" even when poll() didn't return POLLIN. The tor_tls_get_pending_bytes function is used in <a class="el" href="connection_8c.html" title="General high-level functions to handle reading and writing on connections. ">connection.c</a> to detect TLS objects with non-empty internal buffers and read from them again.</p>
<p>Second, the TLS stream's events do not correspond directly to network events: sometimes, before a TLS stream can read, the network must be ready to write &ndash; or vice versa. </p>

</div>
</div>
<a id="a9d88eae643ab99ae0fa364974dd43077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d88eae643ab99ae0fa364974dd43077">&#9670;&nbsp;</a></span>socks_request_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void socks_request_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsocks__request__t.html">socks_request_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free all storage held in the <a class="el" href="structsocks__request__t.html">socks_request_t</a> <b>req</b>. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a9d88eae643ab99ae0fa364974dd43077_cgraph.png" border="0" usemap="#buffers_8h_a9d88eae643ab99ae0fa364974dd43077_cgraph" alt=""/></div>
<map name="buffers_8h_a9d88eae643ab99ae0fa364974dd43077_cgraph" id="buffers_8h_a9d88eae643ab99ae0fa364974dd43077_cgraph">
<area shape="rect" id="node2" href="crypto_8c.html#a955f8d276e5213dd68600bf6dee0b9ae" title="memwipe" alt="" coords="189,5,268,32"/>
</map>
</div>

</div>
</div>
<a id="aacf3c3ffa8cdb33c72236cdfbacafacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf3c3ffa8cdb33c72236cdfbacafacc">&#9670;&nbsp;</a></span>socks_request_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsocks__request__t.html">socks_request_t</a>* socks_request_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new <a class="el" href="structsocks__request__t.html">socks_request_t</a>. </p>

</div>
</div>
<a id="a7c2ec6a70255dc260a166de964a56874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2ec6a70255dc260a166de964a56874">&#9670;&nbsp;</a></span>write_to_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_to_buf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append <b>string_len</b> bytes from <b>string</b> to the end of <b>buf</b>.</p>
<p>Return the new length of the buffer on success, -1 on failure. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffers_8h_a7c2ec6a70255dc260a166de964a56874_icgraph.png" border="0" usemap="#buffers_8h_a7c2ec6a70255dc260a166de964a56874_icgraph" alt=""/></div>
<map name="buffers_8h_a7c2ec6a70255dc260a166de964a56874_icgraph" id="buffers_8h_a7c2ec6a70255dc260a166de964a56874_icgraph">
<area shape="rect" id="node2" href="buffers_8h.html#a7be89c5c69293eab984961565d23288d" title="move_buf_to_buf" alt="" coords="147,5,269,32"/>
</map>
</div>

</div>
</div>
<a id="ab13ed2ec4453c0a1d8a46aa2566b0530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13ed2ec4453c0a1d8a46aa2566b0530">&#9670;&nbsp;</a></span>write_to_buf_zlib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_to_buf_zlib </td>
          <td>(</td>
          <td class="paramtype">buf_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtor__zlib__state__t.html">tor_zlib_state_t</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compress on uncompress the <b>data_len</b> bytes in <b>data</b> using the zlib state <b>state</b>, appending the result to <b>buf</b>. If <b>done</b> is true, flush the data in the state and finish the compression/uncompression. Return -1 on failure, 0 on success. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
