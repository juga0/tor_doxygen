<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: /home/user/_my/code/bwauth-related/tor/src/common/workqueue.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97b64286d42c5ef1697cb5f17129db19.html">tor</a></li><li class="navelem"><a class="el" href="dir_3cb0ba3f4b82dbe34a1a06276e96bc8d.html">src</a></li><li class="navelem"><a class="el" href="dir_b7e1585941a202f53e5249c42015d573.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">workqueue.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements worker threads, queues of work for them, and mechanisms for them to send answers back to the main thread.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;orconfig.h&quot;</code><br />
<code>#include &quot;compat.h&quot;</code><br />
<code>#include &quot;compat_threads.h&quot;</code><br />
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;workqueue.h&quot;</code><br />
<code>#include &quot;tor_queue.h&quot;</code><br />
<code>#include &quot;<a class="el" href="torlog_8h_source.html">torlog.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for workqueue.c:</div>
<div class="dyncontent">
<div class="center"><img src="workqueue_8c__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2common_2workqueue_8c" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2common_2workqueue_8c" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2common_2workqueue_8c">
<area shape="rect" id="node2" href="orconfig_8h_source.html" title="orconfig.h" alt="" coords="687,483,765,509"/>
<area shape="rect" id="node3" href="compat_8h_source.html" title="compat.h" alt="" coords="492,259,568,285"/>
<area shape="rect" id="node10" href="compat__threads_8h_source.html" title="compat_threads.h" alt="" coords="189,333,316,360"/>
<area shape="rect" id="node11" href="util_8h.html" title="Headers for util.c. " alt="" coords="798,109,849,136"/>
<area shape="rect" id="node15" href="workqueue_8h_source.html" title="workqueue.h" alt="" coords="517,109,613,136"/>
<area shape="rect" id="node16" href="tor__queue_8h_source.html" title="tor_queue.h" alt="" coords="1205,109,1295,136"/>
<area shape="rect" id="node17" href="torlog_8h.html" title="Headers for log.c. " alt="" coords="568,184,633,211"/>
<area shape="rect" id="node4" href="torint_8h.html" title="Header file to define uint32_t and friends. " alt="" coords="595,408,657,435"/>
<area shape="rect" id="node5" href="testsupport_8h_source.html" title="testsupport.h" alt="" coords="682,408,781,435"/>
<area shape="rect" id="node7" href="compat__time_8h.html" title="Functions and types for monotonic times. " alt="" coords="5,408,113,435"/>
<area shape="rect" id="node12" href="di__ops_8h.html" title="Headers for di_ops.c. " alt="" coords="811,333,881,360"/>
<area shape="rect" id="node14" href="util__bug_8h.html" title="util_bug.h" alt="" coords="861,184,940,211"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthreadpool__s.html">threadpool_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structworkqueue__entry__s.html">workqueue_entry_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreplyqueue__s.html">replyqueue_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structworkerthread__s.html">workerthread_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8b5173357adb02a86c027316e0acdfa0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#a8b5173357adb02a86c027316e0acdfa0">MAX_THREADS</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a8b5173357adb02a86c027316e0acdfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afc30b2ccf003a3a5ef48ac0113cc66a8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structworkerthread__s.html">workerthread_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#afc30b2ccf003a3a5ef48ac0113cc66a8">workerthread_t</a></td></tr>
<tr class="separator:afc30b2ccf003a3a5ef48ac0113cc66a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a19dc28519d407979f4a56f6c18a7f065"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#a19dc28519d407979f4a56f6c18a7f065">workqueue_entry_cancel</a> (<a class="el" href="structworkqueue__entry__s.html">workqueue_entry_t</a> *ent)</td></tr>
<tr class="separator:a19dc28519d407979f4a56f6c18a7f065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a0b8f55dd61486d6f30cf211078665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structworkqueue__entry__s.html">workqueue_entry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#af3a0b8f55dd61486d6f30cf211078665">threadpool_queue_work</a> (<a class="el" href="structthreadpool__s.html">threadpool_t</a> *pool, workqueue_reply_t(*fn)(void *, void *), void(*reply_fn)(void *), void *arg)</td></tr>
<tr class="separator:af3a0b8f55dd61486d6f30cf211078665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1d5fd74ac97b4fed12770bb380f86e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#aac1d5fd74ac97b4fed12770bb380f86e">threadpool_queue_update</a> (<a class="el" href="structthreadpool__s.html">threadpool_t</a> *pool, void *(*dup_fn)(void *), workqueue_reply_t(*fn)(void *, void *), void(*free_fn)(void *), void *arg)</td></tr>
<tr class="separator:aac1d5fd74ac97b4fed12770bb380f86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013cb0ab1ce586f5ab7d324416f9f1ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structthreadpool__s.html">threadpool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#a013cb0ab1ce586f5ab7d324416f9f1ff">threadpool_new</a> (int n_threads, <a class="el" href="structreplyqueue__s.html">replyqueue_t</a> *replyqueue, void *(*new_thread_state_fn)(void *), void(*free_thread_state_fn)(void *), void *arg)</td></tr>
<tr class="separator:a013cb0ab1ce586f5ab7d324416f9f1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42da84d55974d13389b6c50292f4e006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreplyqueue__s.html">replyqueue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#a42da84d55974d13389b6c50292f4e006">threadpool_get_replyqueue</a> (<a class="el" href="structthreadpool__s.html">threadpool_t</a> *tp)</td></tr>
<tr class="separator:a42da84d55974d13389b6c50292f4e006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bca099ce188de04027e4ef03fcbd97c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreplyqueue__s.html">replyqueue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#a5bca099ce188de04027e4ef03fcbd97c">replyqueue_new</a> (uint32_t alertsocks_flags)</td></tr>
<tr class="separator:a5bca099ce188de04027e4ef03fcbd97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0497e4b7e2eb081ad85944f03f63142"><td class="memItemLeft" align="right" valign="top">tor_socket_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#ab0497e4b7e2eb081ad85944f03f63142">replyqueue_get_socket</a> (<a class="el" href="structreplyqueue__s.html">replyqueue_t</a> *rq)</td></tr>
<tr class="separator:ab0497e4b7e2eb081ad85944f03f63142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c930d1373edce49d4c6d56ed0182cfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="workqueue_8c.html#a4c930d1373edce49d4c6d56ed0182cfe">replyqueue_process</a> (<a class="el" href="structreplyqueue__s.html">replyqueue_t</a> *queue)</td></tr>
<tr class="separator:a4c930d1373edce49d4c6d56ed0182cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements worker threads, queues of work for them, and mechanisms for them to send answers back to the main thread. </p>
<p>The main structure here is a threadpool_t : it manages a set of worker threads, a queue of pending work, and a reply queue. Every piece of work is a workqueue_entry_t, containing data to process and a function to process it with.</p>
<p>The main thread informs the worker threads of pending work by using a condition variable. The workers inform the main process of completed work by using an alert_sockets_t object, as implemented in <a class="el" href="compat__threads_8c.html" title="Cross-platform threading and inter-thread communication logic. (Platform-specific parts are written i...">compat_threads.c</a>.</p>
<p>The main thread can also queue an "update" that will be handled by all the workers. This is useful for updating state that all the workers share.</p>
<p>In Tor today, there is currently only one thread pool, used in <a class="el" href="cpuworker_8c.html" title="Uses the workqueue/threadpool code to farm CPU-intensive activities out to subprocesses. ">cpuworker.c</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8b5173357adb02a86c027316e0acdfa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5173357adb02a86c027316e0acdfa0">&#9670;&nbsp;</a></span>MAX_THREADS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_THREADS&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Don't have more than this many threads per pool. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="afc30b2ccf003a3a5ef48ac0113cc66a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc30b2ccf003a3a5ef48ac0113cc66a8">&#9670;&nbsp;</a></span>workerthread_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structworkerthread__s.html">workerthread_s</a>  <a class="el" href="workqueue_8c.html#afc30b2ccf003a3a5ef48ac0113cc66a8">workerthread_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A worker thread represents a single thread in a thread pool. To avoid contention, each gets its own queue. This breaks the guarantee that that queued work will get executed strictly in order. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab0497e4b7e2eb081ad85944f03f63142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0497e4b7e2eb081ad85944f03f63142">&#9670;&nbsp;</a></span>replyqueue_get_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tor_socket_t replyqueue_get_socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreplyqueue__s.html">replyqueue_t</a> *&#160;</td>
          <td class="paramname"><em>rq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the "read socket" for a given reply queue. The main thread should listen for read events on this socket, and call <a class="el" href="workqueue_8c.html#a4c930d1373edce49d4c6d56ed0182cfe">replyqueue_process()</a> every time it triggers. </p>

</div>
</div>
<a id="a5bca099ce188de04027e4ef03fcbd97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bca099ce188de04027e4ef03fcbd97c">&#9670;&nbsp;</a></span>replyqueue_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreplyqueue__s.html">replyqueue_t</a>* replyqueue_new </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>alertsocks_flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new reply queue. Reply queues are used to pass results from worker threads to the main thread. Since the main thread is running an IO-centric event loop, it needs to get woken up with means other than a condition variable. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="workqueue_8c_a5bca099ce188de04027e4ef03fcbd97c_icgraph.png" border="0" usemap="#workqueue_8c_a5bca099ce188de04027e4ef03fcbd97c_icgraph" alt=""/></div>
<map name="workqueue_8c_a5bca099ce188de04027e4ef03fcbd97c_icgraph" id="workqueue_8c_a5bca099ce188de04027e4ef03fcbd97c_icgraph">
<area shape="rect" id="node2" href="cpuworker_8h.html#a560ad8614ae03841a10b489f4370bc51" title="cpu_init" alt="" coords="169,5,236,32"/>
</map>
</div>

</div>
</div>
<a id="a4c930d1373edce49d4c6d56ed0182cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c930d1373edce49d4c6d56ed0182cfe">&#9670;&nbsp;</a></span>replyqueue_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void replyqueue_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreplyqueue__s.html">replyqueue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process all pending replies on a reply queue. The main thread should call this function every time the socket returned by <a class="el" href="workqueue_8c.html#ab0497e4b7e2eb081ad85944f03f63142">replyqueue_get_socket()</a> is readable. </p>

</div>
</div>
<a id="a42da84d55974d13389b6c50292f4e006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42da84d55974d13389b6c50292f4e006">&#9670;&nbsp;</a></span>threadpool_get_replyqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreplyqueue__s.html">replyqueue_t</a>* threadpool_get_replyqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthreadpool__s.html">threadpool_t</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the reply queue associated with a given thread pool. </p>

</div>
</div>
<a id="a013cb0ab1ce586f5ab7d324416f9f1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013cb0ab1ce586f5ab7d324416f9f1ff">&#9670;&nbsp;</a></span>threadpool_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthreadpool__s.html">threadpool_t</a>* threadpool_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreplyqueue__s.html">replyqueue_t</a> *&#160;</td>
          <td class="paramname"><em>replyqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>new_thread_state_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>free_thread_state_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a new thread pool with <b>n</b> worker threads, configured to send their output to <b>replyqueue</b>. The threads' states will be constructed with the <b>new_thread_state_fn</b> call, receiving <b>arg</b> as its argument. When the threads close, they will call <b>free_thread_state_fn</b> on their states. </p>

</div>
</div>
<a id="aac1d5fd74ac97b4fed12770bb380f86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1d5fd74ac97b4fed12770bb380f86e">&#9670;&nbsp;</a></span>threadpool_queue_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int threadpool_queue_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthreadpool__s.html">threadpool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>dup_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">workqueue_reply_t(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>free_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue a copy of a work item for every thread in a pool. This can be used, for example, to tell the threads to update some parameter in their states.</p>
<p>Arguments are as for <b>threadpool_queue_work</b>, except that the <b>arg</b> value is passed to <b>dup_fn</b> once per each thread to make a copy of it.</p>
<p>UPDATE FUNCTIONS MUST BE IDEMPOTENT. We do not guarantee that every update will be run. If a new update is scheduled before the old update finishes running, then the new will replace the old in any threads that haven't run it yet.</p>
<p>Return 0 on success, -1 on failure. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="workqueue_8c_aac1d5fd74ac97b4fed12770bb380f86e_cgraph.png" border="0" usemap="#workqueue_8c_aac1d5fd74ac97b4fed12770bb380f86e_cgraph" alt=""/></div>
<map name="workqueue_8c_aac1d5fd74ac97b4fed12770bb380f86e_cgraph" id="workqueue_8c_aac1d5fd74ac97b4fed12770bb380f86e_cgraph">
<area shape="rect" id="node2" href="compat__pthreads_8c.html#a8bfcc96866bdf76508915db8b252f746" title="tor_mutex_acquire" alt="" coords="224,5,353,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="workqueue_8c_aac1d5fd74ac97b4fed12770bb380f86e_icgraph.png" border="0" usemap="#workqueue_8c_aac1d5fd74ac97b4fed12770bb380f86e_icgraph" alt=""/></div>
<map name="workqueue_8c_aac1d5fd74ac97b4fed12770bb380f86e_icgraph" id="workqueue_8c_aac1d5fd74ac97b4fed12770bb380f86e_icgraph">
<area shape="rect" id="node2" href="cpuworker_8h.html#ab9e83641db8471cf0727e113713c278f" title="cpuworkers_rotate_keyinfo" alt="" coords="224,5,403,32"/>
</map>
</div>

</div>
</div>
<a id="af3a0b8f55dd61486d6f30cf211078665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a0b8f55dd61486d6f30cf211078665">&#9670;&nbsp;</a></span>threadpool_queue_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structworkqueue__entry__s.html">workqueue_entry_t</a>* threadpool_queue_work </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthreadpool__s.html">threadpool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">workqueue_reply_t(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>reply_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue an item of work for a thread in a thread pool. The function <b>fn</b> will be run in a worker thread, and will receive as arguments the thread's state object, and the provided object <b>arg</b>. It must return one of WQ_RPL_REPLY, WQ_RPL_ERROR, or WQ_RPL_SHUTDOWN.</p>
<p>Regardless of its return value, the function <b>reply_fn</b> will later be run in the main thread when it invokes <a class="el" href="workqueue_8c.html#a4c930d1373edce49d4c6d56ed0182cfe">replyqueue_process()</a>, and will receive as its argument the same <b>arg</b> object. It's the reply function's responsibility to free the work object.</p>
<p>On success, return a workqueue_entry_t object that can be passed to <a class="el" href="workqueue_8c.html#a19dc28519d407979f4a56f6c18a7f065">workqueue_entry_cancel()</a>. On failure, return NULL.</p>
<p>Note that because each thread has its own work queue, work items may not be executed strictly in order. </p>

</div>
</div>
<a id="a19dc28519d407979f4a56f6c18a7f065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dc28519d407979f4a56f6c18a7f065">&#9670;&nbsp;</a></span>workqueue_entry_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* workqueue_entry_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structworkqueue__entry__s.html">workqueue_entry_t</a> *&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel a workqueue_entry_t that has been returned from threadpool_queue_work.</p>
<p>You must not call this function on any work whose reply function has been executed in the main thread; that will cause undefined behavior (probably, a crash).</p>
<p>If the work is cancelled, this function return the argument passed to the work function. It is the caller's responsibility to free this storage.</p>
<p>This function will have no effect if the worker thread has already executed or begun to execute the work item. In that case, it will return NULL. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="workqueue_8c_a19dc28519d407979f4a56f6c18a7f065_cgraph.png" border="0" usemap="#workqueue_8c_a19dc28519d407979f4a56f6c18a7f065_cgraph" alt=""/></div>
<map name="workqueue_8c_a19dc28519d407979f4a56f6c18a7f065_cgraph" id="workqueue_8c_a19dc28519d407979f4a56f6c18a7f065_cgraph">
<area shape="rect" id="node2" href="compat__pthreads_8c.html#a8bfcc96866bdf76508915db8b252f746" title="tor_mutex_acquire" alt="" coords="220,5,349,32"/>
<area shape="rect" id="node3" href="compat__pthreads_8c.html#a3fc2298a8cb49803528daa6d35091372" title="tor_mutex_release" alt="" coords="220,56,349,83"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="workqueue_8c_a19dc28519d407979f4a56f6c18a7f065_icgraph.png" border="0" usemap="#workqueue_8c_a19dc28519d407979f4a56f6c18a7f065_icgraph" alt=""/></div>
<map name="workqueue_8c_a19dc28519d407979f4a56f6c18a7f065_icgraph" id="workqueue_8c_a19dc28519d407979f4a56f6c18a7f065_icgraph">
<area shape="rect" id="node2" href="cpuworker_8h.html#a1b4530118cd6e50e83a95454a6f22036" title="cpuworker_cancel_circ\l_handshake" alt="" coords="220,5,375,47"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
