<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: /home/user/_my/code/bwauth-related/tor/src/or/connection_edge.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97b64286d42c5ef1697cb5f17129db19.html">tor</a></li><li class="navelem"><a class="el" href="dir_3cb0ba3f4b82dbe34a1a06276e96bc8d.html">src</a></li><li class="navelem"><a class="el" href="dir_386635fabd7f6c74e9d9c7a8604514a0.html">or</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">connection_edge.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for <a class="el" href="connection__edge_8c.html" title="Handle edge streams. ">connection_edge.c</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;testsupport.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for connection_edge.h:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__edge_8h" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__edge_8h" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__edge_8h">
<area shape="rect" id="node2" href="testsupport_8h_source.html" title="testsupport.h" alt="" coords="42,109,141,136"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h__dep__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__edge_8hdep" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__edge_8hdep" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__edge_8hdep">
<area shape="rect" id="node2" href="addressmap_8c.html" title="The addressmap module manages the processes by which we rewrite addresses in client requess..." alt="" coords="5,109,153,165"/>
<area shape="rect" id="node3" href="buffers_8c.html" title="Implements a generic buffer interface. " alt="" coords="177,109,325,165"/>
<area shape="rect" id="node4" href="circpathbias_8c.html" title="Code to track success/failure rates of circuits built through different tor nodes, in an attempt to detect attacks where an attacker deliberately causes circuits to fail until the client choses a path they like. " alt="" coords="349,109,497,165"/>
<area shape="rect" id="node5" href="circuitbuild_8c.html" title="Implements the details of building circuits (by chosing paths, constructing/sending create/extend cel..." alt="" coords="521,109,669,165"/>
<area shape="rect" id="node6" href="circuitlist_8c.html" title="Manage the global circuit list, and looking up circuits within it. " alt="" coords="693,109,841,165"/>
<area shape="rect" id="node7" href="circuituse_8c.html" title="Launch the right sort of circuits and attach streams to them. " alt="" coords="865,109,1013,165"/>
<area shape="rect" id="node8" href="config_8c.html" title="Code to parse and interpret configuration files. " alt="" coords="1037,109,1185,165"/>
<area shape="rect" id="node9" href="connection_8c.html" title="General high&#45;level functions to handle reading and writing on connections. " alt="" coords="1209,109,1357,165"/>
<area shape="rect" id="node10" href="connection__edge_8c.html" title="Handle edge streams. " alt="" coords="1381,109,1553,165"/>
<area shape="rect" id="node11" href="control_8c.html" title="Implementation for Tor&#39;s control&#45;socket interface. " alt="" coords="1577,109,1725,165"/>
<area shape="rect" id="node12" href="directory_8c.html" title="Code to send and fetch directories and router descriptors via HTTP. Directories use dirserv..." alt="" coords="1749,109,1897,165"/>
<area shape="rect" id="node13" href="dns_8c.html" title="Implements a local cache for DNS results for Tor servers. This is implemented as a wrapper around Ada..." alt="" coords="1921,109,2069,165"/>
<area shape="rect" id="node14" href="dnsserv_8c.html" title="Implements client&#45;side DNS proxy server code. Note: this is the DNS Server code, not the Server DNS c..." alt="" coords="2093,109,2241,165"/>
<area shape="rect" id="node15" href="hibernate_8c.html" title="Functions to close listeners, stop allowing new circuits, etc in preparation for closing down or goin..." alt="" coords="2265,109,2413,165"/>
<area shape="rect" id="node16" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop..." alt="" coords="2437,109,2585,165"/>
<area shape="rect" id="node17" href="relay_8c.html" title="Handle relay cell encryption/decryption, plus packaging and receiving from circuits, plus queuing on circuits. " alt="" coords="2609,109,2757,165"/>
<area shape="rect" id="node18" href="rendclient_8c.html" title="Client code to access location&#45;hidden services. " alt="" coords="2781,109,2929,165"/>
</map>
</div>
</div>
<p><a href="connection__edge_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5a07fb699aff7aa934346540f577200a"><td class="memItemLeft" align="right" valign="top"><a id="a5a07fb699aff7aa934346540f577200a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>connection_mark_unattached_ap</b>(conn,  endreason)&#160;&#160;&#160;connection_mark_unattached_ap_((conn), (endreason), __LINE__, SHORT_FILE__)</td></tr>
<tr class="separator:a5a07fb699aff7aa934346540f577200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62510aa4279e60ae2c7bf79f09ccbfd"><td class="memItemLeft" align="right" valign="top"><a id="ac62510aa4279e60ae2c7bf79f09ccbfd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>connection_ap_mark_as_pending_circuit</b>(c)&#160;&#160;&#160;<a class="el" href="connection__edge_8h.html#a24992df08ad02820ad5a0998e7e44374">connection_ap_mark_as_pending_circuit_</a>((c), __FILE__, __LINE__)</td></tr>
<tr class="separator:ac62510aa4279e60ae2c7bf79f09ccbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a05c5cdcdfac964ca0fa721369703ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONNECTION_AP_EXPECT_NONPENDING</b>(c)</td></tr>
<tr class="separator:a1a05c5cdcdfac964ca0fa721369703ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Begin-cell flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These flags are used in RELAY_BEGIN cells to change the default behavior of the cell. </p>
</div></td></tr>
<tr class="memitem:ad8c006fe24d2dacd9abe12ced2400f08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#ad8c006fe24d2dacd9abe12ced2400f08">BEGIN_FLAG_IPV6_OK</a>&#160;&#160;&#160;(1u&lt;&lt;0)</td></tr>
<tr class="separator:ad8c006fe24d2dacd9abe12ced2400f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ff21586ae88049f1e0bbc504cdfdac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a75ff21586ae88049f1e0bbc504cdfdac">BEGIN_FLAG_IPV4_NOT_OK</a>&#160;&#160;&#160;(1u&lt;&lt;1)</td></tr>
<tr class="separator:a75ff21586ae88049f1e0bbc504cdfdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58956778d5b7cd2b04f1dc2bff74a35c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a58956778d5b7cd2b04f1dc2bff74a35c">BEGIN_FLAG_IPV6_PREFERRED</a>&#160;&#160;&#160;(1u&lt;&lt;2)</td></tr>
<tr class="separator:a58956778d5b7cd2b04f1dc2bff74a35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac6ca65932a6302ac960ebd72fdf741e2"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="connection__edge_8h.html#a6672882527624d0bebbc4e24b56cf105">hostname_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#ac6ca65932a6302ac960ebd72fdf741e2">hostname_type_t</a></td></tr>
<tr class="separator:ac6ca65932a6302ac960ebd72fdf741e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6672882527624d0bebbc4e24b56cf105"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a6672882527624d0bebbc4e24b56cf105">hostname_type_t</a> { <b>NORMAL_HOSTNAME</b>, 
<b>ONION_HOSTNAME</b>, 
<b>EXIT_HOSTNAME</b>, 
<b>BAD_HOSTNAME</b>
 }</td></tr>
<tr class="separator:a6672882527624d0bebbc4e24b56cf105"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb2d3959ea1dc4297fe8daa612201ee9"><td class="memItemLeft" align="right" valign="top"><a id="acb2d3959ea1dc4297fe8daa612201ee9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (void, connection_mark_unattached_ap_,(<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, int endreason, int line, const char *file))</td></tr>
<tr class="separator:acb2d3959ea1dc4297fe8daa612201ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa216dab9d4e712fa5c03e29bb058ee7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#aa216dab9d4e712fa5c03e29bb058ee7d">connection_edge_reached_eof</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:aa216dab9d4e712fa5c03e29bb058ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb9b70852e8b94a3aae49033285cfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#af7fb9b70852e8b94a3aae49033285cfc">connection_edge_process_inbuf</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn, int package_partial)</td></tr>
<tr class="separator:af7fb9b70852e8b94a3aae49033285cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dcd8839eb2e2bf00e5fd1c452f2a54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a80dcd8839eb2e2bf00e5fd1c452f2a54">connection_edge_destroy</a> (<a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> circ_id, <a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:a80dcd8839eb2e2bf00e5fd1c452f2a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32ca9441698867bcd01f43a7e615106"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#ab32ca9441698867bcd01f43a7e615106">connection_edge_end</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn, uint8_t reason)</td></tr>
<tr class="separator:ab32ca9441698867bcd01f43a7e615106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2063f1ab80516dc671a116ac139705e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#ab2063f1ab80516dc671a116ac139705e">connection_edge_end_errno</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:ab2063f1ab80516dc671a116ac139705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98855be3866a7e56063cefe658788fcd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a98855be3866a7e56063cefe658788fcd">connection_edge_flushed_some</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:a98855be3866a7e56063cefe658788fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d464ff322df919a496d6fdfba9dade"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a84d464ff322df919a496d6fdfba9dade">connection_edge_finished_flushing</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:a84d464ff322df919a496d6fdfba9dade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7fb4d3102044576a30d215e00840ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#aaf7fb4d3102044576a30d215e00840ce">connection_edge_finished_connecting</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:aaf7fb4d3102044576a30d215e00840ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85853fbc21482180df2c420192a84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a1a85853fbc21482180df2c420192a84b">connection_ap_about_to_close</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *edge_conn)</td></tr>
<tr class="separator:a1a85853fbc21482180df2c420192a84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6c052c5ede7819e5bf1b225fbfc6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a8a6c052c5ede7819e5bf1b225fbfc6b2">connection_exit_about_to_close</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *edge_conn)</td></tr>
<tr class="separator:a8a6c052c5ede7819e5bf1b225fbfc6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf52cba1e9b416e96cf47ea07f8f5ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a4bf52cba1e9b416e96cf47ea07f8f5ac">connection_ap_handshake_send_begin</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *ap_conn)</td></tr>
<tr class="separator:a4bf52cba1e9b416e96cf47ea07f8f5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc7f537dbc24a03116f0d6eb873a86d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a9bc7f537dbc24a03116f0d6eb873a86d">connection_ap_handshake_send_resolve</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *ap_conn)</td></tr>
<tr class="separator:a9bc7f537dbc24a03116f0d6eb873a86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0a22a402cbdeaa42a91ffc901db842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a3a0a22a402cbdeaa42a91ffc901db842">connection_ap_make_link</a> (<a class="el" href="structconnection__t.html">connection_t</a> *partner, char *address, uint16_t port, const char *digest, int session_group, int isolation_flags, int use_begindir, int want_onehop)</td></tr>
<tr class="separator:a3a0a22a402cbdeaa42a91ffc901db842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540f7850e71aa8140db0e2c6b4bb1993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a540f7850e71aa8140db0e2c6b4bb1993">connection_ap_handshake_socks_reply</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, char *reply, size_t replylen, int endreason)</td></tr>
<tr class="separator:a540f7850e71aa8140db0e2c6b4bb1993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a0f207c4fcf0ab7ddc082d4296887b"><td class="memItemLeft" align="right" valign="top"><a id="aa8a0f207c4fcf0ab7ddc082d4296887b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (void, connection_ap_handshake_socks_resolved,(<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, int answer_type, size_t answer_len, const uint8_t *answer, int ttl, time_t expires))</td></tr>
<tr class="separator:aa8a0f207c4fcf0ab7ddc082d4296887b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00dc220c37fedfbcafa495a160755ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#aa00dc220c37fedfbcafa495a160755ef">connection_ap_handshake_socks_resolved_addr</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *answer, int ttl, time_t expires)</td></tr>
<tr class="separator:aa00dc220c37fedfbcafa495a160755ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2916d0db0fd6c1551e29a3436308464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#ae2916d0db0fd6c1551e29a3436308464">connection_exit_begin_conn</a> (<a class="el" href="structcell__t.html">cell_t</a> *cell, <a class="el" href="structcircuit__t.html">circuit_t</a> *circ)</td></tr>
<tr class="separator:ae2916d0db0fd6c1551e29a3436308464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8805ef6708301581c9339e83f41e76e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a8805ef6708301581c9339e83f41e76e0">connection_exit_begin_resolve</a> (<a class="el" href="structcell__t.html">cell_t</a> *cell, <a class="el" href="structor__circuit__t.html">or_circuit_t</a> *circ)</td></tr>
<tr class="separator:a8805ef6708301581c9339e83f41e76e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1726a6cec89474d98905c4dd047d1c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#af1726a6cec89474d98905c4dd047d1c3">connection_exit_connect</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:af1726a6cec89474d98905c4dd047d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf4787c953075c4a9aeaab09bb2b3fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#accf4787c953075c4a9aeaab09bb2b3fe">connection_edge_is_rendezvous_stream</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:accf4787c953075c4a9aeaab09bb2b3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5473073c5eda464b105cc32bf941f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a4b5473073c5eda464b105cc32bf941f3">connection_ap_can_use_exit</a> (const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, const <a class="el" href="structnode__t.html">node_t</a> *exit)</td></tr>
<tr class="separator:a4b5473073c5eda464b105cc32bf941f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbef9941b20534da8fb058a85de8fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a3bbef9941b20534da8fb058a85de8fcf">connection_ap_expire_beginning</a> (void)</td></tr>
<tr class="separator:a3bbef9941b20534da8fb058a85de8fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab7b2a135e5085488d7534353db7eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a4ab7b2a135e5085488d7534353db7eed">connection_ap_rescan_and_attach_pending</a> (void)</td></tr>
<tr class="separator:a4ab7b2a135e5085488d7534353db7eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ca7733ddbd1bd01ea51010bf0b792a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#ab5ca7733ddbd1bd01ea51010bf0b792a">connection_ap_attach_pending</a> (int retry)</td></tr>
<tr class="separator:ab5ca7733ddbd1bd01ea51010bf0b792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24992df08ad02820ad5a0998e7e44374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a24992df08ad02820ad5a0998e7e44374">connection_ap_mark_as_pending_circuit_</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *entry_conn, const char *file, int line)</td></tr>
<tr class="separator:a24992df08ad02820ad5a0998e7e44374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2719fd77969767f856cb3fa69e6161be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a2719fd77969767f856cb3fa69e6161be">connection_ap_mark_as_non_pending_circuit</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *entry_conn)</td></tr>
<tr class="separator:a2719fd77969767f856cb3fa69e6161be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445e2c5d72915367befb2ba4d09eb679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a445e2c5d72915367befb2ba4d09eb679">connection_ap_fail_onehop</a> (const char *failed_digest, <a class="el" href="structcpath__build__state__t.html">cpath_build_state_t</a> *build_state)</td></tr>
<tr class="separator:a445e2c5d72915367befb2ba4d09eb679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebad477501c1981a317ca88a1dac7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#aeebad477501c1981a317ca88a1dac7f6">circuit_discard_optional_exit_enclaves</a> (<a class="el" href="structextend__info__t.html">extend_info_t</a> *info)</td></tr>
<tr class="separator:aeebad477501c1981a317ca88a1dac7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc7714d6e53e1ce4eaa07344fc8ba5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a44bc7714d6e53e1ce4eaa07344fc8ba5">connection_ap_detach_retriable</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ, int reason)</td></tr>
<tr class="separator:a44bc7714d6e53e1ce4eaa07344fc8ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742177da6145106592c773a1a53691c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a742177da6145106592c773a1a53691c1">connection_ap_process_transparent</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn)</td></tr>
<tr class="separator:a742177da6145106592c773a1a53691c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcc44ad1e8bee4747d1f5b1e34c9f88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a4dcc44ad1e8bee4747d1f5b1e34c9f88">address_is_invalid_destination</a> (const char *address, int client)</td></tr>
<tr class="separator:a4dcc44ad1e8bee4747d1f5b1e34c9f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b60847e224a01e865bb57afbbfedff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a32b60847e224a01e865bb57afbbfedff">connection_ap_rewrite_and_attach_if_allowed</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ, <a class="el" href="structcrypt__path__t.html">crypt_path_t</a> *cpath)</td></tr>
<tr class="separator:a32b60847e224a01e865bb57afbbfedff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089e626ea05b78585432718686a835e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a089e626ea05b78585432718686a835e2">connection_ap_handshake_rewrite_and_attach</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ, <a class="el" href="structcrypt__path__t.html">crypt_path_t</a> *cpath)</td></tr>
<tr class="separator:a089e626ea05b78585432718686a835e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f609919f0f88177960f67f162cbe2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="connection__edge_8h.html#a6672882527624d0bebbc4e24b56cf105">hostname_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a24f609919f0f88177960f67f162cbe2c">parse_extended_hostname</a> (char *address)</td></tr>
<tr class="separator:a24f609919f0f88177960f67f162cbe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0235c2c1859b9b614df618778ae3fde1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a0235c2c1859b9b614df618778ae3fde1">connection_edge_compatible_with_circuit</a> (const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, const <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ)</td></tr>
<tr class="separator:a0235c2c1859b9b614df618778ae3fde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ece387b44509bca78097fec1975263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#aa1ece387b44509bca78097fec1975263">connection_edge_update_circuit_isolation</a> (const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ, int dry_run)</td></tr>
<tr class="separator:aa1ece387b44509bca78097fec1975263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877a7fd7beb61ea88e8b5a1d66354f7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a877a7fd7beb61ea88e8b5a1d66354f7f">circuit_clear_isolation</a> (<a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ)</td></tr>
<tr class="separator:a877a7fd7beb61ea88e8b5a1d66354f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fce505c5ac663fd02992156aaf7d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="or_8h.html#a73c0506b3441b5715fa7affd5f8759fa">streamid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#ae4fce505c5ac663fd02992156aaf7d19">get_unique_stream_id_by_circ</a> (<a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ)</td></tr>
<tr class="separator:ae4fce505c5ac663fd02992156aaf7d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2255a4d834f5d2428dcf28091eeb20ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8h.html#a2255a4d834f5d2428dcf28091eeb20ba">connection_edge_free_all</a> (void)</td></tr>
<tr class="separator:a2255a4d834f5d2428dcf28091eeb20ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ac03065c538bfa791da16cac95746"><td class="memItemLeft" align="right" valign="top"><a id="a6b9ac03065c538bfa791da16cac95746"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>connection_ap_warn_and_unmark_if_pending_circ</b> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *entry_conn, const char *where)</td></tr>
<tr class="separator:a6b9ac03065c538bfa791da16cac95746"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for <a class="el" href="connection__edge_8c.html" title="Handle edge streams. ">connection_edge.c</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a75ff21586ae88049f1e0bbc504cdfdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ff21586ae88049f1e0bbc504cdfdac">&#9670;&nbsp;</a></span>BEGIN_FLAG_IPV4_NOT_OK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BEGIN_FLAG_IPV4_NOT_OK&#160;&#160;&#160;(1u&lt;&lt;1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, the client DOES NOT support connecting to IPv4 addresses. (The sense of this flag is inverted from IPV6_OK, so that the old default behavior of Tor is equivalent to having all flags set to 0.) </p>

</div>
</div>
<a id="ad8c006fe24d2dacd9abe12ced2400f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c006fe24d2dacd9abe12ced2400f08">&#9670;&nbsp;</a></span>BEGIN_FLAG_IPV6_OK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BEGIN_FLAG_IPV6_OK&#160;&#160;&#160;(1u&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, the client is willing to get connected to IPv6 addresses </p>

</div>
</div>
<a id="a58956778d5b7cd2b04f1dc2bff74a35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58956778d5b7cd2b04f1dc2bff74a35c">&#9670;&nbsp;</a></span>BEGIN_FLAG_IPV6_PREFERRED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BEGIN_FLAG_IPV6_PREFERRED&#160;&#160;&#160;(1u&lt;&lt;2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, if we find both an IPv4 and an IPv6 address, we use the IPv6 address. Otherwise we use the IPv4 address. </p>

</div>
</div>
<a id="a1a05c5cdcdfac964ca0fa721369703ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a05c5cdcdfac964ca0fa721369703ef">&#9670;&nbsp;</a></span>CONNECTION_AP_EXPECT_NONPENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONNECTION_AP_EXPECT_NONPENDING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                         \</div><div class="line">    if (<a class="code" href="or_8h.html#ae8e32e3ce198792c45ac72340f089bc4">ENTRY_TO_CONN</a>(c)-&gt;state == <a class="code" href="or_8h.html#a8e5dd7328fc7a8edc1449f4623a503f7">AP_CONN_STATE_CIRCUIT_WAIT</a>) {        \</div><div class="line">      log_warn(<a class="code" href="torlog_8h.html#aaed5930f414b821f3533f34f839707c8">LD_BUG</a>, <span class="stringliteral">&quot;At %s:%d: %p was unexpectedly in circuit_wait.&quot;</span>, \</div><div class="line">               __FILE__, __LINE__, (c));                                \</div><div class="line">      connection_ap_mark_as_non_pending_circuit(c);                     \</div><div class="line">    }                                                                   \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="or_8h_html_ae8e32e3ce198792c45ac72340f089bc4"><div class="ttname"><a href="or_8h.html#ae8e32e3ce198792c45ac72340f089bc4">ENTRY_TO_CONN</a></div><div class="ttdeci">#define ENTRY_TO_CONN(c)</div><div class="ttdef"><b>Definition:</b> or.h:1777</div></div>
<div class="ttc" id="or_8h_html_a8e5dd7328fc7a8edc1449f4623a503f7"><div class="ttname"><a href="or_8h.html#a8e5dd7328fc7a8edc1449f4623a503f7">AP_CONN_STATE_CIRCUIT_WAIT</a></div><div class="ttdeci">#define AP_CONN_STATE_CIRCUIT_WAIT</div><div class="ttdef"><b>Definition:</b> or.h:317</div></div>
<div class="ttc" id="torlog_8h_html_aaed5930f414b821f3533f34f839707c8"><div class="ttname"><a href="torlog_8h.html#aaed5930f414b821f3533f34f839707c8">LD_BUG</a></div><div class="ttdeci">#define LD_BUG</div><div class="ttdef"><b>Definition:</b> torlog.h:80</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac6ca65932a6302ac960ebd72fdf741e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ca65932a6302ac960ebd72fdf741e2">&#9670;&nbsp;</a></span>hostname_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="connection__edge_8h.html#a6672882527624d0bebbc4e24b56cf105">hostname_type_t</a>  <a class="el" href="connection__edge_8h.html#a6672882527624d0bebbc4e24b56cf105">hostname_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible return values for parse_extended_hostname. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6672882527624d0bebbc4e24b56cf105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6672882527624d0bebbc4e24b56cf105">&#9670;&nbsp;</a></span>hostname_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="connection__edge_8h.html#a6672882527624d0bebbc4e24b56cf105">hostname_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible return values for parse_extended_hostname. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4dcc44ad1e8bee4747d1f5b1e34c9f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcc44ad1e8bee4747d1f5b1e34c9f88">&#9670;&nbsp;</a></span>address_is_invalid_destination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int address_is_invalid_destination </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>client</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 1 if <b>address</b> has funny characters in it like colons. Return 0 if it's fine, or if we're configured to allow it anyway. <b>client</b> should be true if we're using this address as a client; false if we're using it as a server. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_a4dcc44ad1e8bee4747d1f5b1e34c9f88_cgraph.png" border="0" usemap="#connection__edge_8h_a4dcc44ad1e8bee4747d1f5b1e34c9f88_cgraph" alt=""/></div>
<map name="connection__edge_8h_a4dcc44ad1e8bee4747d1f5b1e34c9f88_cgraph" id="connection__edge_8h_a4dcc44ad1e8bee4747d1f5b1e34c9f88_cgraph">
<area shape="rect" id="node2" href="address_8c.html#a3cd537bd8104a89a5996793ee3f1d0dc" title="tor_addr_parse" alt="" coords="183,13,291,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_a4dcc44ad1e8bee4747d1f5b1e34c9f88_icgraph.png" border="0" usemap="#connection__edge_8h_a4dcc44ad1e8bee4747d1f5b1e34c9f88_icgraph" alt=""/></div>
<map name="connection__edge_8h_a4dcc44ad1e8bee4747d1f5b1e34c9f88_icgraph" id="connection__edge_8h_a4dcc44ad1e8bee4747d1f5b1e34c9f88_icgraph">
<area shape="rect" id="node2" href="config_8h.html#ad0680dcf72ca4379b07f06e83f2c2a21" title="addressmap_register_auto" alt="" coords="183,13,357,39"/>
</map>
</div>

</div>
</div>
<a id="a877a7fd7beb61ea88e8b5a1d66354f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877a7fd7beb61ea88e8b5a1d66354f7f">&#9670;&nbsp;</a></span>circuit_clear_isolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circuit_clear_isolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the isolation settings on <b>circ</b>.</p>
<p>This only works on an open circuit that has never had a stream attached to it, and whose isolation settings are hypothetical. (We set hypothetical isolation settings on circuits as we're launching them, so that we know whether they can handle more streams or whether we need to launch even more circuits. Once the circuit is open, if it turns out that we no longer have any streams to attach to it, we clear the isolation flags and data so that other streams can have a chance.) </p>

</div>
</div>
<a id="aeebad477501c1981a317ca88a1dac7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebad477501c1981a317ca88a1dac7f6">&#9670;&nbsp;</a></span>circuit_discard_optional_exit_enclaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circuit_discard_optional_exit_enclaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structextend__info__t.html">extend_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A circuit failed to finish on its last hop <b>info</b>. If there are any streams waiting with this exit node in mind, but they don't absolutely require it, make them give up on it. </p>

</div>
</div>
<a id="a1a85853fbc21482180df2c420192a84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a85853fbc21482180df2c420192a84b">&#9670;&nbsp;</a></span>connection_ap_about_to_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_about_to_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>entry_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when we're about to finally unlink and free an AP (client) connection: perform necessary accounting and cleanup </p>

</div>
</div>
<a id="ab5ca7733ddbd1bd01ea51010bf0b792a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ca7733ddbd1bd01ea51010bf0b792a">&#9670;&nbsp;</a></span>connection_ap_attach_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_attach_pending </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>retry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell any AP streams that are listed as waiting for a new circuit to try again, either attaching to an available circ or launching a new one.</p>
<p>If <b>retry</b> is false, only check the list if it contains at least one streams that we have not yet tried to attach to a circuit. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_ab5ca7733ddbd1bd01ea51010bf0b792a_icgraph.png" border="0" usemap="#connection__edge_8h_ab5ca7733ddbd1bd01ea51010bf0b792a_icgraph" alt=""/></div>
<map name="connection__edge_8h_ab5ca7733ddbd1bd01ea51010bf0b792a_icgraph" id="connection__edge_8h_ab5ca7733ddbd1bd01ea51010bf0b792a_icgraph">
<area shape="rect" id="node2" href="circuituse_8h.html#af4abb529971723bed7226e327b8326c3" title="circuit_try_attaching\l_streams" alt="" coords="203,5,341,47"/>
</map>
</div>

</div>
</div>
<a id="a4b5473073c5eda464b105cc32bf941f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5473073c5eda464b105cc32bf941f3">&#9670;&nbsp;</a></span>connection_ap_can_use_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_can_use_exit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnode__t.html">node_t</a> *&#160;</td>
          <td class="paramname"><em>exit_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 1 if router <b>exit_node</b> is likely to allow stream <b>conn</b> to exit from it, or 0 if it probably will not allow it. (We might be uncertain if conn's destination address has not yet been resolved.) </p>

</div>
</div>
<a id="a44bc7714d6e53e1ce4eaa07344fc8ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bc7714d6e53e1ce4eaa07344fc8ba5">&#9670;&nbsp;</a></span>connection_ap_detach_retriable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_detach_retriable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The AP connection <b>conn</b> has just failed while attaching or sending a BEGIN or resolving on <b>circ</b>, but another circuit might work. Detach the circuit, and either reattach it, launch a new circuit, tell the controller, or give up as appropriate.</p>
<p>Returns -1 on err, 1 on success, 0 on not-yet-sure. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_a44bc7714d6e53e1ce4eaa07344fc8ba5_cgraph.png" border="0" usemap="#connection__edge_8h_a44bc7714d6e53e1ce4eaa07344fc8ba5_cgraph" alt=""/></div>
<map name="connection__edge_8h_a44bc7714d6e53e1ce4eaa07344fc8ba5_cgraph" id="connection__edge_8h_a44bc7714d6e53e1ce4eaa07344fc8ba5_cgraph">
<area shape="rect" id="node2" href="control_8c.html#a9acf2608d05458d1a9e8531619363080" title="control_event_stream\l_status" alt="" coords="205,5,352,47"/>
</map>
</div>

</div>
</div>
<a id="a3bbef9941b20534da8fb058a85de8fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbef9941b20534da8fb058a85de8fcf">&#9670;&nbsp;</a></span>connection_ap_expire_beginning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_expire_beginning </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all general-purpose AP streams waiting for a response that sent their begin/resolve cell too long ago. Detach from their current circuit, and mark their current circuit as unsuitable for new streams. Then call <a class="el" href="circuituse_8c.html#a8d5c81bf7d6238331123b1e8753597f1">connection_ap_handshake_attach_circuit()</a> to attach to a new circuit (if available) or launch a new one.</p>
<p>For rendezvous streams, simply give up after SocksTimeout seconds (with no retry attempt). </p>

</div>
</div>
<a id="a445e2c5d72915367befb2ba4d09eb679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445e2c5d72915367befb2ba4d09eb679">&#9670;&nbsp;</a></span>connection_ap_fail_onehop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_fail_onehop </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>failed_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpath__build__state__t.html">cpath_build_state_t</a> *&#160;</td>
          <td class="paramname"><em>build_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell any AP streams that are waiting for a one-hop tunnel to <b>failed_digest</b> that they are going to fail. </p>

</div>
</div>
<a id="a089e626ea05b78585432718686a835e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089e626ea05b78585432718686a835e2">&#9670;&nbsp;</a></span>connection_ap_handshake_rewrite_and_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_handshake_rewrite_and_attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrypt__path__t.html">crypt_path_t</a> *&#160;</td>
          <td class="paramname"><em>cpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connection <b>conn</b> just finished its socks handshake, or the controller asked us to take care of it. If <b>circ</b> is defined, then that's where we'll want to attach it. Otherwise we have to figure it out ourselves.</p>
<p>First, parse whether it's a .exit address, remap it, and so on. Then if it's for a general circuit, try to attach it to a circuit (or launch one as needed), else if it's for a rendezvous circuit, fetch a rendezvous descriptor first (or attach/launch a circuit if the rendezvous descriptor is already here and fresh enough).</p>
<p>The stream will exit from the hop indicated by <b>cpath</b>, or from the last hop in circ's cpath if <b>cpath</b> is NULL. </p>

</div>
</div>
<a id="a4bf52cba1e9b416e96cf47ea07f8f5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf52cba1e9b416e96cf47ea07f8f5ac">&#9670;&nbsp;</a></span>connection_ap_handshake_send_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_handshake_send_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>ap_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a relay begin cell, using destaddr and destport from ap_conn's socks_request field, and send it down circ.</p>
<p>If ap_conn is broken, mark it for close and return -1. Else return 0. </p>

</div>
</div>
<a id="a9bc7f537dbc24a03116f0d6eb873a86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc7f537dbc24a03116f0d6eb873a86d">&#9670;&nbsp;</a></span>connection_ap_handshake_send_resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_handshake_send_resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>ap_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a relay resolve cell, using destaddr and destport from ap_conn's socks_request field, and send it down circ.</p>
<p>If ap_conn is broken, mark it for close and return -1. Else return 0. </p>

</div>
</div>
<a id="a540f7850e71aa8140db0e2c6b4bb1993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540f7850e71aa8140db0e2c6b4bb1993">&#9670;&nbsp;</a></span>connection_ap_handshake_socks_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_handshake_socks_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>reply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>replylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endreason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a socks reply to stream <b>conn</b>, using the appropriate socks version, etc, and mark <b>conn</b> as completed with SOCKS handshaking.</p>
<p>If <b>reply</b> is defined, then write <b>replylen</b> bytes of it to conn and return, else reply based on <b>endreason</b> (one of END_STREAM_REASON_*). If <b>reply</b> is undefined, <b>endreason</b> can't be 0 or REASON_DONE. Send endreason to the controller, if appropriate. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_a540f7850e71aa8140db0e2c6b4bb1993_cgraph.png" border="0" usemap="#connection__edge_8h_a540f7850e71aa8140db0e2c6b4bb1993_cgraph" alt=""/></div>
<map name="connection__edge_8h_a540f7850e71aa8140db0e2c6b4bb1993_cgraph" id="connection__edge_8h_a540f7850e71aa8140db0e2c6b4bb1993_cgraph">
<area shape="rect" id="node2" href="reasons_8c.html#a53d4b83ccf635050be0ac6123aa7d052" title="stream_end_reason_to\l_socks5_response" alt="" coords="229,5,384,47"/>
</map>
</div>

</div>
</div>
<a id="aa00dc220c37fedfbcafa495a160755ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00dc220c37fedfbcafa495a160755ef">&#9670;&nbsp;</a></span>connection_ap_handshake_socks_resolved_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_handshake_socks_resolved_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>answer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>expires</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As connection_ap_handshake_socks_resolved, but take a <a class="el" href="structtor__addr__t.html">tor_addr_t</a> to send as the answer. </p>

</div>
</div>
<a id="a3a0a22a402cbdeaa42a91ffc901db842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0a22a402cbdeaa42a91ffc901db842">&#9670;&nbsp;</a></span>connection_ap_make_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentry__connection__t.html">entry_connection_t</a>* connection_ap_make_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structconnection__t.html">connection_t</a> *&#160;</td>
          <td class="paramname"><em>partner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>session_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isolation_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_begindir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>want_onehop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an AP <a class="el" href="structconnection__t.html">connection_t</a> linked to the <a class="el" href="structconnection__t.html">connection_t</a> <b>partner</b>. make a new linked connection pair, and attach one side to the conn, connection_add it, initialize it to circuit_wait, and call connection_ap_handshake_attach_circuit(conn) on it.</p>
<p>Return the newly created end of the linked connection pair, or -1 if error. </p>

</div>
</div>
<a id="a2719fd77969767f856cb3fa69e6161be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2719fd77969767f856cb3fa69e6161be">&#9670;&nbsp;</a></span>connection_ap_mark_as_non_pending_circuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_mark_as_non_pending_circuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>entry_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark <b>entry_conn</b> as no longer waiting for a circuit. </p>

</div>
</div>
<a id="a24992df08ad02820ad5a0998e7e44374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24992df08ad02820ad5a0998e7e44374">&#9670;&nbsp;</a></span>connection_ap_mark_as_pending_circuit_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_mark_as_pending_circuit_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>entry_conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark <b>entry_conn</b> as needing to get attached to a circuit.</p>
<p>And <b>entry_conn</b> must be in AP_CONN_STATE_CIRCUIT_WAIT, should not already be pending a circuit. The circuit will get launched or the connection will get attached the next time we call <a class="el" href="connection__edge_8c.html#ab5ca7733ddbd1bd01ea51010bf0b792a">connection_ap_attach_pending()</a>. </p>

</div>
</div>
<a id="a742177da6145106592c773a1a53691c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742177da6145106592c773a1a53691c1">&#9670;&nbsp;</a></span>connection_ap_process_transparent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_process_transparent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>connection_init_accepted_conn() found a new trans AP conn. Get the original destination and send it to <a class="el" href="connection__edge_8c.html#a089e626ea05b78585432718686a835e2">connection_ap_handshake_rewrite_and_attach()</a>.</p>
<p>Return -1 if an unexpected error with conn (and it should be marked for close), else return 0. </p>

</div>
</div>
<a id="a4ab7b2a135e5085488d7534353db7eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab7b2a135e5085488d7534353db7eed">&#9670;&nbsp;</a></span>connection_ap_rescan_and_attach_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_rescan_and_attach_pending </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As connection_ap_attach_pending, but first scans the entire connection array to see if any elements are missing. </p>

</div>
</div>
<a id="a32b60847e224a01e865bb57afbbfedff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b60847e224a01e865bb57afbbfedff">&#9670;&nbsp;</a></span>connection_ap_rewrite_and_attach_if_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_rewrite_and_attach_if_allowed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrypt__path__t.html">crypt_path_t</a> *&#160;</td>
          <td class="paramname"><em>cpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <a class="el" href="connection__edge_8c.html#a089e626ea05b78585432718686a835e2">connection_ap_handshake_rewrite_and_attach()</a> unless a controller asked us to leave streams unattached. Return 0 in that case.</p>
<p>See <a class="el" href="connection__edge_8c.html#a089e626ea05b78585432718686a835e2">connection_ap_handshake_rewrite_and_attach()</a>'s documentation for arguments and return value. </p>

</div>
</div>
<a id="a0235c2c1859b9b614df618778ae3fde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0235c2c1859b9b614df618778ae3fde1">&#9670;&nbsp;</a></span>connection_edge_compatible_with_circuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_compatible_with_circuit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff none of the isolation flags and fields in <b>conn</b> should prevent it from being attached to <b>circ</b>. </p>

</div>
</div>
<a id="a80dcd8839eb2e2bf00e5fd1c452f2a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dcd8839eb2e2bf00e5fd1c452f2a54">&#9670;&nbsp;</a></span>connection_edge_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a>&#160;</td>
          <td class="paramname"><em>circ_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This edge needs to be closed, because its circuit has closed. Mark it for close and return 0. </p>

</div>
</div>
<a id="ab32ca9441698867bcd01f43a7e615106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32ca9441698867bcd01f43a7e615106">&#9670;&nbsp;</a></span>connection_edge_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a relay end cell from stream <b>conn</b> down conn's circuit, and remember that we've done so. If this is not a client connection, set the relay end cell's reason for closing as <b>reason</b>.</p>
<p>Return -1 if this function has already been called on this conn, else return 0. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_ab32ca9441698867bcd01f43a7e615106_icgraph.png" border="0" usemap="#connection__edge_8h_ab32ca9441698867bcd01f43a7e615106_icgraph" alt=""/></div>
<map name="connection__edge_8h_ab32ca9441698867bcd01f43a7e615106_icgraph" id="connection__edge_8h_ab32ca9441698867bcd01f43a7e615106_icgraph">
<area shape="rect" id="node2" href="connection__edge_8h.html#ab2063f1ab80516dc671a116ac139705e" title="connection_edge_end\l_errno" alt="" coords="201,5,349,47"/>
</map>
</div>

</div>
</div>
<a id="ab2063f1ab80516dc671a116ac139705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2063f1ab80516dc671a116ac139705e">&#9670;&nbsp;</a></span>connection_edge_end_errno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_end_errno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An error has just occurred on an operation on an edge connection <b>conn</b>. Extract the errno; convert it to an end reason, and send an appropriate relay end cell to the other end of the connection's circuit. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_ab2063f1ab80516dc671a116ac139705e_cgraph.png" border="0" usemap="#connection__edge_8h_ab2063f1ab80516dc671a116ac139705e_cgraph" alt=""/></div>
<map name="connection__edge_8h_ab2063f1ab80516dc671a116ac139705e_cgraph" id="connection__edge_8h_ab2063f1ab80516dc671a116ac139705e_cgraph">
<area shape="rect" id="node2" href="reasons_8c.html#a8829a9ed7a54cfa9242d7dc5d205da0b" title="errno_to_stream_end\l_reason" alt="" coords="203,5,347,47"/>
<area shape="rect" id="node3" href="connection__edge_8c.html#ab32ca9441698867bcd01f43a7e615106" title="connection_edge_end" alt="" coords="201,71,349,98"/>
</map>
</div>

</div>
</div>
<a id="aaf7fb4d3102044576a30d215e00840ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7fb4d3102044576a30d215e00840ce">&#9670;&nbsp;</a></span>connection_edge_finished_connecting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_finished_connecting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>edge_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connected handler for exit connections: start writing pending data, deliver 'CONNECTED' relay cells as appropriate, and check any pending data that may have been received. </p>

</div>
</div>
<a id="a84d464ff322df919a496d6fdfba9dade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d464ff322df919a496d6fdfba9dade">&#9670;&nbsp;</a></span>connection_edge_finished_flushing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_finished_flushing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connection <b>conn</b> has finished writing and has no bytes left on its outbuf.</p>
<p>If it's in state 'open', stop writing, consider responding with a sendme, and return. Otherwise, stop writing and return.</p>
<p>If <b>conn</b> is broken, mark it for close and return -1, else return 0. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_a84d464ff322df919a496d6fdfba9dade_cgraph.png" border="0" usemap="#connection__edge_8h_a84d464ff322df919a496d6fdfba9dade_cgraph" alt=""/></div>
<map name="connection__edge_8h_a84d464ff322df919a496d6fdfba9dade_cgraph" id="connection__edge_8h_a84d464ff322df919a496d6fdfba9dade_cgraph">
<area shape="rect" id="node2" href="relay_8c.html#a4e70e8fbfc6c89fa97102836a87a99c4" title="connection_edge_consider\l_sending_sendme" alt="" coords="225,23,401,65"/>
<area shape="rect" id="node3" href="connection_8c.html#a1a6be46082e23668c2cb0f323c171ad2" title="connection_outbuf_too_full" alt="" coords="449,5,627,32"/>
<area shape="rect" id="node4" href="circuitlist_8c.html#a60b5bc8820f7f98c15ea5c6999738997" title="circuit_get_by_edge_conn" alt="" coords="451,56,625,83"/>
</map>
</div>

</div>
</div>
<a id="a98855be3866a7e56063cefe658788fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98855be3866a7e56063cefe658788fcd">&#9670;&nbsp;</a></span>connection_edge_flushed_some()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_flushed_some </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We just wrote some data to <b>conn</b>; act appropriately.</p>
<p>(That is, if it's open, consider sending a stream-level sendme cell if we have just flushed enough.) </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_a98855be3866a7e56063cefe658788fcd_cgraph.png" border="0" usemap="#connection__edge_8h_a98855be3866a7e56063cefe658788fcd_cgraph" alt=""/></div>
<map name="connection__edge_8h_a98855be3866a7e56063cefe658788fcd_cgraph" id="connection__edge_8h_a98855be3866a7e56063cefe658788fcd_cgraph">
<area shape="rect" id="node2" href="relay_8c.html#a4e70e8fbfc6c89fa97102836a87a99c4" title="connection_edge_consider\l_sending_sendme" alt="" coords="261,23,437,65"/>
<area shape="rect" id="node3" href="connection_8c.html#a1a6be46082e23668c2cb0f323c171ad2" title="connection_outbuf_too_full" alt="" coords="485,5,663,32"/>
<area shape="rect" id="node4" href="circuitlist_8c.html#a60b5bc8820f7f98c15ea5c6999738997" title="circuit_get_by_edge_conn" alt="" coords="487,56,661,83"/>
</map>
</div>

</div>
</div>
<a id="a2255a4d834f5d2428dcf28091eeb20ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2255a4d834f5d2428dcf28091eeb20ba">&#9670;&nbsp;</a></span>connection_edge_free_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_edge_free_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free all storage held in module-scoped variables for <a class="el" href="connection__edge_8c.html" title="Handle edge streams. ">connection_edge.c</a> </p>

</div>
</div>
<a id="accf4787c953075c4a9aeaab09bb2b3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf4787c953075c4a9aeaab09bb2b3fe">&#9670;&nbsp;</a></span>connection_edge_is_rendezvous_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_is_rendezvous_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 1 if <b>conn</b> is a rendezvous stream, or 0 if it is a general stream. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_accf4787c953075c4a9aeaab09bb2b3fe_icgraph.png" border="0" usemap="#connection__edge_8h_accf4787c953075c4a9aeaab09bb2b3fe_icgraph" alt=""/></div>
<map name="connection__edge_8h_accf4787c953075c4a9aeaab09bb2b3fe_icgraph" id="connection__edge_8h_accf4787c953075c4a9aeaab09bb2b3fe_icgraph">
<area shape="rect" id="node2" href="circuituse_8h.html#a8d5c81bf7d6238331123b1e8753597f1" title="connection_ap_handshake\l_attach_circuit" alt="" coords="196,5,372,47"/>
<area shape="rect" id="node3" href="connection__edge_8c.html#a5922c995ab015f688168d02a6b954050" title="MOCK_IMPL" alt="" coords="234,71,334,98"/>
<area shape="rect" id="node4" href="connection__edge_8h.html#af1726a6cec89474d98905c4dd047d1c3" title="connection_exit_connect" alt="" coords="201,122,367,149"/>
</map>
</div>

</div>
</div>
<a id="af7fb9b70852e8b94a3aae49033285cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fb9b70852e8b94a3aae49033285cfc">&#9670;&nbsp;</a></span>connection_edge_process_inbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_process_inbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>package_partial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle new bytes on conn-&gt;inbuf based on state:</p><ul>
<li>If it's waiting for socks info, try to read another step of the socks handshake out of conn-&gt;inbuf.</li>
<li>If it's waiting for the original destination, fetch it.</li>
<li>If it's open, then package more relay cells from the stream.</li>
<li>Else, leave the bytes on inbuf alone for now.</li>
</ul>
<p>Mark and return -1 if there was an unexpected error with the conn, else return 0. </p>

</div>
</div>
<a id="aa216dab9d4e712fa5c03e29bb058ee7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa216dab9d4e712fa5c03e29bb058ee7d">&#9670;&nbsp;</a></span>connection_edge_reached_eof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_reached_eof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There was an EOF. Send an end and mark the connection for close. </p>

</div>
</div>
<a id="aa1ece387b44509bca78097fec1975263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ece387b44509bca78097fec1975263">&#9670;&nbsp;</a></span>connection_edge_update_circuit_isolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_update_circuit_isolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dry_run</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <b>dry_run</b> is false, update <b>circ</b>'s isolation flags and fields to reflect having had <b>conn</b> attached to it, and return 0. Otherwise, if <b>dry_run</b> is true, then make no changes to <b>circ</b>, and return a bitfield of isolation flags that we would have to set in isolation_flags_mixed to add <b>conn</b> to <b>circ</b>, or -1 if <b>circ</b> has had no streams attached to it. </p>

</div>
</div>
<a id="a8a6c052c5ede7819e5bf1b225fbfc6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6c052c5ede7819e5bf1b225fbfc6b2">&#9670;&nbsp;</a></span>connection_exit_about_to_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_exit_about_to_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>edge_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when we're about to finally unlink and free an exit connection: perform necessary accounting and cleanup </p>

</div>
</div>
<a id="ae2916d0db0fd6c1551e29a3436308464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2916d0db0fd6c1551e29a3436308464">&#9670;&nbsp;</a></span>connection_exit_begin_conn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_exit_begin_conn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcircuit__t.html">circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A relay 'begin' or 'begin_dir' cell has arrived, and either we are an exit hop for the circuit, or we are the origin and it is a rendezvous begin.</p>
<p>Launch a new exit connection and initialize things appropriately.</p>
<p>If it's a rendezvous stream, call <a class="el" href="connection__edge_8c.html#a64bdbd8f1352e1101d8a9a409049a057">connection_exit_connect()</a> on it.</p>
<p>For general streams, call <a class="el" href="dns_8c.html#aa1ffeb643093b409c75573a27574afbc">dns_resolve()</a> on it first, and only call <a class="el" href="connection__edge_8c.html#a64bdbd8f1352e1101d8a9a409049a057">connection_exit_connect()</a> if the dns answer is already known.</p>
<p>Note that we don't call connection_add() on the new stream! We wait for <a class="el" href="connection__edge_8c.html#a64bdbd8f1352e1101d8a9a409049a057">connection_exit_connect()</a> to do that.</p>
<p>Return -(some circuit end reason) if we want to tear down <b>circ</b>. Else return 0. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_ae2916d0db0fd6c1551e29a3436308464_cgraph.png" border="0" usemap="#connection__edge_8h_ae2916d0db0fd6c1551e29a3436308464_cgraph" alt=""/></div>
<map name="connection__edge_8h_ae2916d0db0fd6c1551e29a3436308464_cgraph" id="connection__edge_8h_ae2916d0db0fd6c1551e29a3436308464_cgraph">
<area shape="rect" id="node2" href="circuitlist_8c.html#a96a06b5b1f559dcb3747b599451df921" title="assert_circuit_ok" alt="" coords="240,5,361,32"/>
</map>
</div>

</div>
</div>
<a id="a8805ef6708301581c9339e83f41e76e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8805ef6708301581c9339e83f41e76e0">&#9670;&nbsp;</a></span>connection_exit_begin_resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_exit_begin_resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structor__circuit__t.html">or_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when we receive a RELAY_COMMAND_RESOLVE cell 'cell' along the circuit <b>circ</b>; begin resolving the hostname, and (eventually) reply with a RESOLVED cell. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_a8805ef6708301581c9339e83f41e76e0_cgraph.png" border="0" usemap="#connection__edge_8h_a8805ef6708301581c9339e83f41e76e0_cgraph" alt=""/></div>
<map name="connection__edge_8h_a8805ef6708301581c9339e83f41e76e0_cgraph" id="connection__edge_8h_a8805ef6708301581c9339e83f41e76e0_cgraph">
<area shape="rect" id="node2" href="circuitlist_8c.html#a96a06b5b1f559dcb3747b599451df921" title="assert_circuit_ok" alt="" coords="219,5,340,32"/>
<area shape="rect" id="node3" href="relay_8c.html#a9b06f0a66f2b1af9d4e0855225192e1d" title="relay_header_unpack" alt="" coords="207,56,352,83"/>
<area shape="rect" id="node5" href="connection_8c.html#a2ec50dd3f5bb871bf4a7058e4a57a754" title="edge_connection_new" alt="" coords="204,107,355,133"/>
<area shape="rect" id="node4" href="compat_8c.html#ae67679aa2827ab3a1378abb8a2b953cf" title="get_uint16" alt="" coords="403,56,485,83"/>
</map>
</div>

</div>
</div>
<a id="af1726a6cec89474d98905c4dd047d1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1726a6cec89474d98905c4dd047d1c3">&#9670;&nbsp;</a></span>connection_exit_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_exit_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>edge_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect to conn's specified addr and port. If it worked, conn has now been added to the connection_array.</p>
<p>Send back a connected cell. Include the resolved IP of the destination address, but <em>only</em> if it's a general exit stream. (Rendezvous streams must not reveal what IP they connected to.) </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8h_af1726a6cec89474d98905c4dd047d1c3_cgraph.png" border="0" usemap="#connection__edge_8h_af1726a6cec89474d98905c4dd047d1c3_cgraph" alt=""/></div>
<map name="connection__edge_8h_af1726a6cec89474d98905c4dd047d1c3_cgraph" id="connection__edge_8h_af1726a6cec89474d98905c4dd047d1c3_cgraph">
<area shape="rect" id="node2" href="connection__edge_8c.html#accf4787c953075c4a9aeaab09bb2b3fe" title="connection_edge_is\l_rendezvous_stream" alt="" coords="220,5,363,47"/>
</map>
</div>

</div>
</div>
<a id="ae4fce505c5ac663fd02992156aaf7d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fce505c5ac663fd02992156aaf7d19">&#9670;&nbsp;</a></span>get_unique_stream_id_by_circ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="or_8h.html#a73c0506b3441b5715fa7affd5f8759fa">streamid_t</a> get_unique_stream_id_by_circ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over the two bytes of stream_id until we get one that is not already in use; return it. Return 0 if can't get a unique stream_id. </p>

</div>
</div>
<a id="a24f609919f0f88177960f67f162cbe2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f609919f0f88177960f67f162cbe2c">&#9670;&nbsp;</a></span>parse_extended_hostname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="connection__edge_8h.html#a6672882527624d0bebbc4e24b56cf105">hostname_type_t</a> parse_extended_hostname </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If address is of the form "y.onion" with a well-formed handle y: Put a NUL after y, lower-case it, and return ONION_HOSTNAME.</p>
<p>If address is of the form "x.y.onion" with a well-formed handle x: Drop "x.", put a NUL after y, lower-case it, and return ONION_HOSTNAME.</p>
<p>If address is of the form "y.onion" with a badly-formed handle y: Return BAD_HOSTNAME and log a message.</p>
<p>If address is of the form "y.exit": Put a NUL after y and return EXIT_HOSTNAME.</p>
<p>Otherwise: Return NORMAL_HOSTNAME and change nothing. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
