<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: /home/user/_my/code/bwauth-related/tor/src/or/connection_edge.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97b64286d42c5ef1697cb5f17129db19.html">tor</a></li><li class="navelem"><a class="el" href="dir_3cb0ba3f4b82dbe34a1a06276e96bc8d.html">src</a></li><li class="navelem"><a class="el" href="dir_386635fabd7f6c74e9d9c7a8604514a0.html">or</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">connection_edge.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Handle edge streams.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="or_8h_source.html">or.h</a>&quot;</code><br />
<code>#include &quot;backtrace.h&quot;</code><br />
<code>#include &quot;addressmap.h&quot;</code><br />
<code>#include &quot;<a class="el" href="buffers_8h_source.html">buffers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="channel_8h_source.html">channel.h</a>&quot;</code><br />
<code>#include &quot;circpathbias.h&quot;</code><br />
<code>#include &quot;<a class="el" href="circuitlist_8h_source.html">circuitlist.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="circuituse_8h_source.html">circuituse.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="config_8h_source.html">config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="connection_8h_source.html">connection.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="connection__edge_8h_source.html">connection_edge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="connection__or_8h_source.html">connection_or.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="control_8h_source.html">control.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dns_8h_source.html">dns.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dnsserv_8h_source.html">dnsserv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="directory_8h_source.html">directory.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dirserv_8h_source.html">dirserv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hibernate_8h_source.html">hibernate.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="main_8h_source.html">main.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="nodelist_8h_source.html">nodelist.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="policies_8h_source.html">policies.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="reasons_8h_source.html">reasons.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="relay_8h_source.html">relay.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rendclient_8h_source.html">rendclient.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rendcommon_8h_source.html">rendcommon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rendservice_8h_source.html">rendservice.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rephist_8h_source.html">rephist.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="router_8h_source.html">router.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="routerlist_8h_source.html">routerlist.h</a>&quot;</code><br />
<code>#include &quot;routerset.h&quot;</code><br />
<code>#include &quot;<a class="el" href="circuitbuild_8h_source.html">circuitbuild.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for connection_edge.c:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__edge_8c" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__edge_8c" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__edge_8c">
<area shape="rect" id="node2" href="or_8h.html" title="Master header file for Tor&#45;specific functionality. " alt="" coords="779,259,823,285"/>
<area shape="rect" id="node20" href="backtrace_8h_source.html" title="backtrace.h" alt="" coords="5,557,96,584"/>
<area shape="rect" id="node21" href="addressmap_8h_source.html" title="addressmap.h" alt="" coords="1560,259,1664,285"/>
<area shape="rect" id="node22" href="buffers_8h.html" title="Header file for buffers.c. " alt="" coords="1607,184,1681,211"/>
<area shape="rect" id="node23" href="channel_8h.html" title="Header file for channel.c. " alt="" coords="1189,109,1267,136"/>
<area shape="rect" id="node25" href="circpathbias_8h_source.html" title="circpathbias.h" alt="" coords="1970,109,2073,136"/>
<area shape="rect" id="node26" href="circuitlist_8h.html" title="Header file for circuitlist.c. " alt="" coords="1705,184,1791,211"/>
<area shape="rect" id="node27" href="circuituse_8h.html" title="Header file for circuituse.c. " alt="" coords="2097,109,2186,136"/>
<area shape="rect" id="node28" href="config_8h.html" title="Header file for config.c. " alt="" coords="1793,259,1861,285"/>
<area shape="rect" id="node29" href="connection_8h.html" title="Header file for connection.c. " alt="" coords="1596,109,1692,136"/>
<area shape="rect" id="node30" href="connection__edge_8h.html" title="Header file for connection_edge.c. " alt="" coords="1865,184,1996,211"/>
<area shape="rect" id="node31" href="connection__or_8h.html" title="Header file for connection_or.c. " alt="" coords="2211,109,2325,136"/>
<area shape="rect" id="node32" href="control_8h.html" title="Header file for control.c. " alt="" coords="2349,109,2421,136"/>
<area shape="rect" id="node33" href="dns_8h.html" title="Header file for dns.c. " alt="" coords="2446,109,2501,136"/>
<area shape="rect" id="node34" href="dnsserv_8h.html" title="Header file for dnsserv.c. " alt="" coords="2525,109,2603,136"/>
<area shape="rect" id="node35" href="directory_8h.html" title="Header file for directory.c. " alt="" coords="2628,109,2711,136"/>
<area shape="rect" id="node36" href="dirserv_8h.html" title="Header file for dirserv.c. " alt="" coords="1973,259,2045,285"/>
<area shape="rect" id="node37" href="hibernate_8h.html" title="Header file for hibernate.c. " alt="" coords="1333,184,1419,211"/>
<area shape="rect" id="node38" href="main_8h.html" title="Header file for main.c. " alt="" coords="2735,109,2796,136"/>
<area shape="rect" id="node39" href="nodelist_8h.html" title="Header file for nodelist.c. " alt="" coords="2821,109,2899,136"/>
<area shape="rect" id="node40" href="policies_8h.html" title="Header file for policies.c. " alt="" coords="2924,109,3001,136"/>
<area shape="rect" id="node41" href="reasons_8h.html" title="Header file for reasons.c. " alt="" coords="3026,109,3105,136"/>
<area shape="rect" id="node42" href="relay_8h.html" title="Header file for relay.c. " alt="" coords="3129,109,3191,136"/>
<area shape="rect" id="node43" href="rendclient_8h.html" title="Header file for rendclient.c. " alt="" coords="3215,109,3305,136"/>
<area shape="rect" id="node44" href="rendcommon_8h.html" title="Header file for rendcommon.c. " alt="" coords="3329,109,3437,136"/>
<area shape="rect" id="node45" href="rendservice_8h.html" title="Header file for rendservice.c. " alt="" coords="933,184,1033,211"/>
<area shape="rect" id="node46" href="rephist_8h.html" title="Header file for rephist.c. " alt="" coords="3461,109,3533,136"/>
<area shape="rect" id="node47" href="router_8h.html" title="Header file for router.c. " alt="" coords="1419,259,1485,285"/>
<area shape="rect" id="node48" href="routerlist_8h.html" title="Header file for routerlist.c. " alt="" coords="1492,408,1575,435"/>
<area shape="rect" id="node49" href="routerset_8h_source.html" title="routerset.h" alt="" coords="3558,109,3642,136"/>
<area shape="rect" id="node50" href="circuitbuild_8h.html" title="Header file for circuitbuild.c. " alt="" coords="3666,109,3761,136"/>
<area shape="rect" id="node3" href="orconfig_8h_source.html" title="orconfig.h" alt="" coords="290,632,369,659"/>
<area shape="rect" id="node4" href="torint_8h.html" title="Header file to define uint32_t and friends. " alt="" coords="403,557,466,584"/>
<area shape="rect" id="node5" href="crypto_8h.html" title="Headers for crypto.c. " alt="" coords="1009,483,1079,509"/>
<area shape="rect" id="node7" href="crypto__format_8h_source.html" title="crypto_format.h" alt="" coords="542,333,655,360"/>
<area shape="rect" id="node8" href="crypto__ed25519_8h_source.html" title="crypto_ed25519.h" alt="" coords="536,408,661,435"/>
<area shape="rect" id="node9" href="crypto__curve25519_8h_source.html" title="crypto_curve25519.h" alt="" coords="418,483,561,509"/>
<area shape="rect" id="node10" href="tortls_8h.html" title="Headers for tortls.c. " alt="" coords="1163,408,1226,435"/>
<area shape="rect" id="node11" href="torlog_8h.html" title="Headers for log.c. " alt="" coords="1250,408,1315,435"/>
<area shape="rect" id="node12" href="container_8h_source.html" title="container.h" alt="" coords="273,408,359,435"/>
<area shape="rect" id="node13" href="torgzip_8h.html" title="Headers for torgzip.h. " alt="" coords="832,333,904,360"/>
<area shape="rect" id="node14" href="address_8h.html" title="Headers for address.h. " alt="" coords="225,333,303,360"/>
<area shape="rect" id="node15" href="compat__libevent_8h_source.html" title="compat_libevent.h" alt="" coords="857,483,985,509"/>
<area shape="rect" id="node16" href="ht_8h_source.html" title="ht.h" alt="" coords="929,333,973,360"/>
<area shape="rect" id="node17" href="replaycache_8h.html" title="Header file for replaycache.c. " alt="" coords="997,333,1099,360"/>
<area shape="rect" id="node18" href="tor__queue_8h_source.html" title="tor_queue.h" alt="" coords="1124,333,1215,360"/>
<area shape="rect" id="node19" href="util__format_8h_source.html" title="util_format.h" alt="" coords="687,483,782,509"/>
<area shape="rect" id="node6" href="testsupport_8h_source.html" title="testsupport.h" alt="" coords="1329,557,1428,584"/>
<area shape="rect" id="node24" href="circuitmux_8h.html" title="Header file for circuitmux.c. " alt="" coords="1181,184,1275,211"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae66018d32100c9325d38781d46a2a58b"><td class="memItemLeft" align="right" valign="top"><a id="ae66018d32100c9325d38781d46a2a58b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONNECTION_EDGE_PRIVATE</b></td></tr>
<tr class="separator:ae66018d32100c9325d38781d46a2a58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181d1c2dfda3f4931a4b03f9dee83d88"><td class="memItemLeft" align="right" valign="top"><a id="a181d1c2dfda3f4931a4b03f9dee83d88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SOCKS4_GRANTED</b>&#160;&#160;&#160;90</td></tr>
<tr class="separator:a181d1c2dfda3f4931a4b03f9dee83d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b202e0625ccc7c482e1a7a8ac26c646"><td class="memItemLeft" align="right" valign="top"><a id="a9b202e0625ccc7c482e1a7a8ac26c646"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SOCKS4_REJECT</b>&#160;&#160;&#160;91</td></tr>
<tr class="separator:a9b202e0625ccc7c482e1a7a8ac26c646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad45157fc66324423a41bcf49e8f1bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a3ad45157fc66324423a41bcf49e8f1bd">MAX_CONNECTED_CELL_PAYLOAD_LEN</a>&#160;&#160;&#160;25</td></tr>
<tr class="separator:a3ad45157fc66324423a41bcf49e8f1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4525b1e60c41eddb0e72c1f58fed7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UNMARK</b>()</td></tr>
<tr class="separator:a8b4525b1e60c41eddb0e72c1f58fed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9c7ef40eaccff126b5ccf8e5d79c60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a7c9c7ef40eaccff126b5ccf8e5d79c60">TRACKHOSTEXITS_RETRIES</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a7c9c7ef40eaccff126b5ccf8e5d79c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a44ad70160019e51ccb18714047336"><td class="memItemLeft" align="right" valign="top"><a id="aa4a44ad70160019e51ccb18714047336"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WARN_INTRVL_LOOP</b>&#160;&#160;&#160;300</td></tr>
<tr class="separator:aa4a44ad70160019e51ccb18714047336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bab4e31e2969b0339cdfc7a604cf99b"><td class="memItemLeft" align="right" valign="top"><a id="a8bab4e31e2969b0339cdfc7a604cf99b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WARN_INTRVL_PRIV</b>&#160;&#160;&#160;300</td></tr>
<tr class="separator:a8bab4e31e2969b0339cdfc7a604cf99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5922c995ab015f688168d02a6b954050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a5922c995ab015f688168d02a6b954050">MOCK_IMPL</a> (void, connection_mark_unattached_ap_,(<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, int endreason, int line, const char *file))</td></tr>
<tr class="separator:a5922c995ab015f688168d02a6b954050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa216dab9d4e712fa5c03e29bb058ee7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#aa216dab9d4e712fa5c03e29bb058ee7d">connection_edge_reached_eof</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:aa216dab9d4e712fa5c03e29bb058ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb9b70852e8b94a3aae49033285cfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#af7fb9b70852e8b94a3aae49033285cfc">connection_edge_process_inbuf</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn, int package_partial)</td></tr>
<tr class="separator:af7fb9b70852e8b94a3aae49033285cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dcd8839eb2e2bf00e5fd1c452f2a54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a80dcd8839eb2e2bf00e5fd1c452f2a54">connection_edge_destroy</a> (<a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> circ_id, <a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:a80dcd8839eb2e2bf00e5fd1c452f2a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32ca9441698867bcd01f43a7e615106"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#ab32ca9441698867bcd01f43a7e615106">connection_edge_end</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn, uint8_t reason)</td></tr>
<tr class="separator:ab32ca9441698867bcd01f43a7e615106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2063f1ab80516dc671a116ac139705e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#ab2063f1ab80516dc671a116ac139705e">connection_edge_end_errno</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:ab2063f1ab80516dc671a116ac139705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98855be3866a7e56063cefe658788fcd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a98855be3866a7e56063cefe658788fcd">connection_edge_flushed_some</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:a98855be3866a7e56063cefe658788fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d464ff322df919a496d6fdfba9dade"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a84d464ff322df919a496d6fdfba9dade">connection_edge_finished_flushing</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:a84d464ff322df919a496d6fdfba9dade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ce7ce66878c70c20abf54fdb922185"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a49ce7ce66878c70c20abf54fdb922185">connected_cell_format_payload</a> (uint8_t *payload_out, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr, uint32_t ttl)</td></tr>
<tr class="separator:a49ce7ce66878c70c20abf54fdb922185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a8fec1a11119f7ff891ea0c5d8aa22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a80a8fec1a11119f7ff891ea0c5d8aa22">connection_edge_finished_connecting</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *edge_conn)</td></tr>
<tr class="separator:a80a8fec1a11119f7ff891ea0c5d8aa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58a63d2d02be560117a2a37b5e53b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#ac58a63d2d02be560117a2a37b5e53b8f">connection_ap_about_to_close</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *entry_conn)</td></tr>
<tr class="separator:ac58a63d2d02be560117a2a37b5e53b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6c052c5ede7819e5bf1b225fbfc6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a8a6c052c5ede7819e5bf1b225fbfc6b2">connection_exit_about_to_close</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *edge_conn)</td></tr>
<tr class="separator:a8a6c052c5ede7819e5bf1b225fbfc6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbef9941b20534da8fb058a85de8fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a3bbef9941b20534da8fb058a85de8fcf">connection_ap_expire_beginning</a> (void)</td></tr>
<tr class="separator:a3bbef9941b20534da8fb058a85de8fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab7b2a135e5085488d7534353db7eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a4ab7b2a135e5085488d7534353db7eed">connection_ap_rescan_and_attach_pending</a> (void)</td></tr>
<tr class="separator:a4ab7b2a135e5085488d7534353db7eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ca7733ddbd1bd01ea51010bf0b792a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#ab5ca7733ddbd1bd01ea51010bf0b792a">connection_ap_attach_pending</a> (int retry)</td></tr>
<tr class="separator:ab5ca7733ddbd1bd01ea51010bf0b792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fdd87ac5ecb745896b17f623b85a69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a76fdd87ac5ecb745896b17f623b85a69">connection_ap_mark_as_pending_circuit_</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *entry_conn, const char *fname, int lineno)</td></tr>
<tr class="separator:a76fdd87ac5ecb745896b17f623b85a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2719fd77969767f856cb3fa69e6161be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a2719fd77969767f856cb3fa69e6161be">connection_ap_mark_as_non_pending_circuit</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *entry_conn)</td></tr>
<tr class="separator:a2719fd77969767f856cb3fa69e6161be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ac03065c538bfa791da16cac95746"><td class="memItemLeft" align="right" valign="top"><a id="a6b9ac03065c538bfa791da16cac95746"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>connection_ap_warn_and_unmark_if_pending_circ</b> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *entry_conn, const char *where)</td></tr>
<tr class="separator:a6b9ac03065c538bfa791da16cac95746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445e2c5d72915367befb2ba4d09eb679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a445e2c5d72915367befb2ba4d09eb679">connection_ap_fail_onehop</a> (const char *failed_digest, <a class="el" href="structcpath__build__state__t.html">cpath_build_state_t</a> *build_state)</td></tr>
<tr class="separator:a445e2c5d72915367befb2ba4d09eb679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebad477501c1981a317ca88a1dac7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#aeebad477501c1981a317ca88a1dac7f6">circuit_discard_optional_exit_enclaves</a> (<a class="el" href="structextend__info__t.html">extend_info_t</a> *info)</td></tr>
<tr class="separator:aeebad477501c1981a317ca88a1dac7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc7714d6e53e1ce4eaa07344fc8ba5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a44bc7714d6e53e1ce4eaa07344fc8ba5">connection_ap_detach_retriable</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ, int reason)</td></tr>
<tr class="separator:a44bc7714d6e53e1ce4eaa07344fc8ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b60847e224a01e865bb57afbbfedff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a32b60847e224a01e865bb57afbbfedff">connection_ap_rewrite_and_attach_if_allowed</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ, <a class="el" href="structcrypt__path__t.html">crypt_path_t</a> *cpath)</td></tr>
<tr class="separator:a32b60847e224a01e865bb57afbbfedff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2398922ce23ec9d3eb06839b388674"><td class="memItemLeft" align="right" valign="top"><a id="a9a2398922ce23ec9d3eb06839b388674"></a>
STATIC void&#160;</td><td class="memItemRight" valign="bottom"><b>connection_ap_handshake_rewrite</b> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, rewrite_result_t *out)</td></tr>
<tr class="separator:a9a2398922ce23ec9d3eb06839b388674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089e626ea05b78585432718686a835e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a089e626ea05b78585432718686a835e2">connection_ap_handshake_rewrite_and_attach</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ, <a class="el" href="structcrypt__path__t.html">crypt_path_t</a> *cpath)</td></tr>
<tr class="separator:a089e626ea05b78585432718686a835e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742177da6145106592c773a1a53691c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a742177da6145106592c773a1a53691c1">connection_ap_process_transparent</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn)</td></tr>
<tr class="separator:a742177da6145106592c773a1a53691c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fce505c5ac663fd02992156aaf7d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="or_8h.html#a73c0506b3441b5715fa7affd5f8759fa">streamid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#ae4fce505c5ac663fd02992156aaf7d19">get_unique_stream_id_by_circ</a> (<a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ)</td></tr>
<tr class="separator:ae4fce505c5ac663fd02992156aaf7d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf52cba1e9b416e96cf47ea07f8f5ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a4bf52cba1e9b416e96cf47ea07f8f5ac">connection_ap_handshake_send_begin</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *ap_conn)</td></tr>
<tr class="separator:a4bf52cba1e9b416e96cf47ea07f8f5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc7f537dbc24a03116f0d6eb873a86d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a9bc7f537dbc24a03116f0d6eb873a86d">connection_ap_handshake_send_resolve</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *ap_conn)</td></tr>
<tr class="separator:a9bc7f537dbc24a03116f0d6eb873a86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0a22a402cbdeaa42a91ffc901db842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a3a0a22a402cbdeaa42a91ffc901db842">connection_ap_make_link</a> (<a class="el" href="structconnection__t.html">connection_t</a> *partner, char *address, uint16_t port, const char *digest, int session_group, int isolation_flags, int use_begindir, int want_onehop)</td></tr>
<tr class="separator:a3a0a22a402cbdeaa42a91ffc901db842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00dc220c37fedfbcafa495a160755ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#aa00dc220c37fedfbcafa495a160755ef">connection_ap_handshake_socks_resolved_addr</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *answer, int ttl, time_t expires)</td></tr>
<tr class="separator:aa00dc220c37fedfbcafa495a160755ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f065a4c221152890ce1ac2c838e0e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a79f065a4c221152890ce1ac2c838e0e8">MOCK_IMPL</a> (void, connection_ap_handshake_socks_resolved,(<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, int answer_type, size_t answer_len, const uint8_t *answer, int ttl, time_t expires))</td></tr>
<tr class="separator:a79f065a4c221152890ce1ac2c838e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540f7850e71aa8140db0e2c6b4bb1993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a540f7850e71aa8140db0e2c6b4bb1993">connection_ap_handshake_socks_reply</a> (<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, char *reply, size_t replylen, int endreason)</td></tr>
<tr class="separator:a540f7850e71aa8140db0e2c6b4bb1993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2c59dfc51d377036486ec06428508b"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#abf2c59dfc51d377036486ec06428508b">begin_cell_parse</a> (const <a class="el" href="structcell__t.html">cell_t</a> *cell, begin_cell_t *bcell, uint8_t *end_reason_out)</td></tr>
<tr class="separator:abf2c59dfc51d377036486ec06428508b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2916d0db0fd6c1551e29a3436308464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#ae2916d0db0fd6c1551e29a3436308464">connection_exit_begin_conn</a> (<a class="el" href="structcell__t.html">cell_t</a> *cell, <a class="el" href="structcircuit__t.html">circuit_t</a> *circ)</td></tr>
<tr class="separator:ae2916d0db0fd6c1551e29a3436308464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8805ef6708301581c9339e83f41e76e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a8805ef6708301581c9339e83f41e76e0">connection_exit_begin_resolve</a> (<a class="el" href="structcell__t.html">cell_t</a> *cell, <a class="el" href="structor__circuit__t.html">or_circuit_t</a> *circ)</td></tr>
<tr class="separator:a8805ef6708301581c9339e83f41e76e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bdbd8f1352e1101d8a9a409049a057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a64bdbd8f1352e1101d8a9a409049a057">connection_exit_connect</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *edge_conn)</td></tr>
<tr class="separator:a64bdbd8f1352e1101d8a9a409049a057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf4787c953075c4a9aeaab09bb2b3fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#accf4787c953075c4a9aeaab09bb2b3fe">connection_edge_is_rendezvous_stream</a> (<a class="el" href="structedge__connection__t.html">edge_connection_t</a> *conn)</td></tr>
<tr class="separator:accf4787c953075c4a9aeaab09bb2b3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96677b281964b70945e9f3cb892c0f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#aa96677b281964b70945e9f3cb892c0f3">connection_ap_can_use_exit</a> (const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, const <a class="el" href="structnode__t.html">node_t</a> *exit_node)</td></tr>
<tr class="separator:aa96677b281964b70945e9f3cb892c0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f609919f0f88177960f67f162cbe2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="connection__edge_8h.html#a6672882527624d0bebbc4e24b56cf105">hostname_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a24f609919f0f88177960f67f162cbe2c">parse_extended_hostname</a> (char *address)</td></tr>
<tr class="separator:a24f609919f0f88177960f67f162cbe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0235c2c1859b9b614df618778ae3fde1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a0235c2c1859b9b614df618778ae3fde1">connection_edge_compatible_with_circuit</a> (const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, const <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ)</td></tr>
<tr class="separator:a0235c2c1859b9b614df618778ae3fde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ece387b44509bca78097fec1975263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#aa1ece387b44509bca78097fec1975263">connection_edge_update_circuit_isolation</a> (const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ, int dry_run)</td></tr>
<tr class="separator:aa1ece387b44509bca78097fec1975263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877a7fd7beb61ea88e8b5a1d66354f7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a877a7fd7beb61ea88e8b5a1d66354f7f">circuit_clear_isolation</a> (<a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *circ)</td></tr>
<tr class="separator:a877a7fd7beb61ea88e8b5a1d66354f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2255a4d834f5d2428dcf28091eeb20ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__edge_8c.html#a2255a4d834f5d2428dcf28091eeb20ba">connection_edge_free_all</a> (void)</td></tr>
<tr class="separator:a2255a4d834f5d2428dcf28091eeb20ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Handle edge streams. </p>
<p>An <a class="el" href="structedge__connection__t.html">edge_connection_t</a> is a subtype of a <a class="el" href="structconnection__t.html">connection_t</a>, and represents two critical concepts in Tor: a stream, and an edge connection. From the Tor protocol's point of view, a stream is a bi-directional channel that is multiplexed on a single circuit. Each stream on a circuit is identified with a separate 16-bit stream ID, local to the (circuit,exit) pair. Streams are created in response to client requests.</p>
<p>An edge connection is one thing that can implement a stream: it is either a TCP application socket that has arrived via (e.g.) a SOCKS request, or an exit connection.</p>
<p>Not every instance of <a class="el" href="structedge__connection__t.html">edge_connection_t</a> truly represents an edge connction, however. (Sorry!) We also create <a class="el" href="structedge__connection__t.html">edge_connection_t</a> objects for streams that we will not be handling with TCP. The types of these streams are: </p><ul>
<li>
DNS lookup streams, created on the client side in response to a UDP DNS request received on a DNSPort, or a RESOLVE command on a controller. </li>
<li>
DNS lookup streams, created on the exit side in response to a RELAY_RESOLVE cell from a client. </li>
<li>
Tunneled directory streams, created on the directory cache side in response to a RELAY_BEGINDIR cell. These streams attach directly to a <a class="el" href="structdir__connection__t.html">dir_connection_t</a> object without ever using TCP. </li>
</ul>
<p>This module handles general-purpose functionality having to do with <a class="el" href="structedge__connection__t.html">edge_connection_t</a>. On the client side, it accepts various types of application requests on SocksPorts, TransPorts, and NATDPorts, and creates streams appropriately.</p>
<p>This module is also responsible for implementing stream isolation: ensuring that streams that should not be linkable to one another are kept to different circuits.</p>
<p>On the exit side, this module handles the various stream-creating type of RELAY cells by launching appropriate outgoing connections, DNS requests, or directory connection objects.</p>
<p>And for all edge connections, this module is responsible for handling incoming and outdoing data as it arrives or leaves in the <a class="el" href="relay_8c.html" title="Handle relay cell encryption/decryption, plus packaging and receiving from circuits, plus queuing on circuits. ">relay.c</a> module. (Outgoing data will be packaged in <a class="el" href="connection__edge_8c.html#af7fb9b70852e8b94a3aae49033285cfc">connection_edge_process_inbuf()</a> as it calls <a class="el" href="relay_8c.html#ae6ab21527807bd31cd8a8559693ac35c">connection_edge_package_raw_inbuf()</a>; incoming data from RELAY_DATA cells is applied in connection_edge_process_relay_cell().) </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3ad45157fc66324423a41bcf49e8f1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad45157fc66324423a41bcf49e8f1bd">&#9670;&nbsp;</a></span>MAX_CONNECTED_CELL_PAYLOAD_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_CONNECTED_CELL_PAYLOAD_LEN&#160;&#160;&#160;25</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Longest size for the relay payload of a RELAY_CONNECTED cell that we're able to generate. </p>

</div>
</div>
<a id="a7c9c7ef40eaccff126b5ccf8e5d79c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9c7ef40eaccff126b5ccf8e5d79c60">&#9670;&nbsp;</a></span>TRACKHOSTEXITS_RETRIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TRACKHOSTEXITS_RETRIES&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many times do we try connecting with an exit configured via TrackHostExits before concluding that it won't work any more and trying a different one? </p>

</div>
</div>
<a id="a8b4525b1e60c41eddb0e72c1f58fed7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4525b1e60c41eddb0e72c1f58fed7b">&#9670;&nbsp;</a></span>UNMARK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNMARK</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                           \</div><div class="line">    entry_conn-&gt;marked_pending_circ_line = 0;   \</div><div class="line">    entry_conn-&gt;marked_pending_circ_file = 0;   \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abf2c59dfc51d377036486ec06428508b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2c59dfc51d377036486ec06428508b">&#9670;&nbsp;</a></span>begin_cell_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int begin_cell_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">begin_cell_t *&#160;</td>
          <td class="paramname"><em>bcell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>end_reason_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a RELAY_BEGIN or RELAY_BEGINDIR cell from <b>cell</b>, decode it, and place the result in <b>bcell</b>. On success return 0; on failure return &lt;0 and set *<b>end_reason_out</b> to the end reason we should send back to the client.</p>
<p>Return -1 in the case where want to send a RELAY_END cell, and &lt; -1 when we don't. </p>

</div>
</div>
<a id="a877a7fd7beb61ea88e8b5a1d66354f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877a7fd7beb61ea88e8b5a1d66354f7f">&#9670;&nbsp;</a></span>circuit_clear_isolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circuit_clear_isolation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the isolation settings on <b>circ</b>.</p>
<p>This only works on an open circuit that has never had a stream attached to it, and whose isolation settings are hypothetical. (We set hypothetical isolation settings on circuits as we're launching them, so that we know whether they can handle more streams or whether we need to launch even more circuits. Once the circuit is open, if it turns out that we no longer have any streams to attach to it, we clear the isolation flags and data so that other streams can have a chance.) </p>

</div>
</div>
<a id="aeebad477501c1981a317ca88a1dac7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebad477501c1981a317ca88a1dac7f6">&#9670;&nbsp;</a></span>circuit_discard_optional_exit_enclaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circuit_discard_optional_exit_enclaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structextend__info__t.html">extend_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A circuit failed to finish on its last hop <b>info</b>. If there are any streams waiting with this exit node in mind, but they don't absolutely require it, make them give up on it. </p>

</div>
</div>
<a id="a49ce7ce66878c70c20abf54fdb922185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ce7ce66878c70c20abf54fdb922185">&#9670;&nbsp;</a></span>connected_cell_format_payload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int connected_cell_format_payload </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>payload_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ttl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the buffer at <b>payload_out</b> &ndash; which must have at least MAX_CONNECTED_CELL_PAYLOAD_LEN bytes available &ndash; to the body of a RELAY_CONNECTED cell indicating that we have connected to <b>addr</b>, and that the name resolution that led us to <b>addr</b> will be valid for <b>ttl</b> seconds. Return -1 on error, or the number of bytes used on success. </p>

</div>
</div>
<a id="ac58a63d2d02be560117a2a37b5e53b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58a63d2d02be560117a2a37b5e53b8f">&#9670;&nbsp;</a></span>connection_ap_about_to_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_about_to_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>entry_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when we're about to finally unlink and free an AP (client) connection: perform necessary accounting and cleanup </p>

</div>
</div>
<a id="ab5ca7733ddbd1bd01ea51010bf0b792a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ca7733ddbd1bd01ea51010bf0b792a">&#9670;&nbsp;</a></span>connection_ap_attach_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_attach_pending </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>retry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell any AP streams that are listed as waiting for a new circuit to try again, either attaching to an available circ or launching a new one.</p>
<p>If <b>retry</b> is false, only check the list if it contains at least one streams that we have not yet tried to attach to a circuit. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_ab5ca7733ddbd1bd01ea51010bf0b792a_icgraph.png" border="0" usemap="#connection__edge_8c_ab5ca7733ddbd1bd01ea51010bf0b792a_icgraph" alt=""/></div>
<map name="connection__edge_8c_ab5ca7733ddbd1bd01ea51010bf0b792a_icgraph" id="connection__edge_8c_ab5ca7733ddbd1bd01ea51010bf0b792a_icgraph">
<area shape="rect" id="node2" href="circuituse_8h.html#af4abb529971723bed7226e327b8326c3" title="circuit_try_attaching\l_streams" alt="" coords="203,5,341,47"/>
</map>
</div>

</div>
</div>
<a id="aa96677b281964b70945e9f3cb892c0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96677b281964b70945e9f3cb892c0f3">&#9670;&nbsp;</a></span>connection_ap_can_use_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_can_use_exit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnode__t.html">node_t</a> *&#160;</td>
          <td class="paramname"><em>exit_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 1 if router <b>exit_node</b> is likely to allow stream <b>conn</b> to exit from it, or 0 if it probably will not allow it. (We might be uncertain if conn's destination address has not yet been resolved.) </p>

</div>
</div>
<a id="a44bc7714d6e53e1ce4eaa07344fc8ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bc7714d6e53e1ce4eaa07344fc8ba5">&#9670;&nbsp;</a></span>connection_ap_detach_retriable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_detach_retriable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The AP connection <b>conn</b> has just failed while attaching or sending a BEGIN or resolving on <b>circ</b>, but another circuit might work. Detach the circuit, and either reattach it, launch a new circuit, tell the controller, or give up as appropriate.</p>
<p>Returns -1 on err, 1 on success, 0 on not-yet-sure. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_a44bc7714d6e53e1ce4eaa07344fc8ba5_cgraph.png" border="0" usemap="#connection__edge_8c_a44bc7714d6e53e1ce4eaa07344fc8ba5_cgraph" alt=""/></div>
<map name="connection__edge_8c_a44bc7714d6e53e1ce4eaa07344fc8ba5_cgraph" id="connection__edge_8c_a44bc7714d6e53e1ce4eaa07344fc8ba5_cgraph">
<area shape="rect" id="node2" href="control_8c.html#a9acf2608d05458d1a9e8531619363080" title="control_event_stream\l_status" alt="" coords="205,5,352,47"/>
</map>
</div>

</div>
</div>
<a id="a3bbef9941b20534da8fb058a85de8fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbef9941b20534da8fb058a85de8fcf">&#9670;&nbsp;</a></span>connection_ap_expire_beginning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_expire_beginning </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all general-purpose AP streams waiting for a response that sent their begin/resolve cell too long ago. Detach from their current circuit, and mark their current circuit as unsuitable for new streams. Then call <a class="el" href="circuituse_8c.html#a8d5c81bf7d6238331123b1e8753597f1">connection_ap_handshake_attach_circuit()</a> to attach to a new circuit (if available) or launch a new one.</p>
<p>For rendezvous streams, simply give up after SocksTimeout seconds (with no retry attempt). </p>

</div>
</div>
<a id="a445e2c5d72915367befb2ba4d09eb679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445e2c5d72915367befb2ba4d09eb679">&#9670;&nbsp;</a></span>connection_ap_fail_onehop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_fail_onehop </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>failed_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcpath__build__state__t.html">cpath_build_state_t</a> *&#160;</td>
          <td class="paramname"><em>build_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell any AP streams that are waiting for a one-hop tunnel to <b>failed_digest</b> that they are going to fail. </p>

</div>
</div>
<a id="a089e626ea05b78585432718686a835e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089e626ea05b78585432718686a835e2">&#9670;&nbsp;</a></span>connection_ap_handshake_rewrite_and_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_handshake_rewrite_and_attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrypt__path__t.html">crypt_path_t</a> *&#160;</td>
          <td class="paramname"><em>cpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connection <b>conn</b> just finished its socks handshake, or the controller asked us to take care of it. If <b>circ</b> is defined, then that's where we'll want to attach it. Otherwise we have to figure it out ourselves.</p>
<p>First, parse whether it's a .exit address, remap it, and so on. Then if it's for a general circuit, try to attach it to a circuit (or launch one as needed), else if it's for a rendezvous circuit, fetch a rendezvous descriptor first (or attach/launch a circuit if the rendezvous descriptor is already here and fresh enough).</p>
<p>The stream will exit from the hop indicated by <b>cpath</b>, or from the last hop in circ's cpath if <b>cpath</b> is NULL. </p>

</div>
</div>
<a id="a4bf52cba1e9b416e96cf47ea07f8f5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf52cba1e9b416e96cf47ea07f8f5ac">&#9670;&nbsp;</a></span>connection_ap_handshake_send_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_handshake_send_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>ap_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a relay begin cell, using destaddr and destport from ap_conn's socks_request field, and send it down circ.</p>
<p>If ap_conn is broken, mark it for close and return -1. Else return 0. </p>

</div>
</div>
<a id="a9bc7f537dbc24a03116f0d6eb873a86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc7f537dbc24a03116f0d6eb873a86d">&#9670;&nbsp;</a></span>connection_ap_handshake_send_resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_handshake_send_resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>ap_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a relay resolve cell, using destaddr and destport from ap_conn's socks_request field, and send it down circ.</p>
<p>If ap_conn is broken, mark it for close and return -1. Else return 0. </p>

</div>
</div>
<a id="a540f7850e71aa8140db0e2c6b4bb1993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540f7850e71aa8140db0e2c6b4bb1993">&#9670;&nbsp;</a></span>connection_ap_handshake_socks_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_handshake_socks_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>reply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>replylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endreason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a socks reply to stream <b>conn</b>, using the appropriate socks version, etc, and mark <b>conn</b> as completed with SOCKS handshaking.</p>
<p>If <b>reply</b> is defined, then write <b>replylen</b> bytes of it to conn and return, else reply based on <b>endreason</b> (one of END_STREAM_REASON_*). If <b>reply</b> is undefined, <b>endreason</b> can't be 0 or REASON_DONE. Send endreason to the controller, if appropriate. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_a540f7850e71aa8140db0e2c6b4bb1993_cgraph.png" border="0" usemap="#connection__edge_8c_a540f7850e71aa8140db0e2c6b4bb1993_cgraph" alt=""/></div>
<map name="connection__edge_8c_a540f7850e71aa8140db0e2c6b4bb1993_cgraph" id="connection__edge_8c_a540f7850e71aa8140db0e2c6b4bb1993_cgraph">
<area shape="rect" id="node2" href="reasons_8c.html#a53d4b83ccf635050be0ac6123aa7d052" title="stream_end_reason_to\l_socks5_response" alt="" coords="229,5,384,47"/>
</map>
</div>

</div>
</div>
<a id="aa00dc220c37fedfbcafa495a160755ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00dc220c37fedfbcafa495a160755ef">&#9670;&nbsp;</a></span>connection_ap_handshake_socks_resolved_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_handshake_socks_resolved_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>answer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>expires</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As connection_ap_handshake_socks_resolved, but take a <a class="el" href="structtor__addr__t.html">tor_addr_t</a> to send as the answer. </p>

</div>
</div>
<a id="a3a0a22a402cbdeaa42a91ffc901db842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0a22a402cbdeaa42a91ffc901db842">&#9670;&nbsp;</a></span>connection_ap_make_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentry__connection__t.html">entry_connection_t</a>* connection_ap_make_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structconnection__t.html">connection_t</a> *&#160;</td>
          <td class="paramname"><em>partner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>session_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isolation_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_begindir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>want_onehop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an AP <a class="el" href="structconnection__t.html">connection_t</a> linked to the <a class="el" href="structconnection__t.html">connection_t</a> <b>partner</b>. make a new linked connection pair, and attach one side to the conn, connection_add it, initialize it to circuit_wait, and call connection_ap_handshake_attach_circuit(conn) on it.</p>
<p>Return the newly created end of the linked connection pair, or -1 if error. </p>

</div>
</div>
<a id="a2719fd77969767f856cb3fa69e6161be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2719fd77969767f856cb3fa69e6161be">&#9670;&nbsp;</a></span>connection_ap_mark_as_non_pending_circuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_mark_as_non_pending_circuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>entry_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark <b>entry_conn</b> as no longer waiting for a circuit. </p>

</div>
</div>
<a id="a76fdd87ac5ecb745896b17f623b85a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fdd87ac5ecb745896b17f623b85a69">&#9670;&nbsp;</a></span>connection_ap_mark_as_pending_circuit_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_mark_as_pending_circuit_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>entry_conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark <b>entry_conn</b> as needing to get attached to a circuit.</p>
<p>And <b>entry_conn</b> must be in AP_CONN_STATE_CIRCUIT_WAIT, should not already be pending a circuit. The circuit will get launched or the connection will get attached the next time we call <a class="el" href="connection__edge_8c.html#ab5ca7733ddbd1bd01ea51010bf0b792a">connection_ap_attach_pending()</a>. </p>

</div>
</div>
<a id="a742177da6145106592c773a1a53691c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742177da6145106592c773a1a53691c1">&#9670;&nbsp;</a></span>connection_ap_process_transparent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_process_transparent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>connection_init_accepted_conn() found a new trans AP conn. Get the original destination and send it to <a class="el" href="connection__edge_8c.html#a089e626ea05b78585432718686a835e2">connection_ap_handshake_rewrite_and_attach()</a>.</p>
<p>Return -1 if an unexpected error with conn (and it should be marked for close), else return 0. </p>

</div>
</div>
<a id="a4ab7b2a135e5085488d7534353db7eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab7b2a135e5085488d7534353db7eed">&#9670;&nbsp;</a></span>connection_ap_rescan_and_attach_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_ap_rescan_and_attach_pending </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As connection_ap_attach_pending, but first scans the entire connection array to see if any elements are missing. </p>

</div>
</div>
<a id="a32b60847e224a01e865bb57afbbfedff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b60847e224a01e865bb57afbbfedff">&#9670;&nbsp;</a></span>connection_ap_rewrite_and_attach_if_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_ap_rewrite_and_attach_if_allowed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrypt__path__t.html">crypt_path_t</a> *&#160;</td>
          <td class="paramname"><em>cpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <a class="el" href="connection__edge_8c.html#a089e626ea05b78585432718686a835e2">connection_ap_handshake_rewrite_and_attach()</a> unless a controller asked us to leave streams unattached. Return 0 in that case.</p>
<p>See <a class="el" href="connection__edge_8c.html#a089e626ea05b78585432718686a835e2">connection_ap_handshake_rewrite_and_attach()</a>'s documentation for arguments and return value. </p>

</div>
</div>
<a id="a0235c2c1859b9b614df618778ae3fde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0235c2c1859b9b614df618778ae3fde1">&#9670;&nbsp;</a></span>connection_edge_compatible_with_circuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_compatible_with_circuit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff none of the isolation flags and fields in <b>conn</b> should prevent it from being attached to <b>circ</b>. </p>

</div>
</div>
<a id="a80dcd8839eb2e2bf00e5fd1c452f2a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dcd8839eb2e2bf00e5fd1c452f2a54">&#9670;&nbsp;</a></span>connection_edge_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a>&#160;</td>
          <td class="paramname"><em>circ_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This edge needs to be closed, because its circuit has closed. Mark it for close and return 0. </p>

</div>
</div>
<a id="ab32ca9441698867bcd01f43a7e615106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32ca9441698867bcd01f43a7e615106">&#9670;&nbsp;</a></span>connection_edge_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a relay end cell from stream <b>conn</b> down conn's circuit, and remember that we've done so. If this is not a client connection, set the relay end cell's reason for closing as <b>reason</b>.</p>
<p>Return -1 if this function has already been called on this conn, else return 0. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_ab32ca9441698867bcd01f43a7e615106_icgraph.png" border="0" usemap="#connection__edge_8c_ab32ca9441698867bcd01f43a7e615106_icgraph" alt=""/></div>
<map name="connection__edge_8c_ab32ca9441698867bcd01f43a7e615106_icgraph" id="connection__edge_8c_ab32ca9441698867bcd01f43a7e615106_icgraph">
<area shape="rect" id="node2" href="connection__edge_8h.html#ab2063f1ab80516dc671a116ac139705e" title="connection_edge_end\l_errno" alt="" coords="201,5,349,47"/>
</map>
</div>

</div>
</div>
<a id="ab2063f1ab80516dc671a116ac139705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2063f1ab80516dc671a116ac139705e">&#9670;&nbsp;</a></span>connection_edge_end_errno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_end_errno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An error has just occurred on an operation on an edge connection <b>conn</b>. Extract the errno; convert it to an end reason, and send an appropriate relay end cell to the other end of the connection's circuit. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_ab2063f1ab80516dc671a116ac139705e_cgraph.png" border="0" usemap="#connection__edge_8c_ab2063f1ab80516dc671a116ac139705e_cgraph" alt=""/></div>
<map name="connection__edge_8c_ab2063f1ab80516dc671a116ac139705e_cgraph" id="connection__edge_8c_ab2063f1ab80516dc671a116ac139705e_cgraph">
<area shape="rect" id="node2" href="reasons_8c.html#a8829a9ed7a54cfa9242d7dc5d205da0b" title="errno_to_stream_end\l_reason" alt="" coords="203,5,347,47"/>
<area shape="rect" id="node3" href="connection__edge_8c.html#ab32ca9441698867bcd01f43a7e615106" title="connection_edge_end" alt="" coords="201,71,349,98"/>
</map>
</div>

</div>
</div>
<a id="a80a8fec1a11119f7ff891ea0c5d8aa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a8fec1a11119f7ff891ea0c5d8aa22">&#9670;&nbsp;</a></span>connection_edge_finished_connecting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_finished_connecting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>edge_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connected handler for exit connections: start writing pending data, deliver 'CONNECTED' relay cells as appropriate, and check any pending data that may have been received. </p>

</div>
</div>
<a id="a84d464ff322df919a496d6fdfba9dade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d464ff322df919a496d6fdfba9dade">&#9670;&nbsp;</a></span>connection_edge_finished_flushing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_finished_flushing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connection <b>conn</b> has finished writing and has no bytes left on its outbuf.</p>
<p>If it's in state 'open', stop writing, consider responding with a sendme, and return. Otherwise, stop writing and return.</p>
<p>If <b>conn</b> is broken, mark it for close and return -1, else return 0. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_a84d464ff322df919a496d6fdfba9dade_cgraph.png" border="0" usemap="#connection__edge_8c_a84d464ff322df919a496d6fdfba9dade_cgraph" alt=""/></div>
<map name="connection__edge_8c_a84d464ff322df919a496d6fdfba9dade_cgraph" id="connection__edge_8c_a84d464ff322df919a496d6fdfba9dade_cgraph">
<area shape="rect" id="node2" href="relay_8c.html#a4e70e8fbfc6c89fa97102836a87a99c4" title="connection_edge_consider\l_sending_sendme" alt="" coords="225,23,401,65"/>
<area shape="rect" id="node3" href="connection_8c.html#a1a6be46082e23668c2cb0f323c171ad2" title="connection_outbuf_too_full" alt="" coords="449,5,627,32"/>
<area shape="rect" id="node4" href="circuitlist_8c.html#a60b5bc8820f7f98c15ea5c6999738997" title="circuit_get_by_edge_conn" alt="" coords="451,56,625,83"/>
</map>
</div>

</div>
</div>
<a id="a98855be3866a7e56063cefe658788fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98855be3866a7e56063cefe658788fcd">&#9670;&nbsp;</a></span>connection_edge_flushed_some()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_flushed_some </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We just wrote some data to <b>conn</b>; act appropriately.</p>
<p>(That is, if it's open, consider sending a stream-level sendme cell if we have just flushed enough.) </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_a98855be3866a7e56063cefe658788fcd_cgraph.png" border="0" usemap="#connection__edge_8c_a98855be3866a7e56063cefe658788fcd_cgraph" alt=""/></div>
<map name="connection__edge_8c_a98855be3866a7e56063cefe658788fcd_cgraph" id="connection__edge_8c_a98855be3866a7e56063cefe658788fcd_cgraph">
<area shape="rect" id="node2" href="relay_8c.html#a4e70e8fbfc6c89fa97102836a87a99c4" title="connection_edge_consider\l_sending_sendme" alt="" coords="261,23,437,65"/>
<area shape="rect" id="node3" href="connection_8c.html#a1a6be46082e23668c2cb0f323c171ad2" title="connection_outbuf_too_full" alt="" coords="485,5,663,32"/>
<area shape="rect" id="node4" href="circuitlist_8c.html#a60b5bc8820f7f98c15ea5c6999738997" title="circuit_get_by_edge_conn" alt="" coords="487,56,661,83"/>
</map>
</div>

</div>
</div>
<a id="a2255a4d834f5d2428dcf28091eeb20ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2255a4d834f5d2428dcf28091eeb20ba">&#9670;&nbsp;</a></span>connection_edge_free_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_edge_free_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free all storage held in module-scoped variables for <a class="el" href="connection__edge_8c.html" title="Handle edge streams. ">connection_edge.c</a> </p>

</div>
</div>
<a id="accf4787c953075c4a9aeaab09bb2b3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf4787c953075c4a9aeaab09bb2b3fe">&#9670;&nbsp;</a></span>connection_edge_is_rendezvous_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_is_rendezvous_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 1 if <b>conn</b> is a rendezvous stream, or 0 if it is a general stream. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_accf4787c953075c4a9aeaab09bb2b3fe_icgraph.png" border="0" usemap="#connection__edge_8c_accf4787c953075c4a9aeaab09bb2b3fe_icgraph" alt=""/></div>
<map name="connection__edge_8c_accf4787c953075c4a9aeaab09bb2b3fe_icgraph" id="connection__edge_8c_accf4787c953075c4a9aeaab09bb2b3fe_icgraph">
<area shape="rect" id="node2" href="circuituse_8h.html#a8d5c81bf7d6238331123b1e8753597f1" title="connection_ap_handshake\l_attach_circuit" alt="" coords="196,5,372,47"/>
<area shape="rect" id="node3" href="connection__edge_8c.html#a5922c995ab015f688168d02a6b954050" title="MOCK_IMPL" alt="" coords="234,71,334,98"/>
<area shape="rect" id="node4" href="connection__edge_8h.html#af1726a6cec89474d98905c4dd047d1c3" title="connection_exit_connect" alt="" coords="201,122,367,149"/>
</map>
</div>

</div>
</div>
<a id="af7fb9b70852e8b94a3aae49033285cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fb9b70852e8b94a3aae49033285cfc">&#9670;&nbsp;</a></span>connection_edge_process_inbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_process_inbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>package_partial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle new bytes on conn-&gt;inbuf based on state:</p><ul>
<li>If it's waiting for socks info, try to read another step of the socks handshake out of conn-&gt;inbuf.</li>
<li>If it's waiting for the original destination, fetch it.</li>
<li>If it's open, then package more relay cells from the stream.</li>
<li>Else, leave the bytes on inbuf alone for now.</li>
</ul>
<p>Mark and return -1 if there was an unexpected error with the conn, else return 0. </p>

</div>
</div>
<a id="aa216dab9d4e712fa5c03e29bb058ee7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa216dab9d4e712fa5c03e29bb058ee7d">&#9670;&nbsp;</a></span>connection_edge_reached_eof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_reached_eof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There was an EOF. Send an end and mark the connection for close. </p>

</div>
</div>
<a id="aa1ece387b44509bca78097fec1975263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ece387b44509bca78097fec1975263">&#9670;&nbsp;</a></span>connection_edge_update_circuit_isolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_edge_update_circuit_isolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentry__connection__t.html">entry_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dry_run</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <b>dry_run</b> is false, update <b>circ</b>'s isolation flags and fields to reflect having had <b>conn</b> attached to it, and return 0. Otherwise, if <b>dry_run</b> is true, then make no changes to <b>circ</b>, and return a bitfield of isolation flags that we would have to set in isolation_flags_mixed to add <b>conn</b> to <b>circ</b>, or -1 if <b>circ</b> has had no streams attached to it. </p>

</div>
</div>
<a id="a8a6c052c5ede7819e5bf1b225fbfc6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6c052c5ede7819e5bf1b225fbfc6b2">&#9670;&nbsp;</a></span>connection_exit_about_to_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_exit_about_to_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>edge_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when we're about to finally unlink and free an exit connection: perform necessary accounting and cleanup </p>

</div>
</div>
<a id="ae2916d0db0fd6c1551e29a3436308464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2916d0db0fd6c1551e29a3436308464">&#9670;&nbsp;</a></span>connection_exit_begin_conn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_exit_begin_conn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcircuit__t.html">circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A relay 'begin' or 'begin_dir' cell has arrived, and either we are an exit hop for the circuit, or we are the origin and it is a rendezvous begin.</p>
<p>Launch a new exit connection and initialize things appropriately.</p>
<p>If it's a rendezvous stream, call <a class="el" href="connection__edge_8c.html#a64bdbd8f1352e1101d8a9a409049a057">connection_exit_connect()</a> on it.</p>
<p>For general streams, call <a class="el" href="dns_8c.html#aa1ffeb643093b409c75573a27574afbc">dns_resolve()</a> on it first, and only call <a class="el" href="connection__edge_8c.html#a64bdbd8f1352e1101d8a9a409049a057">connection_exit_connect()</a> if the dns answer is already known.</p>
<p>Note that we don't call connection_add() on the new stream! We wait for <a class="el" href="connection__edge_8c.html#a64bdbd8f1352e1101d8a9a409049a057">connection_exit_connect()</a> to do that.</p>
<p>Return -(some circuit end reason) if we want to tear down <b>circ</b>. Else return 0. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_ae2916d0db0fd6c1551e29a3436308464_cgraph.png" border="0" usemap="#connection__edge_8c_ae2916d0db0fd6c1551e29a3436308464_cgraph" alt=""/></div>
<map name="connection__edge_8c_ae2916d0db0fd6c1551e29a3436308464_cgraph" id="connection__edge_8c_ae2916d0db0fd6c1551e29a3436308464_cgraph">
<area shape="rect" id="node2" href="circuitlist_8c.html#a96a06b5b1f559dcb3747b599451df921" title="assert_circuit_ok" alt="" coords="240,5,361,32"/>
</map>
</div>

</div>
</div>
<a id="a8805ef6708301581c9339e83f41e76e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8805ef6708301581c9339e83f41e76e0">&#9670;&nbsp;</a></span>connection_exit_begin_resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_exit_begin_resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structor__circuit__t.html">or_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when we receive a RELAY_COMMAND_RESOLVE cell 'cell' along the circuit <b>circ</b>; begin resolving the hostname, and (eventually) reply with a RESOLVED cell. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_a8805ef6708301581c9339e83f41e76e0_cgraph.png" border="0" usemap="#connection__edge_8c_a8805ef6708301581c9339e83f41e76e0_cgraph" alt=""/></div>
<map name="connection__edge_8c_a8805ef6708301581c9339e83f41e76e0_cgraph" id="connection__edge_8c_a8805ef6708301581c9339e83f41e76e0_cgraph">
<area shape="rect" id="node2" href="circuitlist_8c.html#a96a06b5b1f559dcb3747b599451df921" title="assert_circuit_ok" alt="" coords="219,5,340,32"/>
<area shape="rect" id="node3" href="relay_8c.html#a9b06f0a66f2b1af9d4e0855225192e1d" title="relay_header_unpack" alt="" coords="207,56,352,83"/>
<area shape="rect" id="node5" href="connection_8c.html#a2ec50dd3f5bb871bf4a7058e4a57a754" title="edge_connection_new" alt="" coords="204,107,355,133"/>
<area shape="rect" id="node4" href="compat_8c.html#ae67679aa2827ab3a1378abb8a2b953cf" title="get_uint16" alt="" coords="403,56,485,83"/>
</map>
</div>

</div>
</div>
<a id="a64bdbd8f1352e1101d8a9a409049a057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bdbd8f1352e1101d8a9a409049a057">&#9670;&nbsp;</a></span>connection_exit_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_exit_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structedge__connection__t.html">edge_connection_t</a> *&#160;</td>
          <td class="paramname"><em>edge_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect to conn's specified addr and port. If it worked, conn has now been added to the connection_array.</p>
<p>Send back a connected cell. Include the resolved IP of the destination address, but <em>only</em> if it's a general exit stream. (Rendezvous streams must not reveal what IP they connected to.) </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_a64bdbd8f1352e1101d8a9a409049a057_cgraph.png" border="0" usemap="#connection__edge_8c_a64bdbd8f1352e1101d8a9a409049a057_cgraph" alt=""/></div>
<map name="connection__edge_8c_a64bdbd8f1352e1101d8a9a409049a057_cgraph" id="connection__edge_8c_a64bdbd8f1352e1101d8a9a409049a057_cgraph">
<area shape="rect" id="node2" href="connection__edge_8c.html#accf4787c953075c4a9aeaab09bb2b3fe" title="connection_edge_is\l_rendezvous_stream" alt="" coords="220,5,363,47"/>
</map>
</div>

</div>
</div>
<a id="ae4fce505c5ac663fd02992156aaf7d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fce505c5ac663fd02992156aaf7d19">&#9670;&nbsp;</a></span>get_unique_stream_id_by_circ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="or_8h.html#a73c0506b3441b5715fa7affd5f8759fa">streamid_t</a> get_unique_stream_id_by_circ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorigin__circuit__t.html">origin_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>circ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over the two bytes of stream_id until we get one that is not already in use; return it. Return 0 if can't get a unique stream_id. </p>

</div>
</div>
<a id="a5922c995ab015f688168d02a6b954050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5922c995ab015f688168d02a6b954050">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">connection_mark_unattached_ap_&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, int endreason, int line, const char *file)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An AP stream has failed/finished. If it hasn't already sent back a socks reply, send one now (based on endreason). Also set has_sent_end to 1, and mark the conn. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__edge_8c_a5922c995ab015f688168d02a6b954050_cgraph.png" border="0" usemap="#connection__edge_8c_a5922c995ab015f688168d02a6b954050_cgraph" alt=""/></div>
<map name="connection__edge_8c_a5922c995ab015f688168d02a6b954050_cgraph" id="connection__edge_8c_a5922c995ab015f688168d02a6b954050_cgraph">
<area shape="rect" id="node2" href="connection__edge_8c.html#accf4787c953075c4a9aeaab09bb2b3fe" title="connection_edge_is\l_rendezvous_stream" alt="" coords="175,5,318,47"/>
<area shape="rect" id="node3" href="rendclient_8c.html#ab6a404500892962da09d28a99822d176" title="rend_client_note_connection\l_attempt_ended" alt="" coords="153,71,340,112"/>
<area shape="rect" id="node6" href="connection_8c.html#a2a15ddd62951cefd848ec070f1d9c912" title="connection_mark_for\l_close_" alt="" coords="175,136,318,177"/>
<area shape="rect" id="node4" href="rendcache_8c.html#a367f96478b3d5bab8af7098b61fdafb4" title="rend_cache_lookup_entry" alt="" coords="388,78,559,105"/>
<area shape="rect" id="node5" href="rendcommon_8c.html#a4c98beed11b35d28c3e8fe8249d027c5" title="rend_valid_service_id" alt="" coords="607,78,753,105"/>
<area shape="rect" id="node7" href="connection_8c.html#a738d9e7ef0c4a101c2adbd4cade35475" title="assert_connection_ok" alt="" coords="399,143,548,170"/>
</map>
</div>

</div>
</div>
<a id="a79f065a4c221152890ce1ac2c838e0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f065a4c221152890ce1ac2c838e0e8">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">connection_ap_handshake_socks_resolved&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(<a class="el" href="structentry__connection__t.html">entry_connection_t</a> *conn, int answer_type, size_t answer_len, const uint8_t *answer, int ttl, time_t expires)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an answer to an AP connection that has requested a DNS lookup via SOCKS. The type should be one of RESOLVED_TYPE_(IPV4|IPV6|HOSTNAME) or -1 for unreachable; the answer should be in the format specified in the socks extensions document. <b>ttl</b> is the ttl for the answer, or -1 on certain errors or for values that didn't come via DNS. <b>expires</b> is a time when the answer expires, or -1 or TIME_MAX if there's a good TTL. </p>

</div>
</div>
<a id="a24f609919f0f88177960f67f162cbe2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f609919f0f88177960f67f162cbe2c">&#9670;&nbsp;</a></span>parse_extended_hostname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="connection__edge_8h.html#a6672882527624d0bebbc4e24b56cf105">hostname_type_t</a> parse_extended_hostname </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If address is of the form "y.onion" with a well-formed handle y: Put a NUL after y, lower-case it, and return ONION_HOSTNAME.</p>
<p>If address is of the form "x.y.onion" with a well-formed handle x: Drop "x.", put a NUL after y, lower-case it, and return ONION_HOSTNAME.</p>
<p>If address is of the form "y.onion" with a badly-formed handle y: Return BAD_HOSTNAME and log a message.</p>
<p>If address is of the form "y.exit": Put a NUL after y and return EXIT_HOSTNAME.</p>
<p>Otherwise: Return NORMAL_HOSTNAME and change nothing. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
