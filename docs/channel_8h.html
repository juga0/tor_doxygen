<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: /home/user/_my/code/bwauth-related/tor/src/or/channel.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97b64286d42c5ef1697cb5f17129db19.html">tor</a></li><li class="navelem"><a class="el" href="dir_3cb0ba3f4b82dbe34a1a06276e96bc8d.html">src</a></li><li class="navelem"><a class="el" href="dir_386635fabd7f6c74e9d9c7a8604514a0.html">or</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">channel.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for <a class="el" href="channel_8c.html" title="OR/OP-to-OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ...">channel.c</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="or_8h_source.html">or.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="circuitmux_8h_source.html">circuitmux.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for channel.h:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8h" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8h" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8h">
<area shape="rect" id="node2" href="or_8h.html" title="Master header file for Tor&#45;specific functionality. " alt="" coords="1447,184,1491,211"/>
<area shape="rect" id="node34" href="circuitmux_8h.html" title="Header file for circuitmux.c. " alt="" coords="1507,109,1600,136"/>
<area shape="rect" id="node3" href="orconfig_8h_source.html" title="orconfig.h" alt="" coords="366,781,445,808"/>
<area shape="rect" id="node4" href="torint_8h.html" title="Header file to define uint32_t and friends. " alt="" coords="902,707,965,733"/>
<area shape="rect" id="node5" href="crypto_8h.html" title="Headers for crypto.c. " alt="" coords="955,483,1024,509"/>
<area shape="rect" id="node13" href="crypto__format_8h_source.html" title="crypto_format.h" alt="" coords="1721,483,1834,509"/>
<area shape="rect" id="node14" href="crypto__ed25519_8h_source.html" title="crypto_ed25519.h" alt="" coords="1419,557,1544,584"/>
<area shape="rect" id="node15" href="crypto__curve25519_8h_source.html" title="crypto_curve25519.h" alt="" coords="1369,632,1511,659"/>
<area shape="rect" id="node16" href="tortls_8h.html" title="Headers for tortls.c. " alt="" coords="1130,408,1193,435"/>
<area shape="rect" id="node19" href="torlog_8h.html" title="Headers for log.c. " alt="" coords="1419,483,1485,509"/>
<area shape="rect" id="node20" href="container_8h_source.html" title="container.h" alt="" coords="617,333,703,360"/>
<area shape="rect" id="node26" href="torgzip_8h.html" title="Headers for torgzip.h. " alt="" coords="1249,259,1321,285"/>
<area shape="rect" id="node27" href="address_8h.html" title="Headers for address.h. " alt="" coords="497,259,575,285"/>
<area shape="rect" id="node28" href="compat__libevent_8h_source.html" title="compat_libevent.h" alt="" coords="1960,632,2088,659"/>
<area shape="rect" id="node30" href="ht_8h_source.html" title="ht.h" alt="" coords="1447,259,1491,285"/>
<area shape="rect" id="node31" href="replaycache_8h.html" title="Header file for replaycache.c. " alt="" coords="1515,259,1618,285"/>
<area shape="rect" id="node32" href="tor__queue_8h_source.html" title="tor_queue.h" alt="" coords="1643,259,1733,285"/>
<area shape="rect" id="node33" href="util__format_8h_source.html" title="util_format.h" alt="" coords="1638,632,1733,659"/>
<area shape="rect" id="node7" href="testsupport_8h_source.html" title="testsupport.h" alt="" coords="1391,707,1489,733"/>
<area shape="rect" id="node8" href="compat_8h_source.html" title="compat.h" alt="" coords="666,557,742,584"/>
<area shape="rect" id="node10" href="compat__time_8h.html" title="Functions and types for monotonic times. " alt="" coords="145,707,253,733"/>
<area shape="rect" id="node12" href="compat__threads_8h_source.html" title="compat_threads.h" alt="" coords="726,632,853,659"/>
<area shape="rect" id="node17" href="compat__openssl_8h.html" title="compatability definitions for working with different openssl forks " alt="" coords="1109,483,1237,509"/>
<area shape="rect" id="node21" href="util_8h.html" title="Headers for util.c. " alt="" coords="589,408,640,435"/>
<area shape="rect" id="node25" href="siphash_8h_source.html" title="siphash.h" alt="" coords="665,408,743,435"/>
<area shape="rect" id="node22" href="di__ops_8h.html" title="Headers for di_ops.c. " alt="" coords="195,632,266,659"/>
<area shape="rect" id="node24" href="util__bug_8h.html" title="util_bug.h" alt="" coords="574,483,653,509"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h__dep__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8hdep" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8hdep" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8hdep">
<area shape="rect" id="node2" href="channel_8c.html" title="OR/OP&#45;to&#45;OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ..." alt="" coords="521,213,669,269"/>
<area shape="rect" id="node3" href="channeltls_8h.html" title="Header file for channeltls.c. " alt="" coords="693,109,841,165"/>
<area shape="rect" id="node4" href="channeltls_8c.html" title="A concrete subclass of channel_t using or_connection_t to transfer cells between Tor instances..." alt="" coords="865,213,1013,269"/>
<area shape="rect" id="node5" href="connection_8c.html" title="General high&#45;level functions to handle reading and writing on connections. " alt="" coords="5,213,153,269"/>
<area shape="rect" id="node6" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. " alt="" coords="1038,213,1193,269"/>
<area shape="rect" id="node7" href="control_8c.html" title="Implementation for Tor&#39;s control&#45;socket interface. " alt="" coords="349,213,497,269"/>
<area shape="rect" id="node8" href="dirserv_8c.html" title="Directory server core implementation. Manages directory contents and generates directories. " alt="" coords="693,213,841,269"/>
<area shape="rect" id="node9" href="hibernate_8c.html" title="Functions to close listeners, stop allowing new circuits, etc in preparation for closing down or goin..." alt="" coords="177,213,325,269"/>
<area shape="rect" id="node10" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop..." alt="" coords="1217,213,1365,269"/>
<area shape="rect" id="node11" href="scheduler_8h.html" title="Header file for scheduler.c. " alt="" coords="1261,109,1409,165"/>
<area shape="rect" id="node12" href="config_8c.html" title="Code to parse and interpret configuration files. " alt="" coords="1733,213,1881,269"/>
<area shape="rect" id="node13" href="relay_8c.html" title="Handle relay cell encryption/decryption, plus packaging and receiving from circuits, plus queuing on circuits. " alt="" coords="1905,213,2053,269"/>
<area shape="rect" id="node14" href="scheduler_8c.html" title="Relay scheduling system. " alt="" coords="2077,213,2225,269"/>
<area shape="rect" id="node15" href="command_8h.html" title="Header file for command.c. " alt="" coords="1037,109,1185,165"/>
<area shape="rect" id="node16" href="circuitbuild_8c.html" title="Implements the details of building circuits (by chosing paths, constructing/sending create/extend cel..." alt="" coords="1389,213,1537,269"/>
<area shape="rect" id="node17" href="command_8c.html" title="Functions for processing incoming cells. " alt="" coords="1561,213,1709,269"/>
<area shape="rect" id="node18" href="circpathbias_8c.html" title="Code to track success/failure rates of circuits built through different tor nodes, in an attempt to detect attacks where an attacker deliberately causes circuits to fail until the client choses a path they like. " alt="" coords="1688,109,1836,165"/>
<area shape="rect" id="node19" href="circuitlist_8c.html" title="Manage the global circuit list, and looking up circuits within it. " alt="" coords="1860,109,2008,165"/>
<area shape="rect" id="node20" href="circuitmux_8c.html" title="Circuit mux/cell selection abstraction. " alt="" coords="2032,109,2180,165"/>
<area shape="rect" id="node21" href="circuituse_8c.html" title="Launch the right sort of circuits and attach streams to them. " alt="" coords="2204,109,2352,165"/>
<area shape="rect" id="node22" href="connection__edge_8c.html" title="Handle edge streams. " alt="" coords="2376,109,2548,165"/>
<area shape="rect" id="node23" href="cpuworker_8c.html" title="Uses the workqueue/threadpool code to farm CPU&#45;intensive activities out to subprocesses. " alt="" coords="2572,109,2720,165"/>
<area shape="rect" id="node24" href="networkstatus_8c.html" title="Functions and structures for handling network status documents as a client or cache. " alt="" coords="2744,109,2900,165"/>
<area shape="rect" id="node25" href="rendmid_8c.html" title="Implement introductions points and rendezvous points. " alt="" coords="2924,109,3072,165"/>
</map>
</div>
</div>
<p><a href="channel_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchannel__s.html">channel_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchannel__listener__s.html">channel_listener_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae4760e2e664fa4991dab88c3bdbad792"><td class="memItemLeft" align="right" valign="top"><a id="ae4760e2e664fa4991dab88c3bdbad792"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GRD_FLAG_ORIGINAL</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ae4760e2e664fa4991dab88c3bdbad792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecacbb75983d4165d1165f9774bf4ad"><td class="memItemLeft" align="right" valign="top"><a id="aaecacbb75983d4165d1165f9774bf4ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GRD_FLAG_ADDR_ONLY</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aaecacbb75983d4165d1165f9774bf4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28abebb6c5d89a4b9c0d150e0a9caac0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_CLOSED</b>(chan)</td></tr>
<tr class="separator:a28abebb6c5d89a4b9c0d150e0a9caac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6cdc5661f051c45f7aeb36d6d00a94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_OPENING</b>(chan)</td></tr>
<tr class="separator:a3d6cdc5661f051c45f7aeb36d6d00a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad144fc71cf2d9f27cdfb0d49cb57d816"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_OPEN</b>(chan)</td></tr>
<tr class="separator:ad144fc71cf2d9f27cdfb0d49cb57d816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8606f53d3d0e710fbc2ba63ae274df2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_MAINT</b>(chan)</td></tr>
<tr class="separator:ab8606f53d3d0e710fbc2ba63ae274df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9958211f3b4e0531e259c147ef602993"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_CLOSING</b>(chan)</td></tr>
<tr class="separator:a9958211f3b4e0531e259c147ef602993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8df712558f5f955701d0d5db99ffe78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_ERROR</b>(chan)</td></tr>
<tr class="separator:ac8df712558f5f955701d0d5db99ffe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600d56dd2c6f29545f5bb80bfab7d446"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_FINISHED</b>(chan)</td></tr>
<tr class="separator:a600d56dd2c6f29545f5bb80bfab7d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23464e5f02f6b1a57ec4c0a2c7234243"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_CONDEMNED</b>(chan)</td></tr>
<tr class="separator:a23464e5f02f6b1a57ec4c0a2c7234243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f58e35a9f96bd9c180d6789d36f909d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_CAN_HANDLE_CELLS</b>(chan)</td></tr>
<tr class="separator:a9f58e35a9f96bd9c180d6789d36f909d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a34c67bf8947c017f17e2866670c30542"><td class="memItemLeft" align="right" valign="top"><a id="a34c67bf8947c017f17e2866670c30542"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>channel_listener_fn_ptr</b>) (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *, <a class="el" href="structchannel__s.html">channel_t</a> *)</td></tr>
<tr class="separator:a34c67bf8947c017f17e2866670c30542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b94b2e3038d9cef5a49338f20cb0879"><td class="memItemLeft" align="right" valign="top"><a id="a9b94b2e3038d9cef5a49338f20cb0879"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>channel_cell_handler_fn_ptr</b>) (<a class="el" href="structchannel__s.html">channel_t</a> *, <a class="el" href="structcell__t.html">cell_t</a> *)</td></tr>
<tr class="separator:a9b94b2e3038d9cef5a49338f20cb0879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9e94f0afdd026831426b258f8a38e"><td class="memItemLeft" align="right" valign="top"><a id="a62a9e94f0afdd026831426b258f8a38e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>channel_var_cell_handler_fn_ptr</b>) (<a class="el" href="structchannel__s.html">channel_t</a> *, <a class="el" href="structvar__cell__t.html">var_cell_t</a> *)</td></tr>
<tr class="separator:a62a9e94f0afdd026831426b258f8a38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0019185c7a02c287640540441a508d"><td class="memItemLeft" align="right" valign="top"><a id="aad0019185c7a02c287640540441a508d"></a>
typedef struct chan_cell_queue&#160;</td><td class="memItemRight" valign="bottom"><b>chan_cell_queue_t</b></td></tr>
<tr class="separator:aad0019185c7a02c287640540441a508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3831036169371916993f5f927b853aac"><td class="memItemLeft" align="right" valign="top"><a id="a3831036169371916993f5f927b853aac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TOR_SIMPLEQ_HEAD</b> (chan_cell_queue, cell_queue_entry_s)</td></tr>
<tr class="separator:a3831036169371916993f5f927b853aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48de40019cd073a6bc571c0ffcf55b51"><td class="memItemLeft" align="right" valign="top"><a id="a48de40019cd073a6bc571c0ffcf55b51"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>channel_state_is_valid</b> (channel_state_t state)</td></tr>
<tr class="separator:a48de40019cd073a6bc571c0ffcf55b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdf98e720a6acc2e476e681e91e4fde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a5bdf98e720a6acc2e476e681e91e4fde">channel_listener_state_is_valid</a> (channel_listener_state_t state)</td></tr>
<tr class="separator:a5bdf98e720a6acc2e476e681e91e4fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727f5f4b03dca7d9b0ef71842709c055"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a727f5f4b03dca7d9b0ef71842709c055">channel_state_can_transition</a> (channel_state_t from, channel_state_t to)</td></tr>
<tr class="separator:a727f5f4b03dca7d9b0ef71842709c055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447edc0876c6c437ae72b5c49b8e038a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a447edc0876c6c437ae72b5c49b8e038a">channel_listener_state_can_transition</a> (channel_listener_state_t from, channel_listener_state_t to)</td></tr>
<tr class="separator:a447edc0876c6c437ae72b5c49b8e038a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5368fc8c3c7f7b0ce1020927961c92a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ac5368fc8c3c7f7b0ce1020927961c92a">channel_state_to_string</a> (channel_state_t state)</td></tr>
<tr class="separator:ac5368fc8c3c7f7b0ce1020927961c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0cac4ba2733cffddc9ff59be701687"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aee0cac4ba2733cffddc9ff59be701687">channel_listener_state_to_string</a> (channel_listener_state_t state)</td></tr>
<tr class="separator:aee0cac4ba2733cffddc9ff59be701687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c51ad12ff89e0f63cc386ccda8493f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ac5c51ad12ff89e0f63cc386ccda8493f">channel_mark_for_close</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ac5c51ad12ff89e0f63cc386ccda8493f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dce1c4def06886d0a3e8f2aeb9d136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ab7dce1c4def06886d0a3e8f2aeb9d136">channel_write_cell</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structcell__t.html">cell_t</a> *cell)</td></tr>
<tr class="separator:ab7dce1c4def06886d0a3e8f2aeb9d136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea0a09319d794c0f301f62fa5237512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aeea0a09319d794c0f301f62fa5237512">channel_write_packed_cell</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *cell)</td></tr>
<tr class="separator:aeea0a09319d794c0f301f62fa5237512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af328f72343802140f8e423a846721a6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#af328f72343802140f8e423a846721a6c">channel_write_var_cell</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structvar__cell__t.html">var_cell_t</a> *cell)</td></tr>
<tr class="separator:af328f72343802140f8e423a846721a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d328d0eebd17c646ec3a1ff4442d827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a4d328d0eebd17c646ec3a1ff4442d827">channel_listener_mark_for_close</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a4d328d0eebd17c646ec3a1ff4442d827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1245962c49dfe3349cf00e0cacd7f15"><td class="memItemLeft" align="right" valign="top">channel_listener_fn_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ab1245962c49dfe3349cf00e0cacd7f15">channel_listener_get_listener_fn</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan)</td></tr>
<tr class="separator:ab1245962c49dfe3349cf00e0cacd7f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed86da67099b40c8eea25752b2260da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a7ed86da67099b40c8eea25752b2260da">channel_listener_set_listener_fn</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan, channel_listener_fn_ptr listener)</td></tr>
<tr class="separator:a7ed86da67099b40c8eea25752b2260da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3b8c3a3d91967c63fea496d2fe1b2e"><td class="memItemLeft" align="right" valign="top">channel_cell_handler_fn_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a9f3b8c3a3d91967c63fea496d2fe1b2e">channel_get_cell_handler</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a9f3b8c3a3d91967c63fea496d2fe1b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee619f7637f1a10fec2da20ea004e998"><td class="memItemLeft" align="right" valign="top">channel_var_cell_handler_fn_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aee619f7637f1a10fec2da20ea004e998">channel_get_var_cell_handler</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:aee619f7637f1a10fec2da20ea004e998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c26cbf4843fb4609f3f0c1eee87498c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a5c26cbf4843fb4609f3f0c1eee87498c">channel_set_cell_handlers</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, channel_cell_handler_fn_ptr cell_handler, channel_var_cell_handler_fn_ptr var_cell_handler)</td></tr>
<tr class="separator:a5c26cbf4843fb4609f3f0c1eee87498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d874b0dd28680dd7f9661e2490d9091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a1d874b0dd28680dd7f9661e2490d9091">channel_run_cleanup</a> (void)</td></tr>
<tr class="separator:a1d874b0dd28680dd7f9661e2490d9091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7838364ded7b78a661a1f3f2f1c266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a3e7838364ded7b78a661a1f3f2f1c266">channel_listener_run_cleanup</a> (void)</td></tr>
<tr class="separator:a3e7838364ded7b78a661a1f3f2f1c266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d84e3ecc8f662ed2072a2104d0b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#adb2d84e3ecc8f662ed2072a2104d0b6b">channel_free_all</a> (void)</td></tr>
<tr class="separator:adb2d84e3ecc8f662ed2072a2104d0b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef365ba78cdfea35f694be31bfd6e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a1ef365ba78cdfea35f694be31bfd6e91">channel_dumpstats</a> (int severity)</td></tr>
<tr class="separator:a1ef365ba78cdfea35f694be31bfd6e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0519ba6c6b14de83e886ed42095fe68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68">channel_listener_dumpstats</a> (int severity)</td></tr>
<tr class="separator:ab0519ba6c6b14de83e886ed42095fe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab581fe82a432b885561d00ab3ecceba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ab581fe82a432b885561d00ab3ecceba6">channel_set_cmux_policy_everywhere</a> (<a class="el" href="structcircuitmux__policy__s.html">circuitmux_policy_t</a> *pol)</td></tr>
<tr class="separator:ab581fe82a432b885561d00ab3ecceba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e3e2de528821cdda969fba6de1e4f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a85e3e2de528821cdda969fba6de1e4f2">channel_send_destroy</a> (<a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> circ_id, <a class="el" href="structchannel__s.html">channel_t</a> *chan, int reason)</td></tr>
<tr class="separator:a85e3e2de528821cdda969fba6de1e4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b8cc7d1d3dbbdca20c863c3cb35273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a13b8cc7d1d3dbbdca20c863c3cb35273">channel_connect</a> (const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr, uint16_t port, const char *id_digest)</td></tr>
<tr class="separator:a13b8cc7d1d3dbbdca20c863c3cb35273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ebc2554b7f8fd2b5c331bf7dc94ecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a41ebc2554b7f8fd2b5c331bf7dc94ecc">channel_get_for_extend</a> (const char *digest, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *target_addr, const char **msg_out, int *launch_out)</td></tr>
<tr class="separator:a41ebc2554b7f8fd2b5c331bf7dc94ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37fcbdaafeac83501c1699e61d8e128"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aa37fcbdaafeac83501c1699e61d8e128">channel_is_better</a> (time_t now, <a class="el" href="structchannel__s.html">channel_t</a> *a, <a class="el" href="structchannel__s.html">channel_t</a> *b, int forgive_new_connections)</td></tr>
<tr class="separator:aa37fcbdaafeac83501c1699e61d8e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ce362c180c51c5018668bae7bb4f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a03ce362c180c51c5018668bae7bb4f24">channel_find_by_global_id</a> (uint64_t global_identifier)</td></tr>
<tr class="separator:a03ce362c180c51c5018668bae7bb4f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0542e2ca72fe8da87de8ea2f711dd7dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a0542e2ca72fe8da87de8ea2f711dd7dc">channel_find_by_remote_digest</a> (const char *identity_digest)</td></tr>
<tr class="separator:a0542e2ca72fe8da87de8ea2f711dd7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ee6566b1661b9e37181d8f83efdfbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a53ee6566b1661b9e37181d8f83efdfbd">channel_next_with_digest</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a53ee6566b1661b9e37181d8f83efdfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185d59ac3e69ab26d2b71804cb882993"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a185d59ac3e69ab26d2b71804cb882993">channel_describe_transport</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a185d59ac3e69ab26d2b71804cb882993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff871ec7cc89dc910ca360747497fb5a"><td class="memItemLeft" align="right" valign="top"><a id="aff871ec7cc89dc910ca360747497fb5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (void, channel_dump_statistics,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, int severity))</td></tr>
<tr class="separator:aff871ec7cc89dc910ca360747497fb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2704646dbc4d5113c2160fd9842f128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ae2704646dbc4d5113c2160fd9842f128">channel_dump_transport_statistics</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, int severity)</td></tr>
<tr class="separator:ae2704646dbc4d5113c2160fd9842f128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8608773117c50600ebe58ffc331b6b3e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a8608773117c50600ebe58ffc331b6b3e">channel_get_actual_remote_descr</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a8608773117c50600ebe58ffc331b6b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1c9c62855d488fa17eaa4c4dd3f6e5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a3c1c9c62855d488fa17eaa4c4dd3f6e5">channel_get_actual_remote_address</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a3c1c9c62855d488fa17eaa4c4dd3f6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88a42a45b25954d77fd2f4ad42097bc"><td class="memItemLeft" align="right" valign="top"><a id="af88a42a45b25954d77fd2f4ad42097bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (int, channel_get_addr_if_possible,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr_out))</td></tr>
<tr class="separator:af88a42a45b25954d77fd2f4ad42097bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a5bd1e17411b06028d4839ad6e6df"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a5a9a5bd1e17411b06028d4839ad6e6df">channel_get_canonical_remote_descr</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a5a9a5bd1e17411b06028d4839ad6e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02db0f9ae91b50323bd345a224d9d1d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a02db0f9ae91b50323bd345a224d9d1d8">channel_has_queued_writes</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a02db0f9ae91b50323bd345a224d9d1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118d357c7f7accb2f220b000f33ea714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a118d357c7f7accb2f220b000f33ea714">channel_is_bad_for_new_circs</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a118d357c7f7accb2f220b000f33ea714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b61336ba7b19572a83d335a6aad65f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a93b61336ba7b19572a83d335a6aad65f">channel_mark_bad_for_new_circs</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a93b61336ba7b19572a83d335a6aad65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58978b931d8b11d4673287e59f8d54bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a58978b931d8b11d4673287e59f8d54bc">channel_is_canonical</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a58978b931d8b11d4673287e59f8d54bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2175e5e47f323e17e518474e8210907f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a2175e5e47f323e17e518474e8210907f">channel_is_canonical_is_reliable</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a2175e5e47f323e17e518474e8210907f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4970564e5ce0547254f76d09d942e0f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a4970564e5ce0547254f76d09d942e0f1">channel_is_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a4970564e5ce0547254f76d09d942e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7950c59a4fefcd76e3e3b327d86114f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ab7950c59a4fefcd76e3e3b327d86114f">channel_is_local</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ab7950c59a4fefcd76e3e3b327d86114f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94903f24f674c7a4dd95dd51e6b6b047"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a94903f24f674c7a4dd95dd51e6b6b047">channel_is_incoming</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a94903f24f674c7a4dd95dd51e6b6b047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150180857a5c09e9ab16095b6011fd06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a150180857a5c09e9ab16095b6011fd06">channel_is_outgoing</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a150180857a5c09e9ab16095b6011fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad8f3da9b53f2a239196da6a822420a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a3ad8f3da9b53f2a239196da6a822420a">channel_mark_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a3ad8f3da9b53f2a239196da6a822420a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb4f4e8f649a753d3d22fb84653c05b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a6cb4f4e8f649a753d3d22fb84653c05b">channel_matches_extend_info</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structextend__info__t.html">extend_info_t</a> *extend_info)</td></tr>
<tr class="separator:a6cb4f4e8f649a753d3d22fb84653c05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9744cd45d925184288dc3751fc1d455"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ae9744cd45d925184288dc3751fc1d455">channel_matches_target_addr_for_extend</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *target)</td></tr>
<tr class="separator:ae9744cd45d925184288dc3751fc1d455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae541683374c3002a6218c576c9775910"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ae541683374c3002a6218c576c9775910">channel_num_circuits</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ae541683374c3002a6218c576c9775910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2028e29817fcb43096dde3a1dc6a61e9"><td class="memItemLeft" align="right" valign="top"><a id="a2028e29817fcb43096dde3a1dc6a61e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (void, channel_set_circid_type,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structcrypto__pk__t.html">crypto_pk_t</a> *identity_rcvd, int consider_identity))</td></tr>
<tr class="separator:a2028e29817fcb43096dde3a1dc6a61e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cdde3933fc1ca5c83494d1fb0e684f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a20cdde3933fc1ca5c83494d1fb0e684f">channel_timestamp_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a20cdde3933fc1ca5c83494d1fb0e684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9310a1fa1a4d1cb1e3af383a98d902"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#abf9310a1fa1a4d1cb1e3af383a98d902">channel_update_xmit_queue_size</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:abf9310a1fa1a4d1cb1e3af383a98d902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0104c379fab8d5cf7dc3eddf113dc44e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a0104c379fab8d5cf7dc3eddf113dc44e">channel_listener_describe_transport</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a0104c379fab8d5cf7dc3eddf113dc44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e2ae335dbe5af256b18df4f3c1070e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e">channel_listener_dump_statistics</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l, int severity)</td></tr>
<tr class="separator:a31e2ae335dbe5af256b18df4f3c1070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8193e4c4351e724edc8ecaddd09f8e10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a8193e4c4351e724edc8ecaddd09f8e10">channel_listener_dump_transport_statistics</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l, int severity)</td></tr>
<tr class="separator:a8193e4c4351e724edc8ecaddd09f8e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc43b3c8ca79ff5ac832ac80489b28ae"><td class="memItemLeft" align="right" valign="top"><a id="adc43b3c8ca79ff5ac832ac80489b28ae"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>channel_get_global_queue_estimate</b> (void)</td></tr>
<tr class="separator:adc43b3c8ca79ff5ac832ac80489b28ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbcbfef4049d88a2975b9cf4ca71645"><td class="memItemLeft" align="right" valign="top"><a id="abcbcbfef4049d88a2975b9cf4ca71645"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>channel_num_cells_writeable</b> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:abcbcbfef4049d88a2975b9cf4ca71645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff1eebb5bba0a9371c5679994d51329"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aeff1eebb5bba0a9371c5679994d51329">channel_when_created</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:aeff1eebb5bba0a9371c5679994d51329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886fbc84390a27e4007562e2e3ddacb5"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a886fbc84390a27e4007562e2e3ddacb5">channel_when_last_active</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a886fbc84390a27e4007562e2e3ddacb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c9bb52317ac2f0189a286108bdc7e"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a7c7c9bb52317ac2f0189a286108bdc7e">channel_when_last_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a7c7c9bb52317ac2f0189a286108bdc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04116ec19eadb75b7315366655023791"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a04116ec19eadb75b7315366655023791">channel_when_last_drained</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a04116ec19eadb75b7315366655023791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbc61adb34b9ce4351a0d5f68915e52"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#adcbc61adb34b9ce4351a0d5f68915e52">channel_when_last_recv</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:adcbc61adb34b9ce4351a0d5f68915e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce5cc93d2f7a10ad18300c4049108ef"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a3ce5cc93d2f7a10ad18300c4049108ef">channel_when_last_xmit</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a3ce5cc93d2f7a10ad18300c4049108ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbcc9a594a0c1794e26a40e7c9dd99b"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a0dbcc9a594a0c1794e26a40e7c9dd99b">channel_listener_when_created</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a0dbcc9a594a0c1794e26a40e7c9dd99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1789dfc777235ab09dabb4977653b6"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a2f1789dfc777235ab09dabb4977653b6">channel_listener_when_last_active</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a2f1789dfc777235ab09dabb4977653b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8926e55f5ad9503ad24c9c4e6f663df5"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a8926e55f5ad9503ad24c9c4e6f663df5">channel_listener_when_last_accepted</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a8926e55f5ad9503ad24c9c4e6f663df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a626fd0d7ed9d4107ace44f7544224"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ad7a626fd0d7ed9d4107ace44f7544224">channel_count_recved</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ad7a626fd0d7ed9d4107ace44f7544224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633aef9ca1dea3cfa6dc0ed41edd725b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a633aef9ca1dea3cfa6dc0ed41edd725b">channel_count_xmitted</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a633aef9ca1dea3cfa6dc0ed41edd725b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b23c1e80a639fe9092437b9ddccadd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a24b23c1e80a639fe9092437b9ddccadd">channel_listener_count_accepted</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a24b23c1e80a639fe9092437b9ddccadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa036957ef1d90c086c403814da8de52f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aa036957ef1d90c086c403814da8de52f">packed_cell_is_destroy</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, const <a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *packed_cell, <a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> *circid_out)</td></tr>
<tr class="separator:aa036957ef1d90c086c403814da8de52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for <a class="el" href="channel_8c.html" title="OR/OP-to-OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ...">channel.c</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9f58e35a9f96bd9c180d6789d36f909d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f58e35a9f96bd9c180d6789d36f909d">&#9670;&nbsp;</a></span>CHANNEL_CAN_HANDLE_CELLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_CAN_HANDLE_CELLS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(CHANNEL_IS_OPENING(chan) || \</div><div class="line">                                        CHANNEL_IS_OPEN(chan) || \</div><div class="line">                                        CHANNEL_IS_MAINT(chan))</div></div><!-- fragment -->
</div>
</div>
<a id="a23464e5f02f6b1a57ec4c0a2c7234243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23464e5f02f6b1a57ec4c0a2c7234243">&#9670;&nbsp;</a></span>CHANNEL_CONDEMNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_CONDEMNED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(CHANNEL_IS_CLOSING(chan) || \</div><div class="line">                                 CHANNEL_FINISHED(chan))</div></div><!-- fragment -->
</div>
</div>
<a id="a600d56dd2c6f29545f5bb80bfab7d446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600d56dd2c6f29545f5bb80bfab7d446">&#9670;&nbsp;</a></span>CHANNEL_FINISHED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_FINISHED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(CHANNEL_IS_CLOSED(chan) || \</div><div class="line">                                CHANNEL_IS_ERROR(chan))</div></div><!-- fragment -->
</div>
</div>
<a id="a28abebb6c5d89a4b9c0d150e0a9caac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28abebb6c5d89a4b9c0d150e0a9caac0">&#9670;&nbsp;</a></span>CHANNEL_IS_CLOSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_CLOSED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                 CHANNEL_STATE_CLOSED))</div></div><!-- fragment -->
</div>
</div>
<a id="a9958211f3b4e0531e259c147ef602993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9958211f3b4e0531e259c147ef602993">&#9670;&nbsp;</a></span>CHANNEL_IS_CLOSING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_CLOSING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                  CHANNEL_STATE_CLOSING))</div></div><!-- fragment -->
</div>
</div>
<a id="ac8df712558f5f955701d0d5db99ffe78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8df712558f5f955701d0d5db99ffe78">&#9670;&nbsp;</a></span>CHANNEL_IS_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                CHANNEL_STATE_ERROR))</div></div><!-- fragment -->
</div>
</div>
<a id="ab8606f53d3d0e710fbc2ba63ae274df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8606f53d3d0e710fbc2ba63ae274df2">&#9670;&nbsp;</a></span>CHANNEL_IS_MAINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_MAINT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                CHANNEL_STATE_MAINT))</div></div><!-- fragment -->
</div>
</div>
<a id="ad144fc71cf2d9f27cdfb0d49cb57d816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad144fc71cf2d9f27cdfb0d49cb57d816">&#9670;&nbsp;</a></span>CHANNEL_IS_OPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_OPEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                               CHANNEL_STATE_OPEN))</div></div><!-- fragment -->
</div>
</div>
<a id="a3d6cdc5661f051c45f7aeb36d6d00a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6cdc5661f051c45f7aeb36d6d00a94">&#9670;&nbsp;</a></span>CHANNEL_IS_OPENING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_OPENING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                  CHANNEL_STATE_OPENING))</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a13b8cc7d1d3dbbdca20c863c3cb35273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b8cc7d1d3dbbdca20c863c3cb35273">&#9670;&nbsp;</a></span>channel_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id_digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect to a given addr/port/digest</p>
<p>This sets up a new outgoing channel; in the future if multiple channel_t subclasses are available, this is where the selection policy should go. It may also be desirable to fold port into <a class="el" href="structtor__addr__t.html">tor_addr_t</a> or make a new type including a <a class="el" href="structtor__addr__t.html">tor_addr_t</a> and port, so we have a single abstract object encapsulating all the protocol details of how to contact an OR. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a13b8cc7d1d3dbbdca20c863c3cb35273_cgraph.png" border="0" usemap="#channel_8h_a13b8cc7d1d3dbbdca20c863c3cb35273_cgraph" alt=""/></div>
<map name="channel_8h_a13b8cc7d1d3dbbdca20c863c3cb35273_cgraph" id="channel_8h_a13b8cc7d1d3dbbdca20c863c3cb35273_cgraph">
<area shape="rect" id="node2" href="channeltls_8c.html#a7a89e235963df96d4b8df41e90dd9447" title="channel_tls_connect" alt="" coords="173,5,315,32"/>
</map>
</div>

</div>
</div>
<a id="ad7a626fd0d7ed9d4107ace44f7544224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a626fd0d7ed9d4107ace44f7544224">&#9670;&nbsp;</a></span>channel_count_recved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t channel_count_recved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query received cell counter </p>

</div>
</div>
<a id="a633aef9ca1dea3cfa6dc0ed41edd725b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633aef9ca1dea3cfa6dc0ed41edd725b">&#9670;&nbsp;</a></span>channel_count_xmitted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t channel_count_xmitted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query transmitted cell counter </p>

</div>
</div>
<a id="a185d59ac3e69ab26d2b71804cb882993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185d59ac3e69ab26d2b71804cb882993">&#9670;&nbsp;</a></span>channel_describe_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_describe_transport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describe the transport subclass for a channel</p>
<p>Invoke a method to get a string description of the lower-layer transport for this channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a185d59ac3e69ab26d2b71804cb882993_icgraph.png" border="0" usemap="#channel_8h_a185d59ac3e69ab26d2b71804cb882993_icgraph" alt=""/></div>
<map name="channel_8h_a185d59ac3e69ab26d2b71804cb882993_icgraph" id="channel_8h_a185d59ac3e69ab26d2b71804cb882993_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ab56dc7ecc8a31e8bfa4dc5281b72c21e" title="MOCK_IMPL" alt="" coords="235,5,335,32"/>
</map>
</div>

</div>
</div>
<a id="ae2704646dbc4d5113c2160fd9842f128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2704646dbc4d5113c2160fd9842f128">&#9670;&nbsp;</a></span>channel_dump_transport_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_dump_transport_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoke transport-specific stats dump for channel</p>
<p>If there is a lower-layer statistics dump method, invoke it </p>

</div>
</div>
<a id="a1ef365ba78cdfea35f694be31bfd6e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef365ba78cdfea35f694be31bfd6e91">&#9670;&nbsp;</a></span>channel_dumpstats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_dumpstats </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel statistics to the log</p>
<p>This is called from dumpstats() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a> and spams the log with statistics on channels. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_cgraph.png" border="0" usemap="#channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_cgraph" alt=""/></div>
<map name="channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_cgraph" id="channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="188,5,249,32"/>
</map>
</div>

</div>
</div>
<a id="a03ce362c180c51c5018668bae7bb4f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ce362c180c51c5018668bae7bb4f24">&#9670;&nbsp;</a></span>channel_find_by_global_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_find_by_global_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>global_identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Channel lookups</p>
<p>Find channel by global ID</p>
<p>This function searches for a channel by the global_identifier assigned at initialization time. This identifier is unique for the lifetime of the Tor process. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a03ce362c180c51c5018668bae7bb4f24_icgraph.png" border="0" usemap="#channel_8h_a03ce362c180c51c5018668bae7bb4f24_icgraph" alt=""/></div>
<map name="channel_8h_a03ce362c180c51c5018668bae7bb4f24_icgraph" id="channel_8h_a03ce362c180c51c5018668bae7bb4f24_icgraph">
<area shape="rect" id="node2" href="circuitmux_8h.html#a4a5fff70da3c5abf8e3ae7abd1aee1cc" title="circuitmux_set_policy" alt="" coords="228,42,376,69"/>
<area shape="rect" id="node3" href="channel_8h.html#ab581fe82a432b885561d00ab3ecceba6" title="channel_set_cmux_policy\l_everywhere" alt="" coords="424,5,596,47"/>
<area shape="rect" id="node4" href="circuitmux_8h.html#a1eefa6dc14786d08f7dcc6a9d33c11b2" title="circuitmux_clear_policy" alt="" coords="431,71,589,98"/>
</map>
</div>

</div>
</div>
<a id="a0542e2ca72fe8da87de8ea2f711dd7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0542e2ca72fe8da87de8ea2f711dd7dc">&#9670;&nbsp;</a></span>channel_find_by_remote_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_find_by_remote_digest </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>identity_digest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find channel by digest of the remote endpoint</p>
<p>This function looks up a channel by the digest of its remote endpoint in the channel digest map. It's possible that more than one channel to a given endpoint exists. Use <a class="el" href="channel_8c.html#a53ee6566b1661b9e37181d8f83efdfbd">channel_next_with_digest()</a> to walk the list. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a0542e2ca72fe8da87de8ea2f711dd7dc_icgraph.png" border="0" usemap="#channel_8h_a0542e2ca72fe8da87de8ea2f711dd7dc_icgraph" alt=""/></div>
<map name="channel_8h_a0542e2ca72fe8da87de8ea2f711dd7dc_icgraph" id="channel_8h_a0542e2ca72fe8da87de8ea2f711dd7dc_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a41ebc2554b7f8fd2b5c331bf7dc94ecc" title="channel_get_for_extend" alt="" coords="216,13,376,39"/>
</map>
</div>

</div>
</div>
<a id="adb2d84e3ecc8f662ed2072a2104d0b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2d84e3ecc8f662ed2072a2104d0b6b">&#9670;&nbsp;</a></span>channel_free_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_free_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close all channels and free everything</p>
<p>This gets called from <a class="el" href="main_8c.html#a3d840759318fbf94fb7009cc0fba5c5d">tor_free_all()</a> in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a> to clean up on exit. It will close all registered channels and free associated storage, then free the all_channels, active_channels, listening_channels and finished_channels lists and also channel_identity_map. </p>

</div>
</div>
<a id="a3c1c9c62855d488fa17eaa4c4dd3f6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1c9c62855d488fa17eaa4c4dd3f6e5">&#9670;&nbsp;</a></span>channel_get_actual_remote_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_get_actual_remote_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the text address of the remote endpoint.</p>
<p>Subsequent calls to channel_get_{actual,canonical}_remote_{address,descr} may invalidate the return value from this function. </p>

</div>
</div>
<a id="a8608773117c50600ebe58ffc331b6b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8608773117c50600ebe58ffc331b6b3e">&#9670;&nbsp;</a></span>channel_get_actual_remote_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_get_actual_remote_descr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return text description of the remote endpoint</p>
<p>This function return a test provided by the lower layer of the remote endpoint for this channel; it should specify the actual address connected to/from.</p>
<p>Subsequent calls to channel_get_{actual,canonical}_remote_{address,descr} may invalidate the return value from this function. </p>

</div>
</div>
<a id="a5a9a5bd1e17411b06028d4839ad6e6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a5bd1e17411b06028d4839ad6e6df">&#9670;&nbsp;</a></span>channel_get_canonical_remote_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_get_canonical_remote_descr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return text description of the remote endpoint canonical address</p>
<p>This function return a test provided by the lower layer of the remote endpoint for this channel; it should use the known canonical address for this OR's identity digest if possible.</p>
<p>Subsequent calls to channel_get_{actual,canonical}_remote_{address,descr} may invalidate the return value from this function. </p>

</div>
</div>
<a id="a9f3b8c3a3d91967c63fea496d2fe1b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3b8c3a3d91967c63fea496d2fe1b2e">&#9670;&nbsp;</a></span>channel_get_cell_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">channel_cell_handler_fn_ptr channel_get_cell_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the fixed-length cell handler for a channel</p>
<p>This function gets the handler for incoming fixed-length cells installed on a channel. </p>

</div>
</div>
<a id="a41ebc2554b7f8fd2b5c331bf7dc94ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ebc2554b7f8fd2b5c331bf7dc94ecc">&#9670;&nbsp;</a></span>channel_get_for_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_get_for_extend </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>target_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>msg_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>launch_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a channel to extend a circuit</p>
<p>Pick a suitable channel to extend a circuit to given the desired digest the address we believe is correct for that digest; this tries to see if we already have one for the requested endpoint, but if there is no good channel, set *msg_out to a message describing the channel's state and our next action, and set *launch_out to a boolean indicated whether the caller should try to launch a new channel with <a class="el" href="channel_8c.html#a13b8cc7d1d3dbbdca20c863c3cb35273">channel_connect()</a>. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a41ebc2554b7f8fd2b5c331bf7dc94ecc_cgraph.png" border="0" usemap="#channel_8h_a41ebc2554b7f8fd2b5c331bf7dc94ecc_cgraph" alt=""/></div>
<map name="channel_8h_a41ebc2554b7f8fd2b5c331bf7dc94ecc_cgraph" id="channel_8h_a41ebc2554b7f8fd2b5c331bf7dc94ecc_cgraph">
<area shape="rect" id="node2" href="util_8c.html#aca03d8cb6a22d540b13b92ea5945df33" title="approx_time" alt="" coords="253,5,346,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a0542e2ca72fe8da87de8ea2f711dd7dc" title="channel_find_by_remote\l_digest" alt="" coords="218,57,381,98"/>
<area shape="rect" id="node4" href="channel_8c.html#a53ee6566b1661b9e37181d8f83efdfbd" title="channel_next_with_digest" alt="" coords="213,123,385,149"/>
<area shape="rect" id="node5" href="di__ops_8c.html#a473334ee93cca0aea10523321a444ea3" title="tor_memeq" alt="" coords="256,173,343,200"/>
</map>
</div>

</div>
</div>
<a id="aee619f7637f1a10fec2da20ea004e998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee619f7637f1a10fec2da20ea004e998">&#9670;&nbsp;</a></span>channel_get_var_cell_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">channel_var_cell_handler_fn_ptr channel_get_var_cell_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the variable-length cell handler for a channel</p>
<p>This function gets the handler for incoming variable-length cells installed on a channel. </p>

</div>
</div>
<a id="a02db0f9ae91b50323bd345a224d9d1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02db0f9ae91b50323bd345a224d9d1d8">&#9670;&nbsp;</a></span>channel_has_queued_writes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_has_queued_writes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if there are outgoing queue writes on this channel</p>
<p>Indicate if either we have queued cells, or if not, whether the underlying lower-layer transport thinks it has an output queue. </p>

</div>
</div>
<a id="a118d357c7f7accb2f220b000f33ea714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118d357c7f7accb2f220b000f33ea714">&#9670;&nbsp;</a></span>channel_is_bad_for_new_circs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_bad_for_new_circs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the is_bad_for_new_circs flag</p>
<p>This function returns the is_bad_for_new_circs flag of the specified channel. </p>

</div>
</div>
<a id="aa37fcbdaafeac83501c1699e61d8e128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37fcbdaafeac83501c1699e61d8e128">&#9670;&nbsp;</a></span>channel_is_better()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_better </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>forgive_new_connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decide which of two channels to prefer for extending a circuit</p>
<p>This function is called while extending a circuit and returns true iff a is 'better' than b. The most important criterion here is that a canonical channel is always better than a non-canonical one, but the number of circuits and the age are used as tie-breakers.</p>
<p>This is based on the former connection_or_is_better() of <a class="el" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. ">connection_or.c</a> </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_aa37fcbdaafeac83501c1699e61d8e128_cgraph.png" border="0" usemap="#channel_8h_aa37fcbdaafeac83501c1699e61d8e128_cgraph" alt=""/></div>
<map name="channel_8h_aa37fcbdaafeac83501c1699e61d8e128_cgraph" id="channel_8h_aa37fcbdaafeac83501c1699e61d8e128_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a58978b931d8b11d4673287e59f8d54bc" title="channel_is_canonical" alt="" coords="181,5,328,32"/>
<area shape="rect" id="node3" href="channel_8c.html#ae541683374c3002a6218c576c9775910" title="channel_num_circuits" alt="" coords="181,56,329,83"/>
<area shape="rect" id="node4" href="channel_8c.html#aeff1eebb5bba0a9371c5679994d51329" title="channel_when_created" alt="" coords="177,107,332,133"/>
</map>
</div>

</div>
</div>
<a id="a58978b931d8b11d4673287e59f8d54bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58978b931d8b11d4673287e59f8d54bc">&#9670;&nbsp;</a></span>channel_is_canonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_canonical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the canonical flag for a channel</p>
<p>This returns the is_canonical for a channel; this flag is determined by the lower layer and can't be set in a transport-independent way. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a58978b931d8b11d4673287e59f8d54bc_icgraph.png" border="0" usemap="#channel_8h_a58978b931d8b11d4673287e59f8d54bc_icgraph" alt=""/></div>
<map name="channel_8h_a58978b931d8b11d4673287e59f8d54bc_icgraph" id="channel_8h_a58978b931d8b11d4673287e59f8d54bc_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#aa37fcbdaafeac83501c1699e61d8e128" title="channel_is_better" alt="" coords="200,5,324,32"/>
</map>
</div>

</div>
</div>
<a id="a2175e5e47f323e17e518474e8210907f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2175e5e47f323e17e518474e8210907f">&#9670;&nbsp;</a></span>channel_is_canonical_is_reliable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_canonical_is_reliable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if the canonical flag is reliable</p>
<p>This function asks if the lower layer thinks it's safe to trust the result of <a class="el" href="channel_8c.html#a58978b931d8b11d4673287e59f8d54bc">channel_is_canonical()</a> </p>

</div>
</div>
<a id="a4970564e5ce0547254f76d09d942e0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4970564e5ce0547254f76d09d942e0f1">&#9670;&nbsp;</a></span>channel_is_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the client flag</p>
<p>This returns the client flag of a channel, which will be set if command_process_create_cell() in <a class="el" href="command_8c.html" title="Functions for processing incoming cells. ">command.c</a> thinks this is a connection from a client. </p>

</div>
</div>
<a id="a94903f24f674c7a4dd95dd51e6b6b047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94903f24f674c7a4dd95dd51e6b6b047">&#9670;&nbsp;</a></span>channel_is_incoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_incoming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test incoming flag</p>
<p>This function gets the incoming flag; this is set when a listener spawns a channel. If this returns true the channel was remotely initiated. </p>

</div>
</div>
<a id="ab7950c59a4fefcd76e3e3b327d86114f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7950c59a4fefcd76e3e3b327d86114f">&#9670;&nbsp;</a></span>channel_is_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test local flag</p>
<p>This function gets the local flag; the lower layer should set this when setting up the channel if is_local_addr() is true for all of the destinations it will communicate with on behalf of this channel. It's used to decide whether to declare the network reachable when seeing incoming traffic on the channel. </p>

</div>
</div>
<a id="a150180857a5c09e9ab16095b6011fd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150180857a5c09e9ab16095b6011fd06">&#9670;&nbsp;</a></span>channel_is_outgoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_outgoing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test outgoing flag</p>
<p>This function gets the outgoing flag; this is the inverse of the incoming bit set when a listener spawns a channel. If this returns true the channel was locally initiated. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a150180857a5c09e9ab16095b6011fd06_icgraph.png" border="0" usemap="#channel_8h_a150180857a5c09e9ab16095b6011fd06_icgraph" alt=""/></div>
<map name="channel_8h_a150180857a5c09e9ab16095b6011fd06_icgraph" id="channel_8h_a150180857a5c09e9ab16095b6011fd06_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#a4bb9524073333e156da271ca623a772d" title="channel_do_open_actions" alt="" coords="193,5,365,32"/>
<area shape="rect" id="node3" href="channel_8c.html#ae9d6f1fad148b483bdb8d2443dab0718" title="MOCK_IMPL" alt="" coords="229,56,329,83"/>
</map>
</div>

</div>
</div>
<a id="a24b23c1e80a639fe9092437b9ddccadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b23c1e80a639fe9092437b9ddccadd">&#9670;&nbsp;</a></span>channel_listener_count_accepted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t channel_listener_count_accepted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query accepted counter </p>

</div>
</div>
<a id="a0104c379fab8d5cf7dc3eddf113dc44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0104c379fab8d5cf7dc3eddf113dc44e">&#9670;&nbsp;</a></span>channel_listener_describe_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_listener_describe_transport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describe the transport subclass for a channel listener</p>
<p>Invoke a method to get a string description of the lower-layer transport for this channel listener. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph.png" border="0" usemap="#channel_8h_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph" alt=""/></div>
<map name="channel_8h_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph" id="channel_8h_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="225,5,380,47"/>
<area shape="rect" id="node3" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="428,13,612,39"/>
</map>
</div>

</div>
</div>
<a id="a31e2ae335dbe5af256b18df4f3c1070e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e2ae335dbe5af256b18df4f3c1070e">&#9670;&nbsp;</a></span>channel_listener_dump_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_dump_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel listener statistics</p>
<p>Dump statistics for one channel listener to the log </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_cgraph.png" border="0" usemap="#channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_cgraph" alt=""/></div>
<map name="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_cgraph" id="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="263,5,325,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a0104c379fab8d5cf7dc3eddf113dc44e" title="channel_listener_describe\l_transport" alt="" coords="208,57,380,98"/>
<area shape="rect" id="node4" href="channel_8c.html#aee0cac4ba2733cffddc9ff59be701687" title="channel_listener_state\l_to_string" alt="" coords="218,122,370,163"/>
<area shape="rect" id="node5" href="channel_8c.html#a8193e4c4351e724edc8ecaddd09f8e10" title="channel_listener_dump\l_transport_statistics" alt="" coords="217,187,371,229"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_icgraph.png" border="0" usemap="#channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_icgraph" alt=""/></div>
<map name="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_icgraph" id="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="208,13,392,39"/>
</map>
</div>

</div>
</div>
<a id="a8193e4c4351e724edc8ecaddd09f8e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8193e4c4351e724edc8ecaddd09f8e10">&#9670;&nbsp;</a></span>channel_listener_dump_transport_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_dump_transport_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoke transport-specific stats dump for channel listener</p>
<p>If there is a lower-layer statistics dump method, invoke it </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a8193e4c4351e724edc8ecaddd09f8e10_icgraph.png" border="0" usemap="#channel_8h_a8193e4c4351e724edc8ecaddd09f8e10_icgraph" alt=""/></div>
<map name="channel_8h_a8193e4c4351e724edc8ecaddd09f8e10_icgraph" id="channel_8h_a8193e4c4351e724edc8ecaddd09f8e10_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="208,5,363,47"/>
<area shape="rect" id="node3" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="411,13,595,39"/>
</map>
</div>

</div>
</div>
<a id="ab0519ba6c6b14de83e886ed42095fe68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0519ba6c6b14de83e886ed42095fe68">&#9670;&nbsp;</a></span>channel_listener_dumpstats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_dumpstats </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel listener statistics to the log</p>
<p>This is called from dumpstats() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a> and spams the log with statistics on channel listeners. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_ab0519ba6c6b14de83e886ed42095fe68_cgraph.png" border="0" usemap="#channel_8h_ab0519ba6c6b14de83e886ed42095fe68_cgraph" alt=""/></div>
<map name="channel_8h_ab0519ba6c6b14de83e886ed42095fe68_cgraph" id="channel_8h_ab0519ba6c6b14de83e886ed42095fe68_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="495,5,557,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="237,57,392,98"/>
<area shape="rect" id="node4" href="channel_8c.html#a0104c379fab8d5cf7dc3eddf113dc44e" title="channel_listener_describe\l_transport" alt="" coords="440,57,612,98"/>
<area shape="rect" id="node5" href="channel_8c.html#aee0cac4ba2733cffddc9ff59be701687" title="channel_listener_state\l_to_string" alt="" coords="450,122,602,163"/>
<area shape="rect" id="node6" href="channel_8c.html#a8193e4c4351e724edc8ecaddd09f8e10" title="channel_listener_dump\l_transport_statistics" alt="" coords="449,187,603,229"/>
</map>
</div>

</div>
</div>
<a id="ab1245962c49dfe3349cf00e0cacd7f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1245962c49dfe3349cf00e0cacd7f15">&#9670;&nbsp;</a></span>channel_listener_get_listener_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">channel_listener_fn_ptr channel_listener_get_listener_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the current registered listener for a channel listener</p>
<p>This function returns a function pointer to the current registered handler for new incoming channels on a channel listener. </p>

</div>
</div>
<a id="a4d328d0eebd17c646ec3a1ff4442d827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d328d0eebd17c646ec3a1ff4442d827">&#9670;&nbsp;</a></span>channel_listener_mark_for_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_mark_for_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel listener for closure</p>
<p>This function tries to close a channel_listener_t; it will go into the CLOSING state, and eventually the lower layer should put it into the CLOSED or ERROR state. Then, <a class="el" href="channel_8c.html#a1d874b0dd28680dd7f9661e2490d9091">channel_run_cleanup()</a> will eventually free it. </p>

</div>
</div>
<a id="a3e7838364ded7b78a661a1f3f2f1c266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7838364ded7b78a661a1f3f2f1c266">&#9670;&nbsp;</a></span>channel_listener_run_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_run_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up channel listeners</p>
<p>This gets called periodically from run_scheduled_events() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a>; it cleans up after closed channel listeners. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a3e7838364ded7b78a661a1f3f2f1c266_cgraph.png" border="0" usemap="#channel_8h_a3e7838364ded7b78a661a1f3f2f1c266_cgraph" alt=""/></div>
<map name="channel_8h_a3e7838364ded7b78a661a1f3f2f1c266_cgraph" id="channel_8h_a3e7838364ded7b78a661a1f3f2f1c266_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a2d954d609b0decab6e56e2ab7e2444f6" title="channel_listener_unregister" alt="" coords="195,5,375,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a5140f151872899d07a2f1cd451902d38" title="channel_listener_free" alt="" coords="212,56,357,83"/>
</map>
</div>

</div>
</div>
<a id="a7ed86da67099b40c8eea25752b2260da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed86da67099b40c8eea25752b2260da">&#9670;&nbsp;</a></span>channel_listener_set_listener_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_set_listener_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_listener_fn_ptr&#160;</td>
          <td class="paramname"><em>listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the listener for a channel listener</p>
<p>This function sets the handler for new incoming channels on a channel listener. </p>

</div>
</div>
<a id="a447edc0876c6c437ae72b5c49b8e038a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447edc0876c6c437ae72b5c49b8e038a">&#9670;&nbsp;</a></span>channel_listener_state_can_transition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_listener_state_can_transition </td>
          <td>(</td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a channel listener state transition is valid</p>
<p>This function takes two channel listener states and indicates whether a transition between them is permitted (see the state definitions and transition table in <a class="el" href="or_8h.html" title="Master header file for Tor-specific functionality. ">or.h</a> at the channel_listener_state_t typedef). </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a447edc0876c6c437ae72b5c49b8e038a_icgraph.png" border="0" usemap="#channel_8h_a447edc0876c6c437ae72b5c49b8e038a_icgraph" alt=""/></div>
<map name="channel_8h_a447edc0876c6c437ae72b5c49b8e038a_icgraph" id="channel_8h_a447edc0876c6c437ae72b5c49b8e038a_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ad0126606a15537e0647e81a9c2ca8b74" title="channel_listener_change\l_state" alt="" coords="205,5,371,47"/>
</map>
</div>

</div>
</div>
<a id="a5bdf98e720a6acc2e476e681e91e4fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdf98e720a6acc2e476e681e91e4fde">&#9670;&nbsp;</a></span>channel_listener_state_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_listener_state_is_valid </td>
          <td>(</td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a given channel listener state is valid </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a5bdf98e720a6acc2e476e681e91e4fde_icgraph.png" border="0" usemap="#channel_8h_a5bdf98e720a6acc2e476e681e91e4fde_icgraph" alt=""/></div>
<map name="channel_8h_a5bdf98e720a6acc2e476e681e91e4fde_icgraph" id="channel_8h_a5bdf98e720a6acc2e476e681e91e4fde_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ad0126606a15537e0647e81a9c2ca8b74" title="channel_listener_change\l_state" alt="" coords="205,5,371,47"/>
</map>
</div>

</div>
</div>
<a id="aee0cac4ba2733cffddc9ff59be701687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0cac4ba2733cffddc9ff59be701687">&#9670;&nbsp;</a></span>channel_listener_state_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_listener_state_to_string </td>
          <td>(</td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a human-readable description for a channel listenier state </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_aee0cac4ba2733cffddc9ff59be701687_icgraph.png" border="0" usemap="#channel_8h_aee0cac4ba2733cffddc9ff59be701687_icgraph" alt=""/></div>
<map name="channel_8h_aee0cac4ba2733cffddc9ff59be701687_icgraph" id="channel_8h_aee0cac4ba2733cffddc9ff59be701687_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="205,5,360,47"/>
<area shape="rect" id="node3" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="408,13,592,39"/>
</map>
</div>

</div>
</div>
<a id="a0dbcc9a594a0c1794e26a40e7c9dd99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbcc9a594a0c1794e26a40e7c9dd99b">&#9670;&nbsp;</a></span>channel_listener_when_created()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_listener_when_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query created timestamp for a channel listener </p>

</div>
</div>
<a id="a8926e55f5ad9503ad24c9c4e6f663df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8926e55f5ad9503ad24c9c4e6f663df5">&#9670;&nbsp;</a></span>channel_listener_when_last_accepted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_listener_when_last_accepted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query last accepted timestamp for a channel listener </p>

</div>
</div>
<a id="a2f1789dfc777235ab09dabb4977653b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1789dfc777235ab09dabb4977653b6">&#9670;&nbsp;</a></span>channel_listener_when_last_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_listener_when_last_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query last active timestamp for a channel listener </p>

</div>
</div>
<a id="a93b61336ba7b19572a83d335a6aad65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b61336ba7b19572a83d335a6aad65f">&#9670;&nbsp;</a></span>channel_mark_bad_for_new_circs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_bad_for_new_circs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel as bad for new circuits</p>
<p>Set the is_bad_for_new_circs_flag on chan. </p>

</div>
</div>
<a id="a3ad8f3da9b53f2a239196da6a822420a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad8f3da9b53f2a239196da6a822420a">&#9670;&nbsp;</a></span>channel_mark_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the client flag</p>
<p>Mark a channel as being from a client </p>

</div>
</div>
<a id="ac5c51ad12ff89e0f63cc386ccda8493f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c51ad12ff89e0f63cc386ccda8493f">&#9670;&nbsp;</a></span>channel_mark_for_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_for_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel for closure</p>
<p>This function tries to close a channel_t; it will go into the CLOSING state, and eventually the lower layer should put it into the CLOSED or ERROR state. Then, <a class="el" href="channel_8c.html#a1d874b0dd28680dd7f9661e2490d9091">channel_run_cleanup()</a> will eventually free it. </p>

</div>
</div>
<a id="a6cb4f4e8f649a753d3d22fb84653c05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb4f4e8f649a753d3d22fb84653c05b">&#9670;&nbsp;</a></span>channel_matches_extend_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_matches_extend_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structextend__info__t.html">extend_info_t</a> *&#160;</td>
          <td class="paramname"><em>extend_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a channel matches an <a class="el" href="structextend__info__t.html">extend_info_t</a></p>
<p>This function calls the lower layer and asks if this channel matches a given <a class="el" href="structextend__info__t.html">extend_info_t</a>. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph.png" border="0" usemap="#channel_8h_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph" alt=""/></div>
<map name="channel_8h_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph" id="channel_8h_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph">
<area shape="rect" id="node2" href="circuitlist_8h.html#aaef0c4aefe50f0432478e21e51814a34" title="circuit_get_all_pending\l_on_channel" alt="" coords="252,5,407,47"/>
<area shape="rect" id="node3" href="circuitlist_8h.html#aa797a036ce04a0d14f669e656ec62408" title="circuit_count_pending\l_on_channel" alt="" coords="455,5,603,47"/>
</map>
</div>

</div>
</div>
<a id="ae9744cd45d925184288dc3751fc1d455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9744cd45d925184288dc3751fc1d455">&#9670;&nbsp;</a></span>channel_matches_target_addr_for_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_matches_target_addr_for_extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a channel matches a given target address; return true iff we do.</p>
<p>This function calls into the lower layer and asks if this channel thinks it matches a given target address for circuit extension purposes. </p>

</div>
</div>
<a id="a53ee6566b1661b9e37181d8f83efdfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ee6566b1661b9e37181d8f83efdfbd">&#9670;&nbsp;</a></span>channel_next_with_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_next_with_digest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For things returned by <a class="el" href="channel_8c.html#a0542e2ca72fe8da87de8ea2f711dd7dc">channel_find_by_remote_digest()</a>, walk the list.</p>
<p>Get next channel with digest</p>
<p>This function takes a channel and finds the next channel in the list with the same digest. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a53ee6566b1661b9e37181d8f83efdfbd_icgraph.png" border="0" usemap="#channel_8h_a53ee6566b1661b9e37181d8f83efdfbd_icgraph" alt=""/></div>
<map name="channel_8h_a53ee6566b1661b9e37181d8f83efdfbd_icgraph" id="channel_8h_a53ee6566b1661b9e37181d8f83efdfbd_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a41ebc2554b7f8fd2b5c331bf7dc94ecc" title="channel_get_for_extend" alt="" coords="225,5,385,32"/>
</map>
</div>

</div>
</div>
<a id="ae541683374c3002a6218c576c9775910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae541683374c3002a6218c576c9775910">&#9670;&nbsp;</a></span>channel_num_circuits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int channel_num_circuits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of circuits used by a channel</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>Channel to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of circuits using this as n_chan or p_chan </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_ae541683374c3002a6218c576c9775910_icgraph.png" border="0" usemap="#channel_8h_ae541683374c3002a6218c576c9775910_icgraph" alt=""/></div>
<map name="channel_8h_ae541683374c3002a6218c576c9775910_icgraph" id="channel_8h_ae541683374c3002a6218c576c9775910_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#aa37fcbdaafeac83501c1699e61d8e128" title="channel_is_better" alt="" coords="201,5,325,32"/>
<area shape="rect" id="node3" href="connection__or_8c.html#a91065ac60ede0c2ccdaf7d2ff4892d5d" title="MOCK_IMPL" alt="" coords="213,56,313,83"/>
</map>
</div>

</div>
</div>
<a id="a1d874b0dd28680dd7f9661e2490d9091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d874b0dd28680dd7f9661e2490d9091">&#9670;&nbsp;</a></span>channel_run_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_run_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up channels</p>
<p>This gets called periodically from run_scheduled_events() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a>; it cleans up after closed channels. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a1d874b0dd28680dd7f9661e2490d9091_cgraph.png" border="0" usemap="#channel_8h_a1d874b0dd28680dd7f9661e2490d9091_cgraph" alt=""/></div>
<map name="channel_8h_a1d874b0dd28680dd7f9661e2490d9091_cgraph" id="channel_8h_a1d874b0dd28680dd7f9661e2490d9091_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a9bbc6210c258ddbc944e9f0d6d386b45" title="channel_unregister" alt="" coords="197,5,328,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a3ac80d0068b62d8da9adddb13ff2a6cf" title="channel_free" alt="" coords="215,56,311,83"/>
</map>
</div>

</div>
</div>
<a id="a85e3e2de528821cdda969fba6de1e4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e3e2de528821cdda969fba6de1e4f2">&#9670;&nbsp;</a></span>channel_send_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_send_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a>&#160;</td>
          <td class="paramname"><em>circ_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send destroy cell on a channel</p>
<p>Write a destroy cell with circ ID <b>circ_id</b> and reason <b>reason</b> onto channel <b>chan</b>. Don't perform range-checking on reason: we may want to propagate reasons from other cells. </p>

</div>
</div>
<a id="a5c26cbf4843fb4609f3f0c1eee87498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c26cbf4843fb4609f3f0c1eee87498c">&#9670;&nbsp;</a></span>channel_set_cell_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_set_cell_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_cell_handler_fn_ptr&#160;</td>
          <td class="paramname"><em>cell_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_var_cell_handler_fn_ptr&#160;</td>
          <td class="paramname"><em>var_cell_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set both cell handlers for a channel</p>
<p>This function sets both the fixed-length and variable length cell handlers for a channel and processes any incoming cells that had been blocked in the queue because none were available. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph.png" border="0" usemap="#channel_8h_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph" alt=""/></div>
<map name="channel_8h_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph" id="channel_8h_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph">
<area shape="rect" id="node2" href="command_8h.html#ad5d1278e8abe0ae9ca6ff9d04bed82f2" title="command_setup_channel" alt="" coords="228,5,399,32"/>
</map>
</div>

</div>
</div>
<a id="ab581fe82a432b885561d00ab3ecceba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab581fe82a432b885561d00ab3ecceba6">&#9670;&nbsp;</a></span>channel_set_cmux_policy_everywhere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_set_cmux_policy_everywhere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcircuitmux__policy__s.html">circuitmux_policy_t</a> *&#160;</td>
          <td class="paramname"><em>pol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the cmux policy on all active channels </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_ab581fe82a432b885561d00ab3ecceba6_cgraph.png" border="0" usemap="#channel_8h_ab581fe82a432b885561d00ab3ecceba6_cgraph" alt=""/></div>
<map name="channel_8h_ab581fe82a432b885561d00ab3ecceba6_cgraph" id="channel_8h_ab581fe82a432b885561d00ab3ecceba6_cgraph">
<area shape="rect" id="node2" href="circuitmux_8c.html#a4a5fff70da3c5abf8e3ae7abd1aee1cc" title="circuitmux_set_policy" alt="" coords="225,35,373,61"/>
<area shape="rect" id="node3" href="channel_8c.html#a03ce362c180c51c5018668bae7bb4f24" title="channel_find_by_global_id" alt="" coords="421,5,596,32"/>
<area shape="rect" id="node4" href="circuitlist_8c.html#a0b3f5de779a301bc93a2293e6f689b60" title="circuit_get_by_circid\l_channel_even_if_marked" alt="" coords="422,57,595,98"/>
</map>
</div>

</div>
</div>
<a id="a727f5f4b03dca7d9b0ef71842709c055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727f5f4b03dca7d9b0ef71842709c055">&#9670;&nbsp;</a></span>channel_state_can_transition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_state_can_transition </td>
          <td>(</td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a channel state transition is valid</p>
<p>This function takes two channel states and indicates whether a transition between them is permitted (see the state definitions and transition table in <a class="el" href="or_8h.html" title="Master header file for Tor-specific functionality. ">or.h</a> at the channel_state_t typedef). </p>

</div>
</div>
<a id="ac5368fc8c3c7f7b0ce1020927961c92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5368fc8c3c7f7b0ce1020927961c92a">&#9670;&nbsp;</a></span>channel_state_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_state_to_string </td>
          <td>(</td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a human-readable description for a channel state </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph.png" border="0" usemap="#channel_8h_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph" alt=""/></div>
<map name="channel_8h_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph" id="channel_8h_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ab56dc7ecc8a31e8bfa4dc5281b72c21e" title="MOCK_IMPL" alt="" coords="213,5,313,32"/>
</map>
</div>

</div>
</div>
<a id="a20cdde3933fc1ca5c83494d1fb0e684f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cdde3933fc1ca5c83494d1fb0e684f">&#9670;&nbsp;</a></span>channel_timestamp_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_timestamp_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update client timestamp</p>
<p>This function is called by <a class="el" href="relay_8c.html" title="Handle relay cell encryption/decryption, plus packaging and receiving from circuits, plus queuing on circuits. ">relay.c</a> to timestamp a channel that appears to be used as a client. </p>

</div>
</div>
<a id="abf9310a1fa1a4d1cb1e3af383a98d902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9310a1fa1a4d1cb1e3af383a98d902">&#9670;&nbsp;</a></span>channel_update_xmit_queue_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_update_xmit_queue_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the estimated number of bytes queued to transmit for this channel, and notify the scheduler. The estimate includes both the channel queue and the queue size reported by the lower layer, and an overhead estimate optionally provided by the lower layer. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_abf9310a1fa1a4d1cb1e3af383a98d902_icgraph.png" border="0" usemap="#channel_8h_abf9310a1fa1a4d1cb1e3af383a98d902_icgraph" alt=""/></div>
<map name="channel_8h_abf9310a1fa1a4d1cb1e3af383a98d902_icgraph" id="channel_8h_abf9310a1fa1a4d1cb1e3af383a98d902_icgraph">
<area shape="rect" id="node2" href="connection__or_8h.html#a8e6891862efd73402fed97a4353b2b24" title="connection_or_flushed_some" alt="" coords="199,13,389,39"/>
</map>
</div>

</div>
</div>
<a id="aeff1eebb5bba0a9371c5679994d51329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff1eebb5bba0a9371c5679994d51329">&#9670;&nbsp;</a></span>channel_when_created()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query created timestamp for a channel </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_aeff1eebb5bba0a9371c5679994d51329_icgraph.png" border="0" usemap="#channel_8h_aeff1eebb5bba0a9371c5679994d51329_icgraph" alt=""/></div>
<map name="channel_8h_aeff1eebb5bba0a9371c5679994d51329_icgraph" id="channel_8h_aeff1eebb5bba0a9371c5679994d51329_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#aa37fcbdaafeac83501c1699e61d8e128" title="channel_is_better" alt="" coords="208,5,332,32"/>
</map>
</div>

</div>
</div>
<a id="a886fbc84390a27e4007562e2e3ddacb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886fbc84390a27e4007562e2e3ddacb5">&#9670;&nbsp;</a></span>channel_when_last_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_last_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query last active timestamp for a channel </p>

</div>
</div>
<a id="a7c7c9bb52317ac2f0189a286108bdc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7c9bb52317ac2f0189a286108bdc7e">&#9670;&nbsp;</a></span>channel_when_last_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_last_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query client timestamp </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph.png" border="0" usemap="#channel_8h_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph" alt=""/></div>
<map name="channel_8h_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph" id="channel_8h_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph">
<area shape="rect" id="node2" href="connection__or_8h.html#a28d99e23c45ae40c245a0474ef4cfb98" title="connection_or_client_used" alt="" coords="224,5,400,32"/>
</map>
</div>

</div>
</div>
<a id="a04116ec19eadb75b7315366655023791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04116ec19eadb75b7315366655023791">&#9670;&nbsp;</a></span>channel_when_last_drained()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_last_drained </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query drained timestamp </p>

</div>
</div>
<a id="adcbc61adb34b9ce4351a0d5f68915e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbc61adb34b9ce4351a0d5f68915e52">&#9670;&nbsp;</a></span>channel_when_last_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_last_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query recv timestamp </p>

</div>
</div>
<a id="a3ce5cc93d2f7a10ad18300c4049108ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce5cc93d2f7a10ad18300c4049108ef">&#9670;&nbsp;</a></span>channel_when_last_xmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_last_xmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query xmit timestamp </p>

</div>
</div>
<a id="ab7dce1c4def06886d0a3e8f2aeb9d136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dce1c4def06886d0a3e8f2aeb9d136">&#9670;&nbsp;</a></span>channel_write_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_write_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a cell to a channel</p>
<p>Write a fixed-length cell to a channel using the write_cell() method. This is equivalent to the pre-channels <a class="el" href="connection__or_8c.html#a1a80590d68a6d8ea9b011ae44245929b">connection_or_write_cell_to_buf()</a>; it is called by the transport-independent code to deliver a cell to a channel for transmission. </p>

</div>
</div>
<a id="aeea0a09319d794c0f301f62fa5237512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea0a09319d794c0f301f62fa5237512">&#9670;&nbsp;</a></span>channel_write_packed_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_write_packed_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *&#160;</td>
          <td class="paramname"><em>packed_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a packed cell to a channel</p>
<p>Write a packed cell to a channel using the write_cell() method. This is called by the transport-independent code to deliver a packed cell to a channel for transmission. </p>

</div>
</div>
<a id="af328f72343802140f8e423a846721a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af328f72343802140f8e423a846721a6c">&#9670;&nbsp;</a></span>channel_write_var_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_write_var_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvar__cell__t.html">var_cell_t</a> *&#160;</td>
          <td class="paramname"><em>var_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a variable-length cell to a channel</p>
<p>Write a variable-length cell to a channel using the write_cell() method. This is equivalent to the pre-channels connection_or_write_var_cell_to_buf(); it's called by the transport- independent code to deliver a var_cell to a channel for transmission. </p>

</div>
</div>
<a id="aa036957ef1d90c086c403814da8de52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa036957ef1d90c086c403814da8de52f">&#9670;&nbsp;</a></span>packed_cell_is_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int packed_cell_is_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *&#160;</td>
          <td class="paramname"><em>packed_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> *&#160;</td>
          <td class="paramname"><em>circid_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <b>packed_cell</b> on <b>chan</b> is a destroy cell, then set *<b>circid_out</b> to its circuit ID, and return true. Otherwise, return false. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
