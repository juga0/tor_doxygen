<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: /home/user/_my/code/bwauth-related/tor/src/or/channel.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97b64286d42c5ef1697cb5f17129db19.html">tor</a></li><li class="navelem"><a class="el" href="dir_3cb0ba3f4b82dbe34a1a06276e96bc8d.html">src</a></li><li class="navelem"><a class="el" href="dir_386635fabd7f6c74e9d9c7a8604514a0.html">or</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">channel.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for <a class="el" href="channel_8c.html" title="OR/OP-to-OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ...">channel.c</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="or_8h_source.html">or.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="circuitmux_8h_source.html">circuitmux.h</a>&quot;</code><br />
<code>#include &quot;timers.h&quot;</code><br />
<code>#include &quot;<a class="el" href="handles_8h_source.html">handles.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for channel.h:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8h" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8h" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8h">
<area shape="rect" id="node2" href="or_8h.html" title="Master header file for Tor&#45;specific functionality. " alt="" coords="1063,184,1107,211"/>
<area shape="rect" id="node41" href="circuitmux_8h.html" title="Header file for circuitmux.c. " alt="" coords="2105,109,2199,136"/>
<area shape="rect" id="node42" href="timers_8h_source.html" title="timers.h" alt="" coords="2332,856,2401,883"/>
<area shape="rect" id="node43" href="handles_8h.html" title="Macros for C weak&#45;handle implementation. " alt="" coords="2197,184,2275,211"/>
<area shape="rect" id="node3" href="orconfig_8h_source.html" title="orconfig.h" alt="" coords="1743,1005,1822,1032"/>
<area shape="rect" id="node4" href="torint_8h.html" title="Header file to define uint32_t and friends. " alt="" coords="329,931,391,957"/>
<area shape="rect" id="node6" href="crypto_8h.html" title="Headers for crypto.c. " alt="" coords="1312,333,1381,360"/>
<area shape="rect" id="node20" href="container_8h_source.html" title="container.h" alt="" coords="601,557,687,584"/>
<area shape="rect" id="node22" href="torlog_8h.html" title="Headers for log.c. " alt="" coords="1782,557,1847,584"/>
<area shape="rect" id="node23" href="crypto__format_8h_source.html" title="crypto_format.h" alt="" coords="807,259,921,285"/>
<area shape="rect" id="node24" href="crypto__ed25519_8h_source.html" title="crypto_ed25519.h" alt="" coords="720,333,845,360"/>
<area shape="rect" id="node25" href="crypto__curve25519_8h_source.html" title="crypto_curve25519.h" alt="" coords="563,408,706,435"/>
<area shape="rect" id="node28" href="tortls_8h.html" title="Headers for tortls.c. " alt="" coords="1727,333,1790,360"/>
<area shape="rect" id="node31" href="compress_8h.html" title="Headers for compress.c. " alt="" coords="523,259,613,285"/>
<area shape="rect" id="node32" href="address_8h.html" title="Headers for address.h. " alt="" coords="534,483,613,509"/>
<area shape="rect" id="node33" href="compat__libevent_8h_source.html" title="compat_libevent.h" alt="" coords="2079,856,2207,883"/>
<area shape="rect" id="node34" href="ht_8h_source.html" title="ht.h" alt="" coords="739,259,783,285"/>
<area shape="rect" id="node35" href="confline_8h_source.html" title="confline.h" alt="" coords="899,333,978,360"/>
<area shape="rect" id="node36" href="replaycache_8h.html" title="Header file for replaycache.c. " alt="" coords="945,259,1047,285"/>
<area shape="rect" id="node37" href="tor__queue_8h_source.html" title="tor_queue.h" alt="" coords="2108,259,2199,285"/>
<area shape="rect" id="node38" href="token__bucket_8h_source.html" title="token_bucket.h" alt="" coords="569,856,679,883"/>
<area shape="rect" id="node39" href="util__format_8h_source.html" title="util_format.h" alt="" coords="398,856,493,883"/>
<area shape="rect" id="node40" href="hs__circuitmap_8h.html" title="Header file for hs_circuitmap.c. " alt="" coords="1173,259,1288,285"/>
<area shape="rect" id="node8" href="compat_8h_source.html" title="compat.h" alt="" coords="1493,781,1569,808"/>
<area shape="rect" id="node14" href="util_8h.html" title="Headers for util.c. " alt="" coords="953,632,1004,659"/>
<area shape="rect" id="node18" href="crypto__rsa_8h.html" title="Headers for crypto_rsa.c. " alt="" coords="1405,408,1499,435"/>
<area shape="rect" id="node9" href="testsupport_8h_source.html" title="testsupport.h" alt="" coords="1405,931,1504,957"/>
<area shape="rect" id="node11" href="compat__time_8h.html" title="Functions and types for monotonic times. " alt="" coords="1775,931,1883,957"/>
<area shape="rect" id="node13" href="compat__threads_8h_source.html" title="compat_threads.h" alt="" coords="1087,856,1214,883"/>
<area shape="rect" id="node15" href="di__ops_8h.html" title="Headers for di_ops.c. " alt="" coords="703,856,774,883"/>
<area shape="rect" id="node17" href="util__bug_8h.html" title="Macros to manage assertions, fatal and non&#45;fatal. " alt="" coords="993,707,1071,733"/>
<area shape="rect" id="node19" href="crypto__digest_8h.html" title="Headers for crypto_digest.c. " alt="" coords="347,483,458,509"/>
<area shape="rect" id="node21" href="siphash_8h_source.html" title="siphash.h" alt="" coords="605,632,683,659"/>
<area shape="rect" id="node26" href="crypto__openssl__mgt_8h_source.html" title="crypto_openssl_mgt.h" alt="" coords="833,483,983,509"/>
<area shape="rect" id="node29" href="compat__openssl_8h.html" title="compatibility definitions for working with different openssl forks " alt="" coords="1695,408,1823,435"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h__dep__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8hdep" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8hdep" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8hdep">
<area shape="rect" id="node2" href="channel_8c.html" title="OR/OP&#45;to&#45;OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ..." alt="" coords="1924,213,2072,269"/>
<area shape="rect" id="node3" href="channeltls_8h.html" title="Header file for channeltls.c. " alt="" coords="1180,109,1328,165"/>
<area shape="rect" id="node4" href="channeltls_8c.html" title="A concrete subclass of channel_t using or_connection_t to transfer cells between Tor instances..." alt="" coords="693,213,841,269"/>
<area shape="rect" id="node5" href="connection_8c.html" title="General high&#45;level functions to handle reading and writing on connections. " alt="" coords="1408,213,1556,269"/>
<area shape="rect" id="node6" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. " alt="" coords="866,213,1021,269"/>
<area shape="rect" id="node7" href="control_8c.html" title="Implementation for Tor&#39;s control&#45;socket interface. " alt="" coords="521,213,669,269"/>
<area shape="rect" id="node8" href="dirserv_8c.html" title="Directory server core implementation. Manages directory contents and generates directories. " alt="" coords="349,213,497,269"/>
<area shape="rect" id="node9" href="hibernate_8c.html" title="Functions to close listeners, stop allowing new circuits, etc in preparation for closing down or goin..." alt="" coords="1580,213,1728,269"/>
<area shape="rect" id="node10" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop..." alt="" coords="1236,213,1384,269"/>
<area shape="rect" id="node13" href="scheduler_8h.html" title="Header file for scheduler*.c. " alt="" coords="1505,109,1653,165"/>
<area shape="rect" id="node14" href="config_8c.html" title="Code to interpret the user&#39;s configuration of Tor. " alt="" coords="2096,213,2244,269"/>
<area shape="rect" id="node15" href="networkstatus_8c.html" title="Functions and structures for handling networkstatus documents as a client or as a directory cache..." alt="" coords="2268,213,2424,269"/>
<area shape="rect" id="node16" href="relay_8c.html" title="Handle relay cell encryption/decryption, plus packaging and receiving from circuits, plus queuing on circuits. " alt="" coords="2448,213,2596,269"/>
<area shape="rect" id="node17" href="command_8h.html" title="Header file for command.c. " alt="" coords="580,109,728,165"/>
<area shape="rect" id="node18" href="circuitbuild_8c.html" title="Implements the details of building circuits (by chosing paths, constructing/sending create/extend cel..." alt="" coords="5,213,153,269"/>
<area shape="rect" id="node19" href="command_8c.html" title="Functions for processing incoming cells. " alt="" coords="177,213,325,269"/>
<area shape="rect" id="node20" href="circpathbias_8c.html" title="Code to track success/failure rates of circuits built through different tor nodes, in an attempt to detect attacks where an attacker deliberately causes circuits to fail until the client choses a path they like. " alt="" coords="1881,109,2029,165"/>
<area shape="rect" id="node21" href="circuitlist_8c.html" title="Manage global structures that list and index circuits, and look up circuits within them..." alt="" coords="2053,109,2201,165"/>
<area shape="rect" id="node22" href="circuitmux_8c.html" title="Circuit mux/cell selection abstraction. " alt="" coords="2225,109,2373,165"/>
<area shape="rect" id="node23" href="circuituse_8c.html" title="Launch the right sort of circuits and attach the right streams to them. " alt="" coords="2397,109,2545,165"/>
<area shape="rect" id="node24" href="connection__edge_8c.html" title="Handle edge streams. " alt="" coords="2569,109,2741,165"/>
<area shape="rect" id="node25" href="cpuworker_8c.html" title="Uses the workqueue/threadpool code to farm CPU&#45;intensive activities out to subprocesses. " alt="" coords="2765,109,2913,165"/>
<area shape="rect" id="node26" href="entrynodes_8c.html" title="Code to manage our fixed first nodes for various functions. " alt="" coords="2937,109,3085,165"/>
<area shape="rect" id="node27" href="rendmid_8c.html" title="Implement introductions points and rendezvous points. " alt="" coords="3109,109,3257,165"/>
<area shape="rect" id="node11" href="scheduler_8c.html" title="Channel scheduling system: decides which channels should send and receive when. " alt="" coords="1752,213,1900,269"/>
<area shape="rect" id="node12" href="test__hs__client_8c.html" title="Test prop224 HS client functionality. " alt="" coords="1045,213,1212,269"/>
</map>
</div>
</div>
<p><a href="channel_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchannel__s.html">channel_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchannel__listener__s.html">channel_listener_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae4760e2e664fa4991dab88c3bdbad792"><td class="memItemLeft" align="right" valign="top"><a id="ae4760e2e664fa4991dab88c3bdbad792"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GRD_FLAG_ORIGINAL</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ae4760e2e664fa4991dab88c3bdbad792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecacbb75983d4165d1165f9774bf4ad"><td class="memItemLeft" align="right" valign="top"><a id="aaecacbb75983d4165d1165f9774bf4ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GRD_FLAG_ADDR_ONLY</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aaecacbb75983d4165d1165f9774bf4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28abebb6c5d89a4b9c0d150e0a9caac0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_CLOSED</b>(chan)</td></tr>
<tr class="separator:a28abebb6c5d89a4b9c0d150e0a9caac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6cdc5661f051c45f7aeb36d6d00a94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_OPENING</b>(chan)</td></tr>
<tr class="separator:a3d6cdc5661f051c45f7aeb36d6d00a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad144fc71cf2d9f27cdfb0d49cb57d816"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_OPEN</b>(chan)</td></tr>
<tr class="separator:ad144fc71cf2d9f27cdfb0d49cb57d816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8606f53d3d0e710fbc2ba63ae274df2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_MAINT</b>(chan)</td></tr>
<tr class="separator:ab8606f53d3d0e710fbc2ba63ae274df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9958211f3b4e0531e259c147ef602993"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_CLOSING</b>(chan)</td></tr>
<tr class="separator:a9958211f3b4e0531e259c147ef602993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8df712558f5f955701d0d5db99ffe78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_IS_ERROR</b>(chan)</td></tr>
<tr class="separator:ac8df712558f5f955701d0d5db99ffe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600d56dd2c6f29545f5bb80bfab7d446"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_FINISHED</b>(chan)</td></tr>
<tr class="separator:a600d56dd2c6f29545f5bb80bfab7d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23464e5f02f6b1a57ec4c0a2c7234243"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_CONDEMNED</b>(chan)</td></tr>
<tr class="separator:a23464e5f02f6b1a57ec4c0a2c7234243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f58e35a9f96bd9c180d6789d36f909d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_CAN_HANDLE_CELLS</b>(chan)</td></tr>
<tr class="separator:a9f58e35a9f96bd9c180d6789d36f909d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c7c6058511e654a9cbd51679293d40"><td class="memItemLeft" align="right" valign="top"><a id="ae6c7c6058511e654a9cbd51679293d40"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>channel_handle_free</b>(h)&#160;&#160;&#160;FREE_AND_NULL(channel_handle_t, channel_handle_free_, (h))</td></tr>
<tr class="separator:ae6c7c6058511e654a9cbd51679293d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a34c67bf8947c017f17e2866670c30542"><td class="memItemLeft" align="right" valign="top"><a id="a34c67bf8947c017f17e2866670c30542"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>channel_listener_fn_ptr</b>) (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *, <a class="el" href="structchannel__s.html">channel_t</a> *)</td></tr>
<tr class="separator:a34c67bf8947c017f17e2866670c30542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b94b2e3038d9cef5a49338f20cb0879"><td class="memItemLeft" align="right" valign="top"><a id="a9b94b2e3038d9cef5a49338f20cb0879"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>channel_cell_handler_fn_ptr</b>) (<a class="el" href="structchannel__s.html">channel_t</a> *, <a class="el" href="structcell__t.html">cell_t</a> *)</td></tr>
<tr class="separator:a9b94b2e3038d9cef5a49338f20cb0879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9e94f0afdd026831426b258f8a38e"><td class="memItemLeft" align="right" valign="top"><a id="a62a9e94f0afdd026831426b258f8a38e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>channel_var_cell_handler_fn_ptr</b>) (<a class="el" href="structchannel__s.html">channel_t</a> *, <a class="el" href="structvar__cell__t.html">var_cell_t</a> *)</td></tr>
<tr class="separator:a62a9e94f0afdd026831426b258f8a38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7934ac4184582961e1f61cd0241f408a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a7934ac4184582961e1f61cd0241f408a">channel_usage_info_t</a> { <b>CHANNEL_USED_NOT_USED_FOR_FULL_CIRCS</b> = 0, 
<b>CHANNEL_USED_FOR_FULL_CIRCS</b>, 
<b>CHANNEL_USED_FOR_USER_TRAFFIC</b>
 }</td></tr>
<tr class="separator:a7934ac4184582961e1f61cd0241f408a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a48de40019cd073a6bc571c0ffcf55b51"><td class="memItemLeft" align="right" valign="top"><a id="a48de40019cd073a6bc571c0ffcf55b51"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>channel_state_is_valid</b> (channel_state_t state)</td></tr>
<tr class="separator:a48de40019cd073a6bc571c0ffcf55b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdf98e720a6acc2e476e681e91e4fde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a5bdf98e720a6acc2e476e681e91e4fde">channel_listener_state_is_valid</a> (channel_listener_state_t state)</td></tr>
<tr class="separator:a5bdf98e720a6acc2e476e681e91e4fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727f5f4b03dca7d9b0ef71842709c055"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a727f5f4b03dca7d9b0ef71842709c055">channel_state_can_transition</a> (channel_state_t from, channel_state_t to)</td></tr>
<tr class="separator:a727f5f4b03dca7d9b0ef71842709c055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447edc0876c6c437ae72b5c49b8e038a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a447edc0876c6c437ae72b5c49b8e038a">channel_listener_state_can_transition</a> (channel_listener_state_t from, channel_listener_state_t to)</td></tr>
<tr class="separator:a447edc0876c6c437ae72b5c49b8e038a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5368fc8c3c7f7b0ce1020927961c92a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ac5368fc8c3c7f7b0ce1020927961c92a">channel_state_to_string</a> (channel_state_t state)</td></tr>
<tr class="separator:ac5368fc8c3c7f7b0ce1020927961c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0cac4ba2733cffddc9ff59be701687"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aee0cac4ba2733cffddc9ff59be701687">channel_listener_state_to_string</a> (channel_listener_state_t state)</td></tr>
<tr class="separator:aee0cac4ba2733cffddc9ff59be701687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c51ad12ff89e0f63cc386ccda8493f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ac5c51ad12ff89e0f63cc386ccda8493f">channel_mark_for_close</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ac5c51ad12ff89e0f63cc386ccda8493f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea762ac9b96570c55daa5dd57c95eafa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aea762ac9b96570c55daa5dd57c95eafa">channel_write_packed_cell</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *cell)</td></tr>
<tr class="separator:aea762ac9b96570c55daa5dd57c95eafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d328d0eebd17c646ec3a1ff4442d827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a4d328d0eebd17c646ec3a1ff4442d827">channel_listener_mark_for_close</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a4d328d0eebd17c646ec3a1ff4442d827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed86da67099b40c8eea25752b2260da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a7ed86da67099b40c8eea25752b2260da">channel_listener_set_listener_fn</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan, channel_listener_fn_ptr listener)</td></tr>
<tr class="separator:a7ed86da67099b40c8eea25752b2260da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3b8c3a3d91967c63fea496d2fe1b2e"><td class="memItemLeft" align="right" valign="top">channel_cell_handler_fn_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a9f3b8c3a3d91967c63fea496d2fe1b2e">channel_get_cell_handler</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a9f3b8c3a3d91967c63fea496d2fe1b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee619f7637f1a10fec2da20ea004e998"><td class="memItemLeft" align="right" valign="top">channel_var_cell_handler_fn_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aee619f7637f1a10fec2da20ea004e998">channel_get_var_cell_handler</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:aee619f7637f1a10fec2da20ea004e998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c26cbf4843fb4609f3f0c1eee87498c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a5c26cbf4843fb4609f3f0c1eee87498c">channel_set_cell_handlers</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, channel_cell_handler_fn_ptr cell_handler, channel_var_cell_handler_fn_ptr var_cell_handler)</td></tr>
<tr class="separator:a5c26cbf4843fb4609f3f0c1eee87498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d874b0dd28680dd7f9661e2490d9091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a1d874b0dd28680dd7f9661e2490d9091">channel_run_cleanup</a> (void)</td></tr>
<tr class="separator:a1d874b0dd28680dd7f9661e2490d9091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7838364ded7b78a661a1f3f2f1c266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a3e7838364ded7b78a661a1f3f2f1c266">channel_listener_run_cleanup</a> (void)</td></tr>
<tr class="separator:a3e7838364ded7b78a661a1f3f2f1c266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d84e3ecc8f662ed2072a2104d0b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#adb2d84e3ecc8f662ed2072a2104d0b6b">channel_free_all</a> (void)</td></tr>
<tr class="separator:adb2d84e3ecc8f662ed2072a2104d0b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef365ba78cdfea35f694be31bfd6e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a1ef365ba78cdfea35f694be31bfd6e91">channel_dumpstats</a> (int severity)</td></tr>
<tr class="separator:a1ef365ba78cdfea35f694be31bfd6e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0519ba6c6b14de83e886ed42095fe68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68">channel_listener_dumpstats</a> (int severity)</td></tr>
<tr class="separator:ab0519ba6c6b14de83e886ed42095fe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e3e2de528821cdda969fba6de1e4f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a85e3e2de528821cdda969fba6de1e4f2">channel_send_destroy</a> (<a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> circ_id, <a class="el" href="structchannel__s.html">channel_t</a> *chan, int reason)</td></tr>
<tr class="separator:a85e3e2de528821cdda969fba6de1e4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4d2973b9efd25ea2ffd54761ac8960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ace4d2973b9efd25ea2ffd54761ac8960">channel_connect</a> (const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr, uint16_t port, const char *rsa_id_digest, const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *ed_id)</td></tr>
<tr class="separator:ace4d2973b9efd25ea2ffd54761ac8960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225a9a8dab25e6fa224525867d0a056e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a225a9a8dab25e6fa224525867d0a056e">channel_get_for_extend</a> (const char *rsa_id_digest, const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *ed_id, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *target_addr, const char **msg_out, int *launch_out)</td></tr>
<tr class="separator:a225a9a8dab25e6fa224525867d0a056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098e7f8cd053cab6477b2ff9dcbd7190"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a098e7f8cd053cab6477b2ff9dcbd7190">channel_is_better</a> (<a class="el" href="structchannel__s.html">channel_t</a> *a, <a class="el" href="structchannel__s.html">channel_t</a> *b)</td></tr>
<tr class="separator:a098e7f8cd053cab6477b2ff9dcbd7190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ce362c180c51c5018668bae7bb4f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a03ce362c180c51c5018668bae7bb4f24">channel_find_by_global_id</a> (uint64_t global_identifier)</td></tr>
<tr class="separator:a03ce362c180c51c5018668bae7bb4f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ab9bd6d990fc6d07b0c8842a3aee71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a04ab9bd6d990fc6d07b0c8842a3aee71">channel_find_by_remote_identity</a> (const char *rsa_id_digest, const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *ed_id)</td></tr>
<tr class="separator:a04ab9bd6d990fc6d07b0c8842a3aee71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb42fd943884ecec3e7a7469c4e52f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a1bb42fd943884ecec3e7a7469c4e52f3">channel_next_with_rsa_identity</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a1bb42fd943884ecec3e7a7469c4e52f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185d59ac3e69ab26d2b71804cb882993"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a185d59ac3e69ab26d2b71804cb882993">channel_describe_transport</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a185d59ac3e69ab26d2b71804cb882993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff871ec7cc89dc910ca360747497fb5a"><td class="memItemLeft" align="right" valign="top"><a id="aff871ec7cc89dc910ca360747497fb5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (void, channel_dump_statistics,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, int severity))</td></tr>
<tr class="separator:aff871ec7cc89dc910ca360747497fb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2704646dbc4d5113c2160fd9842f128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ae2704646dbc4d5113c2160fd9842f128">channel_dump_transport_statistics</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, int severity)</td></tr>
<tr class="separator:ae2704646dbc4d5113c2160fd9842f128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8608773117c50600ebe58ffc331b6b3e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a8608773117c50600ebe58ffc331b6b3e">channel_get_actual_remote_descr</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a8608773117c50600ebe58ffc331b6b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1c9c62855d488fa17eaa4c4dd3f6e5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a3c1c9c62855d488fa17eaa4c4dd3f6e5">channel_get_actual_remote_address</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a3c1c9c62855d488fa17eaa4c4dd3f6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88a42a45b25954d77fd2f4ad42097bc"><td class="memItemLeft" align="right" valign="top"><a id="af88a42a45b25954d77fd2f4ad42097bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (int, channel_get_addr_if_possible,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr_out))</td></tr>
<tr class="separator:af88a42a45b25954d77fd2f4ad42097bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a5bd1e17411b06028d4839ad6e6df"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a5a9a5bd1e17411b06028d4839ad6e6df">channel_get_canonical_remote_descr</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a5a9a5bd1e17411b06028d4839ad6e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02db0f9ae91b50323bd345a224d9d1d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a02db0f9ae91b50323bd345a224d9d1d8">channel_has_queued_writes</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a02db0f9ae91b50323bd345a224d9d1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118d357c7f7accb2f220b000f33ea714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a118d357c7f7accb2f220b000f33ea714">channel_is_bad_for_new_circs</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a118d357c7f7accb2f220b000f33ea714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b61336ba7b19572a83d335a6aad65f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a93b61336ba7b19572a83d335a6aad65f">channel_mark_bad_for_new_circs</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a93b61336ba7b19572a83d335a6aad65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58978b931d8b11d4673287e59f8d54bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a58978b931d8b11d4673287e59f8d54bc">channel_is_canonical</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a58978b931d8b11d4673287e59f8d54bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2175e5e47f323e17e518474e8210907f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a2175e5e47f323e17e518474e8210907f">channel_is_canonical_is_reliable</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a2175e5e47f323e17e518474e8210907f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e699a108ac50e3f7e356b336734a56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a94e699a108ac50e3f7e356b336734a56">channel_is_client</a> (const <a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a94e699a108ac50e3f7e356b336734a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7950c59a4fefcd76e3e3b327d86114f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ab7950c59a4fefcd76e3e3b327d86114f">channel_is_local</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ab7950c59a4fefcd76e3e3b327d86114f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94903f24f674c7a4dd95dd51e6b6b047"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a94903f24f674c7a4dd95dd51e6b6b047">channel_is_incoming</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a94903f24f674c7a4dd95dd51e6b6b047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150180857a5c09e9ab16095b6011fd06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a150180857a5c09e9ab16095b6011fd06">channel_is_outgoing</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a150180857a5c09e9ab16095b6011fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad8f3da9b53f2a239196da6a822420a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a3ad8f3da9b53f2a239196da6a822420a">channel_mark_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a3ad8f3da9b53f2a239196da6a822420a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9de3ab9c23adb8e2646a4767e7d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ae5c9de3ab9c23adb8e2646a4767e7d37">channel_clear_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ae5c9de3ab9c23adb8e2646a4767e7d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb4f4e8f649a753d3d22fb84653c05b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a6cb4f4e8f649a753d3d22fb84653c05b">channel_matches_extend_info</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structextend__info__t.html">extend_info_t</a> *extend_info)</td></tr>
<tr class="separator:a6cb4f4e8f649a753d3d22fb84653c05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9744cd45d925184288dc3751fc1d455"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ae9744cd45d925184288dc3751fc1d455">channel_matches_target_addr_for_extend</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *target)</td></tr>
<tr class="separator:ae9744cd45d925184288dc3751fc1d455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae541683374c3002a6218c576c9775910"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#ae541683374c3002a6218c576c9775910">channel_num_circuits</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ae541683374c3002a6218c576c9775910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2028e29817fcb43096dde3a1dc6a61e9"><td class="memItemLeft" align="right" valign="top"><a id="a2028e29817fcb43096dde3a1dc6a61e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (void, channel_set_circid_type,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structcrypto__pk__t.html">crypto_pk_t</a> *identity_rcvd, int consider_identity))</td></tr>
<tr class="separator:a2028e29817fcb43096dde3a1dc6a61e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cdde3933fc1ca5c83494d1fb0e684f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a20cdde3933fc1ca5c83494d1fb0e684f">channel_timestamp_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a20cdde3933fc1ca5c83494d1fb0e684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0104c379fab8d5cf7dc3eddf113dc44e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a0104c379fab8d5cf7dc3eddf113dc44e">channel_listener_describe_transport</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a0104c379fab8d5cf7dc3eddf113dc44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e2ae335dbe5af256b18df4f3c1070e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e">channel_listener_dump_statistics</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l, int severity)</td></tr>
<tr class="separator:a31e2ae335dbe5af256b18df4f3c1070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8193e4c4351e724edc8ecaddd09f8e10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a8193e4c4351e724edc8ecaddd09f8e10">channel_listener_dump_transport_statistics</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l, int severity)</td></tr>
<tr class="separator:a8193e4c4351e724edc8ecaddd09f8e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea19d2f4cb7ba545fffa00bf86b6559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a4ea19d2f4cb7ba545fffa00bf86b6559">channel_check_for_duplicates</a> (void)</td></tr>
<tr class="separator:a4ea19d2f4cb7ba545fffa00bf86b6559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4bd42593d0df3646e947bf4661648f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a1e4bd42593d0df3646e947bf4661648f">channel_update_bad_for_new_circs</a> (const char *digest, int force)</td></tr>
<tr class="separator:a1e4bd42593d0df3646e947bf4661648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbcbfef4049d88a2975b9cf4ca71645"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#abcbcbfef4049d88a2975b9cf4ca71645">channel_num_cells_writeable</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:abcbcbfef4049d88a2975b9cf4ca71645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff1eebb5bba0a9371c5679994d51329"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aeff1eebb5bba0a9371c5679994d51329">channel_when_created</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:aeff1eebb5bba0a9371c5679994d51329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c9bb52317ac2f0189a286108bdc7e"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a7c7c9bb52317ac2f0189a286108bdc7e">channel_when_last_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a7c7c9bb52317ac2f0189a286108bdc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce5cc93d2f7a10ad18300c4049108ef"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#a3ce5cc93d2f7a10ad18300c4049108ef">channel_when_last_xmit</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a3ce5cc93d2f7a10ad18300c4049108ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa036957ef1d90c086c403814da8de52f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8h.html#aa036957ef1d90c086c403814da8de52f">packed_cell_is_destroy</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, const <a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *packed_cell, <a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> *circid_out)</td></tr>
<tr class="separator:aa036957ef1d90c086c403814da8de52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for <a class="el" href="channel_8c.html" title="OR/OP-to-OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ...">channel.c</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9f58e35a9f96bd9c180d6789d36f909d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f58e35a9f96bd9c180d6789d36f909d">&#9670;&nbsp;</a></span>CHANNEL_CAN_HANDLE_CELLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_CAN_HANDLE_CELLS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(CHANNEL_IS_OPENING(chan) || \</div><div class="line">                                        CHANNEL_IS_OPEN(chan) || \</div><div class="line">                                        CHANNEL_IS_MAINT(chan))</div></div><!-- fragment -->
</div>
</div>
<a id="a23464e5f02f6b1a57ec4c0a2c7234243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23464e5f02f6b1a57ec4c0a2c7234243">&#9670;&nbsp;</a></span>CHANNEL_CONDEMNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_CONDEMNED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(CHANNEL_IS_CLOSING(chan) || \</div><div class="line">                                 CHANNEL_FINISHED(chan))</div></div><!-- fragment -->
</div>
</div>
<a id="a600d56dd2c6f29545f5bb80bfab7d446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600d56dd2c6f29545f5bb80bfab7d446">&#9670;&nbsp;</a></span>CHANNEL_FINISHED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_FINISHED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(CHANNEL_IS_CLOSED(chan) || \</div><div class="line">                                CHANNEL_IS_ERROR(chan))</div></div><!-- fragment -->
</div>
</div>
<a id="a28abebb6c5d89a4b9c0d150e0a9caac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28abebb6c5d89a4b9c0d150e0a9caac0">&#9670;&nbsp;</a></span>CHANNEL_IS_CLOSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_CLOSED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                 CHANNEL_STATE_CLOSED))</div></div><!-- fragment -->
</div>
</div>
<a id="a9958211f3b4e0531e259c147ef602993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9958211f3b4e0531e259c147ef602993">&#9670;&nbsp;</a></span>CHANNEL_IS_CLOSING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_CLOSING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                  CHANNEL_STATE_CLOSING))</div></div><!-- fragment -->
</div>
</div>
<a id="ac8df712558f5f955701d0d5db99ffe78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8df712558f5f955701d0d5db99ffe78">&#9670;&nbsp;</a></span>CHANNEL_IS_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                CHANNEL_STATE_ERROR))</div></div><!-- fragment -->
</div>
</div>
<a id="ab8606f53d3d0e710fbc2ba63ae274df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8606f53d3d0e710fbc2ba63ae274df2">&#9670;&nbsp;</a></span>CHANNEL_IS_MAINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_MAINT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                CHANNEL_STATE_MAINT))</div></div><!-- fragment -->
</div>
</div>
<a id="ad144fc71cf2d9f27cdfb0d49cb57d816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad144fc71cf2d9f27cdfb0d49cb57d816">&#9670;&nbsp;</a></span>CHANNEL_IS_OPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_OPEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                               CHANNEL_STATE_OPEN))</div></div><!-- fragment -->
</div>
</div>
<a id="a3d6cdc5661f051c45f7aeb36d6d00a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6cdc5661f051c45f7aeb36d6d00a94">&#9670;&nbsp;</a></span>CHANNEL_IS_OPENING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANNEL_IS_OPENING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chan</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(channel_is_in_state((chan), \</div><div class="line">                                  CHANNEL_STATE_OPENING))</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7934ac4184582961e1f61cd0241f408a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7934ac4184582961e1f61cd0241f408a">&#9670;&nbsp;</a></span>channel_usage_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="channel_8h.html#a7934ac4184582961e1f61cd0241f408a">channel_usage_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum is used by channelpadding to decide when to pad channels. Don't add values to it without updating the checks in channelpadding_decide_to_pad_channel(). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4ea19d2f4cb7ba545fffa00bf86b6559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea19d2f4cb7ba545fffa00bf86b6559">&#9670;&nbsp;</a></span>channel_check_for_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_check_for_duplicates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relays run this once an hour to look over our list of channels to other relays. It prints out some statistics if there are multiple connections to many relays.</p>
<p>This function is similar to connection_or_set_bad_connections(), and probably could be adapted to replace it, if it was modified to actually take action on any of these connections. </p>

</div>
</div>
<a id="ae5c9de3ab9c23adb8e2646a4767e7d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c9de3ab9c23adb8e2646a4767e7d37">&#9670;&nbsp;</a></span>channel_clear_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_clear_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the client flag.</p>
<p>Mark a channel as being <em>not</em> from a client. </p>

</div>
</div>
<a id="ace4d2973b9efd25ea2ffd54761ac8960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4d2973b9efd25ea2ffd54761ac8960">&#9670;&nbsp;</a></span>channel_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>ed_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect to a given addr/port/digest.</p>
<p>This sets up a new outgoing channel; in the future if multiple channel_t subclasses are available, this is where the selection policy should go. It may also be desirable to fold port into <a class="el" href="structtor__addr__t.html">tor_addr_t</a> or make a new type including a <a class="el" href="structtor__addr__t.html">tor_addr_t</a> and port, so we have a single abstract object encapsulating all the protocol details of how to contact an OR. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_ace4d2973b9efd25ea2ffd54761ac8960_cgraph.png" border="0" usemap="#channel_8h_ace4d2973b9efd25ea2ffd54761ac8960_cgraph" alt=""/></div>
<map name="channel_8h_ace4d2973b9efd25ea2ffd54761ac8960_cgraph" id="channel_8h_ace4d2973b9efd25ea2ffd54761ac8960_cgraph">
<area shape="rect" id="node2" href="channeltls_8c.html#a8178dc802e84ceb764d8d5803e8d9a6b" title="channel_tls_connect" alt="" coords="173,5,315,32"/>
</map>
</div>

</div>
</div>
<a id="a185d59ac3e69ab26d2b71804cb882993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185d59ac3e69ab26d2b71804cb882993">&#9670;&nbsp;</a></span>channel_describe_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_describe_transport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describe the transport subclass for a channel.</p>
<p>Invoke a method to get a string description of the lower-layer transport for this channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a185d59ac3e69ab26d2b71804cb882993_icgraph.png" border="0" usemap="#channel_8h_a185d59ac3e69ab26d2b71804cb882993_icgraph" alt=""/></div>
<map name="channel_8h_a185d59ac3e69ab26d2b71804cb882993_icgraph" id="channel_8h_a185d59ac3e69ab26d2b71804cb882993_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ab56dc7ecc8a31e8bfa4dc5281b72c21e" title="MOCK_IMPL" alt="" coords="235,5,335,32"/>
</map>
</div>

</div>
</div>
<a id="ae2704646dbc4d5113c2160fd9842f128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2704646dbc4d5113c2160fd9842f128">&#9670;&nbsp;</a></span>channel_dump_transport_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_dump_transport_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoke transport-specific stats dump for channel.</p>
<p>If there is a lower-layer statistics dump method, invoke it. </p>

</div>
</div>
<a id="a1ef365ba78cdfea35f694be31bfd6e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef365ba78cdfea35f694be31bfd6e91">&#9670;&nbsp;</a></span>channel_dumpstats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_dumpstats </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel statistics to the log.</p>
<p>This is called from dumpstats() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a> and spams the log with statistics on channels. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_cgraph.png" border="0" usemap="#channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_cgraph" alt=""/></div>
<map name="channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_cgraph" id="channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="188,5,249,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_icgraph.png" border="0" usemap="#channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_icgraph" alt=""/></div>
<map name="channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_icgraph" id="channel_8h_a1ef365ba78cdfea35f694be31bfd6e91_icgraph">
<area shape="rect" id="node2" href="fakechans_8h.html#a2cff55df4a9516484aba4c6302c9deda" title="scheduler_release_channel_mock" alt="" coords="188,5,407,32"/>
</map>
</div>

</div>
</div>
<a id="a03ce362c180c51c5018668bae7bb4f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ce362c180c51c5018668bae7bb4f24">&#9670;&nbsp;</a></span>channel_find_by_global_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_find_by_global_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>global_identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Channel lookups</p>
<p>Find channel by global ID.</p>
<p>This function searches for a channel by the global_identifier assigned at initialization time. This identifier is unique for the lifetime of the Tor process. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a03ce362c180c51c5018668bae7bb4f24_icgraph.png" border="0" usemap="#channel_8h_a03ce362c180c51c5018668bae7bb4f24_icgraph" alt=""/></div>
<map name="channel_8h_a03ce362c180c51c5018668bae7bb4f24_icgraph" id="channel_8h_a03ce362c180c51c5018668bae7bb4f24_icgraph">
<area shape="rect" id="node2" href="circuitmux_8h.html#a4a5fff70da3c5abf8e3ae7abd1aee1cc" title="circuitmux_set_policy" alt="" coords="228,5,376,32"/>
<area shape="rect" id="node3" href="circuitmux_8h.html#a1eefa6dc14786d08f7dcc6a9d33c11b2" title="circuitmux_clear_policy" alt="" coords="424,5,583,32"/>
</map>
</div>

</div>
</div>
<a id="a04ab9bd6d990fc6d07b0c8842a3aee71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ab9bd6d990fc6d07b0c8842a3aee71">&#9670;&nbsp;</a></span>channel_find_by_remote_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_find_by_remote_identity </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rsa_id_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>ed_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find channel by RSA/Ed25519 identity of of the remote endpoint.</p>
<p>This function looks up a channel by the digest of its remote endpoint's RSA identity key. If <b>ed_id</b> is provided and nonzero, only a channel matching the <b>ed_id</b> will be returned.</p>
<p>It's possible that more than one channel to a given endpoint exists. Use <a class="el" href="channel_8c.html#a1bb42fd943884ecec3e7a7469c4e52f3">channel_next_with_rsa_identity()</a> to walk the list of channels; make sure to test for Ed25519 identity match too (as appropriate) </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a04ab9bd6d990fc6d07b0c8842a3aee71_icgraph.png" border="0" usemap="#channel_8h_a04ab9bd6d990fc6d07b0c8842a3aee71_icgraph" alt=""/></div>
<map name="channel_8h_a04ab9bd6d990fc6d07b0c8842a3aee71_icgraph" id="channel_8h_a04ab9bd6d990fc6d07b0c8842a3aee71_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a225a9a8dab25e6fa224525867d0a056e" title="channel_get_for_extend" alt="" coords="216,13,376,39"/>
</map>
</div>

</div>
</div>
<a id="adb2d84e3ecc8f662ed2072a2104d0b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2d84e3ecc8f662ed2072a2104d0b6b">&#9670;&nbsp;</a></span>channel_free_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_free_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close all channels and free everything.</p>
<p>This gets called from <a class="el" href="main_8c.html#a3d840759318fbf94fb7009cc0fba5c5d">tor_free_all()</a> in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a> to clean up on exit. It will close all registered channels and free associated storage, then free the all_channels, active_channels, listening_channels and finished_channels lists and also channel_identity_map. </p>

</div>
</div>
<a id="a3c1c9c62855d488fa17eaa4c4dd3f6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1c9c62855d488fa17eaa4c4dd3f6e5">&#9670;&nbsp;</a></span>channel_get_actual_remote_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_get_actual_remote_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the text address of the remote endpoint.</p>
<p>Subsequent calls to channel_get_{actual,canonical}_remote_{address,descr} may invalidate the return value from this function. </p>

</div>
</div>
<a id="a8608773117c50600ebe58ffc331b6b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8608773117c50600ebe58ffc331b6b3e">&#9670;&nbsp;</a></span>channel_get_actual_remote_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_get_actual_remote_descr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return text description of the remote endpoint.</p>
<p>This function return a test provided by the lower layer of the remote endpoint for this channel; it should specify the actual address connected to/from.</p>
<p>Subsequent calls to channel_get_{actual,canonical}_remote_{address,descr} may invalidate the return value from this function. </p>

</div>
</div>
<a id="a5a9a5bd1e17411b06028d4839ad6e6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a5bd1e17411b06028d4839ad6e6df">&#9670;&nbsp;</a></span>channel_get_canonical_remote_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_get_canonical_remote_descr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return text description of the remote endpoint canonical address.</p>
<p>This function return a test provided by the lower layer of the remote endpoint for this channel; it should use the known canonical address for this OR's identity digest if possible.</p>
<p>Subsequent calls to channel_get_{actual,canonical}_remote_{address,descr} may invalidate the return value from this function. </p>

</div>
</div>
<a id="a9f3b8c3a3d91967c63fea496d2fe1b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3b8c3a3d91967c63fea496d2fe1b2e">&#9670;&nbsp;</a></span>channel_get_cell_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">channel_cell_handler_fn_ptr channel_get_cell_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the fixed-length cell handler for a channel.</p>
<p>This function gets the handler for incoming fixed-length cells installed on a channel. </p>

</div>
</div>
<a id="a225a9a8dab25e6fa224525867d0a056e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225a9a8dab25e6fa224525867d0a056e">&#9670;&nbsp;</a></span>channel_get_for_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_get_for_extend </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rsa_id_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>ed_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>target_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>msg_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>launch_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a channel to extend a circuit.</p>
<p>Pick a suitable channel to extend a circuit to given the desired digest the address we believe is correct for that digest; this tries to see if we already have one for the requested endpoint, but if there is no good channel, set *msg_out to a message describing the channel's state and our next action, and set *launch_out to a boolean indicated whether the caller should try to launch a new channel with <a class="el" href="channel_8c.html#a2de1eedac60a9f05dd621bc9b07909dd">channel_connect()</a>. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a225a9a8dab25e6fa224525867d0a056e_cgraph.png" border="0" usemap="#channel_8h_a225a9a8dab25e6fa224525867d0a056e_cgraph" alt=""/></div>
<map name="channel_8h_a225a9a8dab25e6fa224525867d0a056e_cgraph" id="channel_8h_a225a9a8dab25e6fa224525867d0a056e_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a04ab9bd6d990fc6d07b0c8842a3aee71" title="channel_find_by_remote\l_identity" alt="" coords="213,5,376,47"/>
<area shape="rect" id="node3" href="channel_8c.html#a1bb42fd943884ecec3e7a7469c4e52f3" title="channel_next_with_rsa\l_identity" alt="" coords="217,71,372,112"/>
<area shape="rect" id="node4" href="di__ops_8c.html#a473334ee93cca0aea10523321a444ea3" title="tor_memeq" alt="" coords="251,137,338,163"/>
</map>
</div>

</div>
</div>
<a id="aee619f7637f1a10fec2da20ea004e998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee619f7637f1a10fec2da20ea004e998">&#9670;&nbsp;</a></span>channel_get_var_cell_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">channel_var_cell_handler_fn_ptr channel_get_var_cell_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the variable-length cell handler for a channel.</p>
<p>This function gets the handler for incoming variable-length cells installed on a channel. </p>

</div>
</div>
<a id="a02db0f9ae91b50323bd345a224d9d1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02db0f9ae91b50323bd345a224d9d1d8">&#9670;&nbsp;</a></span>channel_has_queued_writes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_has_queued_writes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff the channel has any cells on the connection outbuf waiting to be sent onto the network. </p>

</div>
</div>
<a id="a118d357c7f7accb2f220b000f33ea714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118d357c7f7accb2f220b000f33ea714">&#9670;&nbsp;</a></span>channel_is_bad_for_new_circs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_bad_for_new_circs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the is_bad_for_new_circs flag.</p>
<p>This function returns the is_bad_for_new_circs flag of the specified channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a118d357c7f7accb2f220b000f33ea714_icgraph.png" border="0" usemap="#channel_8h_a118d357c7f7accb2f220b000f33ea714_icgraph" alt=""/></div>
<map name="channel_8h_a118d357c7f7accb2f220b000f33ea714_icgraph" id="channel_8h_a118d357c7f7accb2f220b000f33ea714_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a098e7f8cd053cab6477b2ff9dcbd7190" title="channel_is_better" alt="" coords="188,13,312,39"/>
</map>
</div>

</div>
</div>
<a id="a098e7f8cd053cab6477b2ff9dcbd7190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098e7f8cd053cab6477b2ff9dcbd7190">&#9670;&nbsp;</a></span>channel_is_better()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_better </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decide which of two channels to prefer for extending a circuit.</p>
<p>This function is called while extending a circuit and returns true iff a is 'better' than b. The most important criterion here is that a canonical channel is always better than a non-canonical one, but the number of circuits and the age are used as tie-breakers.</p>
<p>This is based on the former connection_or_is_better() of <a class="el" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. ">connection_or.c</a> </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a098e7f8cd053cab6477b2ff9dcbd7190_cgraph.png" border="0" usemap="#channel_8h_a098e7f8cd053cab6477b2ff9dcbd7190_cgraph" alt=""/></div>
<map name="channel_8h_a098e7f8cd053cab6477b2ff9dcbd7190_cgraph" id="channel_8h_a098e7f8cd053cab6477b2ff9dcbd7190_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a118d357c7f7accb2f220b000f33ea714" title="channel_is_bad_for\l_new_circs" alt="" coords="187,5,322,47"/>
<area shape="rect" id="node3" href="channel_8c.html#a58978b931d8b11d4673287e59f8d54bc" title="channel_is_canonical" alt="" coords="181,71,328,98"/>
<area shape="rect" id="node4" href="channel_8c.html#aeff1eebb5bba0a9371c5679994d51329" title="channel_when_created" alt="" coords="177,122,332,149"/>
<area shape="rect" id="node5" href="channel_8c.html#ae541683374c3002a6218c576c9775910" title="channel_num_circuits" alt="" coords="181,173,329,199"/>
</map>
</div>

</div>
</div>
<a id="a58978b931d8b11d4673287e59f8d54bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58978b931d8b11d4673287e59f8d54bc">&#9670;&nbsp;</a></span>channel_is_canonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_canonical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the canonical flag for a channel.</p>
<p>This returns the is_canonical for a channel; this flag is determined by the lower layer and can't be set in a transport-independent way. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a58978b931d8b11d4673287e59f8d54bc_icgraph.png" border="0" usemap="#channel_8h_a58978b931d8b11d4673287e59f8d54bc_icgraph" alt=""/></div>
<map name="channel_8h_a58978b931d8b11d4673287e59f8d54bc_icgraph" id="channel_8h_a58978b931d8b11d4673287e59f8d54bc_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a098e7f8cd053cab6477b2ff9dcbd7190" title="channel_is_better" alt="" coords="200,5,324,32"/>
</map>
</div>

</div>
</div>
<a id="a2175e5e47f323e17e518474e8210907f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2175e5e47f323e17e518474e8210907f">&#9670;&nbsp;</a></span>channel_is_canonical_is_reliable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_canonical_is_reliable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if the canonical flag is reliable.</p>
<p>This function asks if the lower layer thinks it's safe to trust the result of <a class="el" href="channel_8c.html#a58978b931d8b11d4673287e59f8d54bc">channel_is_canonical()</a>. </p>

</div>
</div>
<a id="a94e699a108ac50e3f7e356b336734a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e699a108ac50e3f7e356b336734a56">&#9670;&nbsp;</a></span>channel_is_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the client flag.</p>
<p>This returns the client flag of a channel, which will be set if command_process_create_cell() in <a class="el" href="command_8c.html" title="Functions for processing incoming cells. ">command.c</a> thinks this is a connection from a client. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a94e699a108ac50e3f7e356b336734a56_icgraph.png" border="0" usemap="#channel_8h_a94e699a108ac50e3f7e356b336734a56_icgraph" alt=""/></div>
<map name="channel_8h_a94e699a108ac50e3f7e356b336734a56_icgraph" id="channel_8h_a94e699a108ac50e3f7e356b336734a56_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#a4bb9524073333e156da271ca623a772d" title="channel_do_open_actions" alt="" coords="176,5,348,32"/>
</map>
</div>

</div>
</div>
<a id="a94903f24f674c7a4dd95dd51e6b6b047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94903f24f674c7a4dd95dd51e6b6b047">&#9670;&nbsp;</a></span>channel_is_incoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_incoming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test incoming flag.</p>
<p>This function gets the incoming flag; this is set when a listener spawns a channel. If this returns true the channel was remotely initiated. </p>

</div>
</div>
<a id="ab7950c59a4fefcd76e3e3b327d86114f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7950c59a4fefcd76e3e3b327d86114f">&#9670;&nbsp;</a></span>channel_is_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test local flag.</p>
<p>This function gets the local flag; the lower layer should set this when setting up the channel if is_local_addr() is true for all of the destinations it will communicate with on behalf of this channel. It's used to decide whether to declare the network reachable when seeing incoming traffic on the channel. </p>

</div>
</div>
<a id="a150180857a5c09e9ab16095b6011fd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150180857a5c09e9ab16095b6011fd06">&#9670;&nbsp;</a></span>channel_is_outgoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_outgoing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test outgoing flag.</p>
<p>This function gets the outgoing flag; this is the inverse of the incoming bit set when a listener spawns a channel. If this returns true the channel was locally initiated. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a150180857a5c09e9ab16095b6011fd06_icgraph.png" border="0" usemap="#channel_8h_a150180857a5c09e9ab16095b6011fd06_icgraph" alt=""/></div>
<map name="channel_8h_a150180857a5c09e9ab16095b6011fd06_icgraph" id="channel_8h_a150180857a5c09e9ab16095b6011fd06_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#a4bb9524073333e156da271ca623a772d" title="channel_do_open_actions" alt="" coords="193,5,365,32"/>
<area shape="rect" id="node3" href="channel_8c.html#ae9d6f1fad148b483bdb8d2443dab0718" title="MOCK_IMPL" alt="" coords="229,56,329,83"/>
</map>
</div>

</div>
</div>
<a id="a0104c379fab8d5cf7dc3eddf113dc44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0104c379fab8d5cf7dc3eddf113dc44e">&#9670;&nbsp;</a></span>channel_listener_describe_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_listener_describe_transport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describe the transport subclass for a channel listener.</p>
<p>Invoke a method to get a string description of the lower-layer transport for this channel listener. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph.png" border="0" usemap="#channel_8h_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph" alt=""/></div>
<map name="channel_8h_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph" id="channel_8h_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="225,5,380,47"/>
<area shape="rect" id="node3" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="428,13,612,39"/>
</map>
</div>

</div>
</div>
<a id="a31e2ae335dbe5af256b18df4f3c1070e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e2ae335dbe5af256b18df4f3c1070e">&#9670;&nbsp;</a></span>channel_listener_dump_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_dump_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel listener statistics.</p>
<p>Dump statistics for one channel listener to the log. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_cgraph.png" border="0" usemap="#channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_cgraph" alt=""/></div>
<map name="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_cgraph" id="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="263,5,325,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a0104c379fab8d5cf7dc3eddf113dc44e" title="channel_listener_describe\l_transport" alt="" coords="208,57,380,98"/>
<area shape="rect" id="node4" href="channel_8c.html#aee0cac4ba2733cffddc9ff59be701687" title="channel_listener_state\l_to_string" alt="" coords="218,122,370,163"/>
<area shape="rect" id="node5" href="channel_8c.html#a8193e4c4351e724edc8ecaddd09f8e10" title="channel_listener_dump\l_transport_statistics" alt="" coords="217,187,371,229"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_icgraph.png" border="0" usemap="#channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_icgraph" alt=""/></div>
<map name="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_icgraph" id="channel_8h_a31e2ae335dbe5af256b18df4f3c1070e_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="208,13,392,39"/>
</map>
</div>

</div>
</div>
<a id="a8193e4c4351e724edc8ecaddd09f8e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8193e4c4351e724edc8ecaddd09f8e10">&#9670;&nbsp;</a></span>channel_listener_dump_transport_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_dump_transport_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoke transport-specific stats dump for channel listener.</p>
<p>If there is a lower-layer statistics dump method, invoke it. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a8193e4c4351e724edc8ecaddd09f8e10_icgraph.png" border="0" usemap="#channel_8h_a8193e4c4351e724edc8ecaddd09f8e10_icgraph" alt=""/></div>
<map name="channel_8h_a8193e4c4351e724edc8ecaddd09f8e10_icgraph" id="channel_8h_a8193e4c4351e724edc8ecaddd09f8e10_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="208,5,363,47"/>
<area shape="rect" id="node3" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="411,13,595,39"/>
</map>
</div>

</div>
</div>
<a id="ab0519ba6c6b14de83e886ed42095fe68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0519ba6c6b14de83e886ed42095fe68">&#9670;&nbsp;</a></span>channel_listener_dumpstats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_dumpstats </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel listener statistics to the log.</p>
<p>This is called from dumpstats() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a> and spams the log with statistics on channel listeners. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_ab0519ba6c6b14de83e886ed42095fe68_cgraph.png" border="0" usemap="#channel_8h_ab0519ba6c6b14de83e886ed42095fe68_cgraph" alt=""/></div>
<map name="channel_8h_ab0519ba6c6b14de83e886ed42095fe68_cgraph" id="channel_8h_ab0519ba6c6b14de83e886ed42095fe68_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="495,5,557,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="237,57,392,98"/>
<area shape="rect" id="node4" href="channel_8c.html#a0104c379fab8d5cf7dc3eddf113dc44e" title="channel_listener_describe\l_transport" alt="" coords="440,57,612,98"/>
<area shape="rect" id="node5" href="channel_8c.html#aee0cac4ba2733cffddc9ff59be701687" title="channel_listener_state\l_to_string" alt="" coords="450,122,602,163"/>
<area shape="rect" id="node6" href="channel_8c.html#a8193e4c4351e724edc8ecaddd09f8e10" title="channel_listener_dump\l_transport_statistics" alt="" coords="449,187,603,229"/>
</map>
</div>

</div>
</div>
<a id="a4d328d0eebd17c646ec3a1ff4442d827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d328d0eebd17c646ec3a1ff4442d827">&#9670;&nbsp;</a></span>channel_listener_mark_for_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_mark_for_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel listener for closure.</p>
<p>This function tries to close a channel_listener_t; it will go into the CLOSING state, and eventually the lower layer should put it into the CLOSED or ERROR state. Then, <a class="el" href="channel_8c.html#a1d874b0dd28680dd7f9661e2490d9091">channel_run_cleanup()</a> will eventually free it. </p>

</div>
</div>
<a id="a3e7838364ded7b78a661a1f3f2f1c266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7838364ded7b78a661a1f3f2f1c266">&#9670;&nbsp;</a></span>channel_listener_run_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_run_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up channel listeners.</p>
<p>This gets called periodically from run_scheduled_events() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a>; it cleans up after closed channel listeners. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a3e7838364ded7b78a661a1f3f2f1c266_cgraph.png" border="0" usemap="#channel_8h_a3e7838364ded7b78a661a1f3f2f1c266_cgraph" alt=""/></div>
<map name="channel_8h_a3e7838364ded7b78a661a1f3f2f1c266_cgraph" id="channel_8h_a3e7838364ded7b78a661a1f3f2f1c266_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a2d954d609b0decab6e56e2ab7e2444f6" title="channel_listener_unregister" alt="" coords="195,13,375,39"/>
</map>
</div>

</div>
</div>
<a id="a7ed86da67099b40c8eea25752b2260da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed86da67099b40c8eea25752b2260da">&#9670;&nbsp;</a></span>channel_listener_set_listener_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_set_listener_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_listener_fn_ptr&#160;</td>
          <td class="paramname"><em>listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the listener for a channel listener.</p>
<p>This function sets the handler for new incoming channels on a channel listener. </p>

</div>
</div>
<a id="a447edc0876c6c437ae72b5c49b8e038a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447edc0876c6c437ae72b5c49b8e038a">&#9670;&nbsp;</a></span>channel_listener_state_can_transition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_listener_state_can_transition </td>
          <td>(</td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a channel listener state transition is valid.</p>
<p>This function takes two channel listener states and indicates whether a transition between them is permitted (see the state definitions and transition table in <a class="el" href="or_8h.html" title="Master header file for Tor-specific functionality. ">or.h</a> at the channel_listener_state_t typedef). </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a447edc0876c6c437ae72b5c49b8e038a_icgraph.png" border="0" usemap="#channel_8h_a447edc0876c6c437ae72b5c49b8e038a_icgraph" alt=""/></div>
<map name="channel_8h_a447edc0876c6c437ae72b5c49b8e038a_icgraph" id="channel_8h_a447edc0876c6c437ae72b5c49b8e038a_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ad0126606a15537e0647e81a9c2ca8b74" title="channel_listener_change\l_state" alt="" coords="205,5,371,47"/>
</map>
</div>

</div>
</div>
<a id="a5bdf98e720a6acc2e476e681e91e4fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdf98e720a6acc2e476e681e91e4fde">&#9670;&nbsp;</a></span>channel_listener_state_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_listener_state_is_valid </td>
          <td>(</td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a given channel listener state is valid. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a5bdf98e720a6acc2e476e681e91e4fde_icgraph.png" border="0" usemap="#channel_8h_a5bdf98e720a6acc2e476e681e91e4fde_icgraph" alt=""/></div>
<map name="channel_8h_a5bdf98e720a6acc2e476e681e91e4fde_icgraph" id="channel_8h_a5bdf98e720a6acc2e476e681e91e4fde_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ad0126606a15537e0647e81a9c2ca8b74" title="channel_listener_change\l_state" alt="" coords="205,5,371,47"/>
</map>
</div>

</div>
</div>
<a id="aee0cac4ba2733cffddc9ff59be701687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0cac4ba2733cffddc9ff59be701687">&#9670;&nbsp;</a></span>channel_listener_state_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_listener_state_to_string </td>
          <td>(</td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a human-readable description for a channel listener state. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_aee0cac4ba2733cffddc9ff59be701687_icgraph.png" border="0" usemap="#channel_8h_aee0cac4ba2733cffddc9ff59be701687_icgraph" alt=""/></div>
<map name="channel_8h_aee0cac4ba2733cffddc9ff59be701687_icgraph" id="channel_8h_aee0cac4ba2733cffddc9ff59be701687_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="205,5,360,47"/>
<area shape="rect" id="node3" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="408,13,592,39"/>
</map>
</div>

</div>
</div>
<a id="a93b61336ba7b19572a83d335a6aad65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b61336ba7b19572a83d335a6aad65f">&#9670;&nbsp;</a></span>channel_mark_bad_for_new_circs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_bad_for_new_circs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel as bad for new circuits.</p>
<p>Set the is_bad_for_new_circs_flag on chan. </p>

</div>
</div>
<a id="a3ad8f3da9b53f2a239196da6a822420a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad8f3da9b53f2a239196da6a822420a">&#9670;&nbsp;</a></span>channel_mark_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the client flag.</p>
<p>Mark a channel as being from a client. </p>

</div>
</div>
<a id="ac5c51ad12ff89e0f63cc386ccda8493f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c51ad12ff89e0f63cc386ccda8493f">&#9670;&nbsp;</a></span>channel_mark_for_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_for_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel for closure.</p>
<p>This function tries to close a channel_t; it will go into the CLOSING state, and eventually the lower layer should put it into the CLOSED or ERROR state. Then, <a class="el" href="channel_8c.html#a1d874b0dd28680dd7f9661e2490d9091">channel_run_cleanup()</a> will eventually free it. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_ac5c51ad12ff89e0f63cc386ccda8493f_icgraph.png" border="0" usemap="#channel_8h_ac5c51ad12ff89e0f63cc386ccda8493f_icgraph" alt=""/></div>
<map name="channel_8h_ac5c51ad12ff89e0f63cc386ccda8493f_icgraph" id="channel_8h_ac5c51ad12ff89e0f63cc386ccda8493f_icgraph">
<area shape="rect" id="node2" href="fakechans_8h.html#a2cff55df4a9516484aba4c6302c9deda" title="scheduler_release_channel_mock" alt="" coords="216,5,435,32"/>
</map>
</div>

</div>
</div>
<a id="a6cb4f4e8f649a753d3d22fb84653c05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb4f4e8f649a753d3d22fb84653c05b">&#9670;&nbsp;</a></span>channel_matches_extend_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_matches_extend_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structextend__info__t.html">extend_info_t</a> *&#160;</td>
          <td class="paramname"><em>extend_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a channel matches an <a class="el" href="structextend__info__t.html">extend_info_t</a>.</p>
<p>This function calls the lower layer and asks if this channel matches a given <a class="el" href="structextend__info__t.html">extend_info_t</a>. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph.png" border="0" usemap="#channel_8h_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph" alt=""/></div>
<map name="channel_8h_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph" id="channel_8h_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph">
<area shape="rect" id="node2" href="circuitlist_8h.html#aaef0c4aefe50f0432478e21e51814a34" title="circuit_get_all_pending\l_on_channel" alt="" coords="252,35,407,76"/>
<area shape="rect" id="node3" href="circuitlist_8h.html#aa797a036ce04a0d14f669e656ec62408" title="circuit_count_pending\l_on_channel" alt="" coords="462,5,610,47"/>
<area shape="rect" id="node4" href="entrynodes_8h.html#a0e486d12b1fae8b40a392567b676a083" title="entry_guard_chan_failed" alt="" coords="455,71,617,98"/>
</map>
</div>

</div>
</div>
<a id="ae9744cd45d925184288dc3751fc1d455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9744cd45d925184288dc3751fc1d455">&#9670;&nbsp;</a></span>channel_matches_target_addr_for_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_matches_target_addr_for_extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a channel matches a given target address; return true iff we do.</p>
<p>This function calls into the lower layer and asks if this channel thinks it matches a given target address for circuit extension purposes. </p>

</div>
</div>
<a id="a1bb42fd943884ecec3e7a7469c4e52f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb42fd943884ecec3e7a7469c4e52f3">&#9670;&nbsp;</a></span>channel_next_with_rsa_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_next_with_rsa_identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For things returned by channel_find_by_remote_digest(), walk the list. The RSA key will match for all returned elements; the Ed25519 key might not.</p>
<p>Get next channel with digest.</p>
<p>This function takes a channel and finds the next channel in the list with the same digest. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a1bb42fd943884ecec3e7a7469c4e52f3_icgraph.png" border="0" usemap="#channel_8h_a1bb42fd943884ecec3e7a7469c4e52f3_icgraph" alt=""/></div>
<map name="channel_8h_a1bb42fd943884ecec3e7a7469c4e52f3_icgraph" id="channel_8h_a1bb42fd943884ecec3e7a7469c4e52f3_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a225a9a8dab25e6fa224525867d0a056e" title="channel_get_for_extend" alt="" coords="208,13,368,39"/>
</map>
</div>

</div>
</div>
<a id="abcbcbfef4049d88a2975b9cf4ca71645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbcbfef4049d88a2975b9cf4ca71645">&#9670;&nbsp;</a></span>channel_num_cells_writeable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_num_cells_writeable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the number of writeable cells.</p>
<p>Ask the lower layer for an estimate of how many cells it can accept. </p>

</div>
</div>
<a id="ae541683374c3002a6218c576c9775910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae541683374c3002a6218c576c9775910">&#9670;&nbsp;</a></span>channel_num_circuits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int channel_num_circuits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of circuits used by a channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>Channel to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of circuits using this as n_chan or p_chan </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_ae541683374c3002a6218c576c9775910_icgraph.png" border="0" usemap="#channel_8h_ae541683374c3002a6218c576c9775910_icgraph" alt=""/></div>
<map name="channel_8h_ae541683374c3002a6218c576c9775910_icgraph" id="channel_8h_ae541683374c3002a6218c576c9775910_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a098e7f8cd053cab6477b2ff9dcbd7190" title="channel_is_better" alt="" coords="201,5,325,32"/>
<area shape="rect" id="node3" href="connection__or_8c.html#a91065ac60ede0c2ccdaf7d2ff4892d5d" title="MOCK_IMPL" alt="" coords="213,56,313,83"/>
</map>
</div>

</div>
</div>
<a id="a1d874b0dd28680dd7f9661e2490d9091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d874b0dd28680dd7f9661e2490d9091">&#9670;&nbsp;</a></span>channel_run_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_run_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up channels.</p>
<p>This gets called periodically from run_scheduled_events() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a>; it cleans up after closed channels. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a1d874b0dd28680dd7f9661e2490d9091_cgraph.png" border="0" usemap="#channel_8h_a1d874b0dd28680dd7f9661e2490d9091_cgraph" alt=""/></div>
<map name="channel_8h_a1d874b0dd28680dd7f9661e2490d9091_cgraph" id="channel_8h_a1d874b0dd28680dd7f9661e2490d9091_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a9bbc6210c258ddbc944e9f0d6d386b45" title="channel_unregister" alt="" coords="197,5,328,32"/>
</map>
</div>

</div>
</div>
<a id="a85e3e2de528821cdda969fba6de1e4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e3e2de528821cdda969fba6de1e4f2">&#9670;&nbsp;</a></span>channel_send_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_send_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a>&#160;</td>
          <td class="paramname"><em>circ_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send destroy cell on a channel.</p>
<p>Write a destroy cell with circ ID <b>circ_id</b> and reason <b>reason</b> onto channel <b>chan</b>. Don't perform range-checking on reason: we may want to propagate reasons from other cells. </p>

</div>
</div>
<a id="a5c26cbf4843fb4609f3f0c1eee87498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c26cbf4843fb4609f3f0c1eee87498c">&#9670;&nbsp;</a></span>channel_set_cell_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_set_cell_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_cell_handler_fn_ptr&#160;</td>
          <td class="paramname"><em>cell_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_var_cell_handler_fn_ptr&#160;</td>
          <td class="paramname"><em>var_cell_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set both cell handlers for a channel.</p>
<p>This function sets both the fixed-length and variable length cell handlers for a channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph.png" border="0" usemap="#channel_8h_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph" alt=""/></div>
<map name="channel_8h_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph" id="channel_8h_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph">
<area shape="rect" id="node2" href="command_8h.html#ad5d1278e8abe0ae9ca6ff9d04bed82f2" title="command_setup_channel" alt="" coords="228,5,399,32"/>
</map>
</div>

</div>
</div>
<a id="a727f5f4b03dca7d9b0ef71842709c055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727f5f4b03dca7d9b0ef71842709c055">&#9670;&nbsp;</a></span>channel_state_can_transition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_state_can_transition </td>
          <td>(</td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a channel state transition is valid.</p>
<p>This function takes two channel states and indicates whether a transition between them is permitted (see the state definitions and transition table in <a class="el" href="or_8h.html" title="Master header file for Tor-specific functionality. ">or.h</a> at the channel_state_t typedef). </p>

</div>
</div>
<a id="ac5368fc8c3c7f7b0ce1020927961c92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5368fc8c3c7f7b0ce1020927961c92a">&#9670;&nbsp;</a></span>channel_state_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_state_to_string </td>
          <td>(</td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a human-readable description for a channel state. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph.png" border="0" usemap="#channel_8h_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph" alt=""/></div>
<map name="channel_8h_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph" id="channel_8h_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ab56dc7ecc8a31e8bfa4dc5281b72c21e" title="MOCK_IMPL" alt="" coords="213,5,313,32"/>
</map>
</div>

</div>
</div>
<a id="a20cdde3933fc1ca5c83494d1fb0e684f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cdde3933fc1ca5c83494d1fb0e684f">&#9670;&nbsp;</a></span>channel_timestamp_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_timestamp_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update client timestamp.</p>
<p>This function is called by <a class="el" href="relay_8c.html" title="Handle relay cell encryption/decryption, plus packaging and receiving from circuits, plus queuing on circuits. ">relay.c</a> to timestamp a channel that appears to be used as a client. </p>

</div>
</div>
<a id="a1e4bd42593d0df3646e947bf4661648f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4bd42593d0df3646e947bf4661648f">&#9670;&nbsp;</a></span>channel_update_bad_for_new_circs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_update_bad_for_new_circs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Go through all the channels (or if <b>digest</b> is non-NULL, just the OR connections with that digest), and set the is_bad_for_new_circs flag based on the rules in connection_or_group_set_badness() (or just always set it if <b>force</b> is true). </p>

</div>
</div>
<a id="aeff1eebb5bba0a9371c5679994d51329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff1eebb5bba0a9371c5679994d51329">&#9670;&nbsp;</a></span>channel_when_created()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query created timestamp for a channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_aeff1eebb5bba0a9371c5679994d51329_icgraph.png" border="0" usemap="#channel_8h_aeff1eebb5bba0a9371c5679994d51329_icgraph" alt=""/></div>
<map name="channel_8h_aeff1eebb5bba0a9371c5679994d51329_icgraph" id="channel_8h_aeff1eebb5bba0a9371c5679994d51329_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a098e7f8cd053cab6477b2ff9dcbd7190" title="channel_is_better" alt="" coords="208,5,332,32"/>
</map>
</div>

</div>
</div>
<a id="a7c7c9bb52317ac2f0189a286108bdc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7c9bb52317ac2f0189a286108bdc7e">&#9670;&nbsp;</a></span>channel_when_last_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_last_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query client timestamp. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8h_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph.png" border="0" usemap="#channel_8h_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph" alt=""/></div>
<map name="channel_8h_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph" id="channel_8h_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph">
<area shape="rect" id="node2" href="connection__or_8h.html#a28d99e23c45ae40c245a0474ef4cfb98" title="connection_or_client_used" alt="" coords="224,5,400,32"/>
</map>
</div>

</div>
</div>
<a id="a3ce5cc93d2f7a10ad18300c4049108ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce5cc93d2f7a10ad18300c4049108ef">&#9670;&nbsp;</a></span>channel_when_last_xmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_last_xmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query xmit timestamp. </p>

</div>
</div>
<a id="aea762ac9b96570c55daa5dd57c95eafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea762ac9b96570c55daa5dd57c95eafa">&#9670;&nbsp;</a></span>channel_write_packed_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_write_packed_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a packed cell to a channel.</p>
<p>Write a packed cell to a channel using the write_cell() method. This is called by the transport-independent code to deliver a packed cell to a channel for transmission.</p>
<p>Return 0 on success else a negative value. In both cases, the caller should not access the cell anymore, it is freed both on success and error. </p>

</div>
</div>
<a id="aa036957ef1d90c086c403814da8de52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa036957ef1d90c086c403814da8de52f">&#9670;&nbsp;</a></span>packed_cell_is_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int packed_cell_is_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *&#160;</td>
          <td class="paramname"><em>packed_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> *&#160;</td>
          <td class="paramname"><em>circid_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <b>packed_cell</b> on <b>chan</b> is a destroy cell, then set *<b>circid_out</b> to its circuit ID, and return true. Otherwise, return false. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
