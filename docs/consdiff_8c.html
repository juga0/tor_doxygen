<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: /home/user/_my/code/bwauth-related/tor/src/or/consdiff.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_95039623eb1ebeaf46c028778b39de98.html">or</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">consdiff.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Consensus diff implementation, including both the generation and the application of diffs in a minimal ed format.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="or_8h_source.html">or.h</a>&quot;</code><br />
<code>#include &quot;consdiff.h&quot;</code><br />
<code>#include &quot;memarea.h&quot;</code><br />
<code>#include &quot;<a class="el" href="routerparse_8h_source.html">routerparse.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for consdiff.c:</div>
<div class="dyncontent">
<div class="center"><img src="consdiff_8c__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2consdiff_8c" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2consdiff_8c" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2consdiff_8c">
<area shape="rect" id="node2" href="or_8h.html" title="Master header file for Tor&#45;specific functionality. " alt="" coords="1594,184,1638,211"/>
<area shape="rect" id="node43" href="consdiff_8h_source.html" title="consdiff.h" alt="" coords="1615,109,1694,136"/>
<area shape="rect" id="node44" href="memarea_8h_source.html" title="memarea.h" alt="" coords="1718,109,1805,136"/>
<area shape="rect" id="node45" href="routerparse_8h.html" title="Header file for routerparse.c. " alt="" coords="1829,109,1928,136"/>
<area shape="rect" id="node3" href="orconfig_8h_source.html" title="orconfig.h" alt="" coords="805,1020,883,1047"/>
<area shape="rect" id="node4" href="torint_8h.html" title="Header file to define uint32_t and friends. " alt="" coords="1883,945,1946,972"/>
<area shape="rect" id="node6" href="crypto_8h.html" title="Headers for crypto.c. " alt="" coords="1783,333,1852,360"/>
<area shape="rect" id="node20" href="container_8h_source.html" title="container.h" alt="" coords="1490,572,1577,599"/>
<area shape="rect" id="node22" href="torlog_8h.html" title="Headers for log.c. " alt="" coords="459,572,525,599"/>
<area shape="rect" id="node25" href="crypto__format_8h_source.html" title="crypto_format.h" alt="" coords="1281,259,1394,285"/>
<area shape="rect" id="node26" href="crypto__ed25519_8h_source.html" title="crypto_ed25519.h" alt="" coords="1284,333,1409,360"/>
<area shape="rect" id="node27" href="crypto__curve25519_8h_source.html" title="crypto_curve25519.h" alt="" coords="1306,415,1449,442"/>
<area shape="rect" id="node30" href="tortls_8h.html" title="Headers for tortls.c. " alt="" coords="1041,333,1103,360"/>
<area shape="rect" id="node33" href="compress_8h.html" title="Headers for compress.c. " alt="" coords="1571,259,1661,285"/>
<area shape="rect" id="node34" href="address_8h.html" title="Headers for address.h. " alt="" coords="1313,497,1391,524"/>
<area shape="rect" id="node35" href="compat__libevent_8h_source.html" title="compat_libevent.h" alt="" coords="600,871,728,897"/>
<area shape="rect" id="node36" href="ht_8h_source.html" title="ht.h" alt="" coords="1787,259,1831,285"/>
<area shape="rect" id="node37" href="confline_8h_source.html" title="confline.h" alt="" coords="1451,333,1530,360"/>
<area shape="rect" id="node38" href="replaycache_8h.html" title="Header file for replaycache.c. " alt="" coords="1907,259,2010,285"/>
<area shape="rect" id="node39" href="tor__queue_8h_source.html" title="tor_queue.h" alt="" coords="2035,259,2125,285"/>
<area shape="rect" id="node40" href="token__bucket_8h_source.html" title="token_bucket.h" alt="" coords="1690,871,1801,897"/>
<area shape="rect" id="node41" href="util__format_8h_source.html" title="util_format.h" alt="" coords="1571,871,1666,897"/>
<area shape="rect" id="node42" href="hs__circuitmap_8h.html" title="Header file for hs_circuitmap.c. " alt="" coords="2404,259,2519,285"/>
<area shape="rect" id="node8" href="testsupport_8h_source.html" title="testsupport.h" alt="" coords="488,945,587,972"/>
<area shape="rect" id="node9" href="compat_8h_source.html" title="compat.h" alt="" coords="1057,796,1133,823"/>
<area shape="rect" id="node14" href="util_8h.html" title="Headers for util.c. " alt="" coords="992,647,1043,673"/>
<area shape="rect" id="node18" href="crypto__rsa_8h.html" title="Headers for crypto_rsa.c. " alt="" coords="1110,415,1205,442"/>
<area shape="rect" id="node23" href="keccak-tiny_8h_source.html" title="keccak&#45;tiny/keccak\l&#45;tiny.h" alt="" coords="2126,408,2261,449"/>
<area shape="rect" id="node11" href="compat__time_8h.html" title="Functions and types for monotonic times. " alt="" coords="915,945,1023,972"/>
<area shape="rect" id="node13" href="compat__threads_8h_source.html" title="compat_threads.h" alt="" coords="1102,871,1229,897"/>
<area shape="rect" id="node15" href="di__ops_8h.html" title="Headers for di_ops.c. " alt="" coords="905,871,975,897"/>
<area shape="rect" id="node17" href="util__bug_8h.html" title="Macros to manage assertions, fatal and non&#45;fatal. " alt="" coords="750,721,829,748"/>
<area shape="rect" id="node19" href="crypto__digest_8h.html" title="Headers for crypto_digest.c. " alt="" coords="1415,497,1526,524"/>
<area shape="rect" id="node21" href="siphash_8h_source.html" title="siphash.h" alt="" coords="1499,647,1578,673"/>
<area shape="rect" id="node28" href="crypto__openssl__mgt_8h_source.html" title="crypto_openssl_mgt.h" alt="" coords="881,497,1031,524"/>
<area shape="rect" id="node31" href="compat__openssl_8h.html" title="compatibility definitions for working with different openssl forks " alt="" coords="892,415,1020,442"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrouter__id__iterator__t.html">router_id_iterator_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a778c6f49a47ae8aa1aaf58799fe02632"><td class="memItemLeft" align="right" valign="top"><a id="a778c6f49a47ae8aa1aaf58799fe02632"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONSDIFF_PRIVATE</b></td></tr>
<tr class="separator:a778c6f49a47ae8aa1aaf58799fe02632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581334ee7c37c33485a41b0f19f04c35"><td class="memItemLeft" align="right" valign="top"><a id="a581334ee7c37c33485a41b0f19f04c35"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NOT_VALID_BASE64</b>&#160;&#160;&#160;255</td></tr>
<tr class="separator:a581334ee7c37c33485a41b0f19f04c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207fd5507206d307cd63f95374fcd00d"><td class="memItemLeft" align="right" valign="top"><a id="a207fd5507206d307cd63f95374fcd00d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X</b>&#160;&#160;&#160;NOT_VALID_BASE64</td></tr>
<tr class="separator:a207fd5507206d307cd63f95374fcd00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd69d9a67487cc45c38eb184c50538a"><td class="memItemLeft" align="right" valign="top"><a id="aecd69d9a67487cc45c38eb184c50538a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SP</b>&#160;&#160;&#160;NOT_VALID_BASE64</td></tr>
<tr class="separator:aecd69d9a67487cc45c38eb184c50538a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323d60150d94a9f5f599bb97726ac384"><td class="memItemLeft" align="right" valign="top"><a id="a323d60150d94a9f5f599bb97726ac384"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PAD</b>&#160;&#160;&#160;NOT_VALID_BASE64</td></tr>
<tr class="separator:a323d60150d94a9f5f599bb97726ac384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b110bd12c27d415b4c686c119d9d781"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a3b110bd12c27d415b4c686c119d9d781">ROUTER_ID_ITERATOR_INIT</a>&#160;&#160;&#160;{ { NULL, 0 }, { NULL, 0 } }</td></tr>
<tr class="separator:a3b110bd12c27d415b4c686c119d9d781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b7f0807b26eca755d5dd6fa263e1b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#af1b7f0807b26eca755d5dd6fa263e1b5">START_OF_SIGNATURES_SECTION</a>&#160;&#160;&#160;&quot;directory-signature &quot;</td></tr>
<tr class="separator:af1b7f0807b26eca755d5dd6fa263e1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02edf9d765ce01b1e784931f3926acae"><td class="memItemLeft" align="right" valign="top"><a id="a02edf9d765ce01b1e784931f3926acae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_LINE_COUNT</b>&#160;&#160;&#160;(10000)</td></tr>
<tr class="separator:a02edf9d765ce01b1e784931f3926acae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23903cb68b708b8dd56d8035e36f3597"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a23903cb68b708b8dd56d8035e36f3597">CONSENSUS_LINE_MAX_LEN</a>&#160;&#160;&#160;(1&lt;&lt;20)</td></tr>
<tr class="separator:a23903cb68b708b8dd56d8035e36f3597"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acb47b826381871e64738c0e0b4799406"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrouter__id__iterator__t.html">router_id_iterator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#acb47b826381871e64738c0e0b4799406">router_id_iterator_t</a></td></tr>
<tr class="separator:acb47b826381871e64738c0e0b4799406"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aedb26ab4096d0cbd46c879450b5724a2"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#aedb26ab4096d0cbd46c879450b5724a2">lines_eq</a> (const cdline_t *a, const cdline_t *b)</td></tr>
<tr class="separator:aedb26ab4096d0cbd46c879450b5724a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296b2ba2a51a5e86b31543dddb2721d3"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a296b2ba2a51a5e86b31543dddb2721d3">line_str_eq</a> (const cdline_t *a, const char *b)</td></tr>
<tr class="separator:a296b2ba2a51a5e86b31543dddb2721d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cbdd8439ee2d3727e6ed1b670d31e5"><td class="memItemLeft" align="right" valign="top">STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a16cbdd8439ee2d3727e6ed1b670d31e5">smartlist_add_linecpy</a> (<a class="el" href="structsmartlist__t.html">smartlist_t</a> *lst, <a class="el" href="structmemarea__t.html">memarea_t</a> *area, const char *s)</td></tr>
<tr class="separator:a16cbdd8439ee2d3727e6ed1b670d31e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad1bd2854dbda99120910f106726c07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#acad1bd2854dbda99120910f106726c07">MOCK_IMPL</a> (STATIC int, consensus_compute_digest,(const char *cons, consensus_digest_t *digest_out))</td></tr>
<tr class="separator:acad1bd2854dbda99120910f106726c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b81e4502db10522c1051647963be2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#af0b81e4502db10522c1051647963be2f">MOCK_IMPL</a> (STATIC int, consensus_compute_digest_as_signed,(const char *cons, consensus_digest_t *digest_out))</td></tr>
<tr class="separator:af0b81e4502db10522c1051647963be2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f06324bb1e886838ffb6995295cda0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a39f06324bb1e886838ffb6995295cda0">MOCK_IMPL</a> (STATIC int, consensus_digest_eq,(const uint8_t *d1, const uint8_t *d2))</td></tr>
<tr class="separator:a39f06324bb1e886838ffb6995295cda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9230afcb4352fead94a2e8341e971fdc"><td class="memItemLeft" align="right" valign="top">STATIC smartlist_slice_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a9230afcb4352fead94a2e8341e971fdc">smartlist_slice</a> (const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *list, int start, int end)</td></tr>
<tr class="separator:a9230afcb4352fead94a2e8341e971fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d34451f43f802b7a490a684af67830d"><td class="memItemLeft" align="right" valign="top">STATIC int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a5d34451f43f802b7a490a684af67830d">lcs_lengths</a> (const smartlist_slice_t *slice1, const smartlist_slice_t *slice2, int direction)</td></tr>
<tr class="separator:a5d34451f43f802b7a490a684af67830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450c29ea724a0271bfc227a157e24332"><td class="memItemLeft" align="right" valign="top">STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a450c29ea724a0271bfc227a157e24332">trim_slices</a> (smartlist_slice_t *slice1, smartlist_slice_t *slice2)</td></tr>
<tr class="separator:a450c29ea724a0271bfc227a157e24332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af131136ce4b0bdead45911f3426d28d0"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#af131136ce4b0bdead45911f3426d28d0">smartlist_slice_string_pos</a> (const smartlist_slice_t *slice, const cdline_t *string)</td></tr>
<tr class="separator:af131136ce4b0bdead45911f3426d28d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6293383be931683a9ccd524751c99cb1"><td class="memItemLeft" align="right" valign="top">STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a6293383be931683a9ccd524751c99cb1">set_changed</a> (bitarray_t *changed1, bitarray_t *changed2, const smartlist_slice_t *slice1, const smartlist_slice_t *slice2)</td></tr>
<tr class="separator:a6293383be931683a9ccd524751c99cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e600f2ec2f92de2a906ae8a73737a1"><td class="memItemLeft" align="right" valign="top">STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a93e600f2ec2f92de2a906ae8a73737a1">calc_changes</a> (smartlist_slice_t *slice1, smartlist_slice_t *slice2, bitarray_t *changed1, bitarray_t *changed2)</td></tr>
<tr class="separator:a93e600f2ec2f92de2a906ae8a73737a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea93027d581ed848a9225a951cfc96cb"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#aea93027d581ed848a9225a951cfc96cb">get_id_hash</a> (const cdline_t *line, cdline_t *hash_out)</td></tr>
<tr class="separator:aea93027d581ed848a9225a951cfc96cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba46559ed750532b53f83b29fd4569f0"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#aba46559ed750532b53f83b29fd4569f0">is_valid_router_entry</a> (const cdline_t *line)</td></tr>
<tr class="separator:aba46559ed750532b53f83b29fd4569f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea8373194d59b92419294611aa7c77b"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a8ea8373194d59b92419294611aa7c77b">next_router</a> (const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *cons, int cur)</td></tr>
<tr class="separator:a8ea8373194d59b92419294611aa7c77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a21fba70e780340e95c15fce46cb765"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a8a21fba70e780340e95c15fce46cb765">base64cmp</a> (const cdline_t *hash1, const cdline_t *hash2)</td></tr>
<tr class="separator:a8a21fba70e780340e95c15fce46cb765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0687383d619c3e157da44c9c43615c4"><td class="memItemLeft" align="right" valign="top">STATIC <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#ae0687383d619c3e157da44c9c43615c4">gen_ed_diff</a> (const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *cons1_orig, const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *cons2, <a class="el" href="structmemarea__t.html">memarea_t</a> *area)</td></tr>
<tr class="separator:ae0687383d619c3e157da44c9c43615c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7632812f17c85a551a7663711cf77dbd"><td class="memItemLeft" align="right" valign="top">STATIC <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a7632812f17c85a551a7663711cf77dbd">apply_ed_diff</a> (const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *cons1, const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *diff, int diff_starting_line)</td></tr>
<tr class="separator:a7632812f17c85a551a7663711cf77dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7705423da427c72ba7509701c5287e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#a7705423da427c72ba7509701c5287e81">consdiff_gen_diff</a> (const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *cons1, const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *cons2, const consensus_digest_t *digests1, const consensus_digest_t *digests2, <a class="el" href="structmemarea__t.html">memarea_t</a> *area)</td></tr>
<tr class="separator:a7705423da427c72ba7509701c5287e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4774743d3040ade43dea06eb121d82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#afc4774743d3040ade43dea06eb121d82">consdiff_get_digests</a> (const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *diff, char *digest1_out, char *digest2_out)</td></tr>
<tr class="separator:afc4774743d3040ade43dea06eb121d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f13c2103d9b38a05cdd327c7ab5009"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#ac6f13c2103d9b38a05cdd327c7ab5009">consdiff_apply_diff</a> (const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *cons1, const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *diff, const consensus_digest_t *digests1)</td></tr>
<tr class="separator:ac6f13c2103d9b38a05cdd327c7ab5009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ff16a6b550703e7a23bfc9a1f59867"><td class="memItemLeft" align="right" valign="top">STATIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#af1ff16a6b550703e7a23bfc9a1f59867">consensus_split_lines</a> (<a class="el" href="structsmartlist__t.html">smartlist_t</a> *out, const char *s, <a class="el" href="structmemarea__t.html">memarea_t</a> *area)</td></tr>
<tr class="separator:af1ff16a6b550703e7a23bfc9a1f59867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac771ef7ed5aa589e9a3ea3c48f2313f2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#ac771ef7ed5aa589e9a3ea3c48f2313f2">consensus_diff_generate</a> (const char *cons1, const char *cons2)</td></tr>
<tr class="separator:ac771ef7ed5aa589e9a3ea3c48f2313f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00c3918b44fa3e2f32ed7190281ed18"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#af00c3918b44fa3e2f32ed7190281ed18">consensus_diff_apply</a> (const char *consensus, const char *diff)</td></tr>
<tr class="separator:af00c3918b44fa3e2f32ed7190281ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee547e5b36f9a6e0d89d5f95980bdb55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="consdiff_8c.html#aee547e5b36f9a6e0d89d5f95980bdb55">looks_like_a_consensus_diff</a> (const char *document, size_t len)</td></tr>
<tr class="separator:aee547e5b36f9a6e0d89d5f95980bdb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Consensus diff implementation, including both the generation and the application of diffs in a minimal ed format. </p>
<p>The consensus diff application is done in consdiff_apply_diff, which relies on apply_ed_diff for the main ed diff part and on some digest helper functions to check the digest hashes found in the consensus diff header.</p>
<p>The consensus diff generation is more complex. consdiff_gen_diff generates it, relying on gen_ed_diff to generate the ed diff and some digest helper functions to generate the digest hashes.</p>
<p>gen_ed_diff is the tricky bit. In it simplest form, it will take quadratic time and linear space to generate an ed diff given two smartlists. As shown in its comment section, calling calc_changes on the entire two consensuses will calculate what is to be added and what is to be deleted in the diff. Its comment section briefly explains how it works.</p>
<p>In our case specific to consensuses, we take advantage of the fact that consensuses list routers sorted by their identities. We use that information to avoid running calc_changes on the whole smartlists. gen_ed_diff will navigate through the two consensuses identity by identity and will send small couples of slices to calc_changes, keeping the running time near-linear. This is explained in more detail in the gen_ed_diff comments.</p>
<p>The allocation strategy tries to save time and memory by avoiding needless copies. Instead of actually splitting the inputs into separate strings, we allocate cdline_t objects, each of which represents a line in the original object or in the output. We use <a class="el" href="structmemarea__t.html">memarea_t</a> allocators to manage the temporary memory we use when generating or applying diffs. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a23903cb68b708b8dd56d8035e36f3597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23903cb68b708b8dd56d8035e36f3597">&#9670;&nbsp;</a></span>CONSENSUS_LINE_MAX_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONSENSUS_LINE_MAX_LEN&#160;&#160;&#160;(1&lt;&lt;20)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Any consensus line longer than this means that the input is invalid. </p>

</div>
</div>
<a id="a3b110bd12c27d415b4c686c119d9d781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b110bd12c27d415b4c686c119d9d781">&#9670;&nbsp;</a></span>ROUTER_ID_ITERATOR_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ROUTER_ID_ITERATOR_INIT&#160;&#160;&#160;{ { NULL, 0 }, { NULL, 0 } }</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer for a <a class="el" href="structrouter__id__iterator__t.html">router_id_iterator_t</a>. </p>

</div>
</div>
<a id="af1b7f0807b26eca755d5dd6fa263e1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b7f0807b26eca755d5dd6fa263e1b5">&#9670;&nbsp;</a></span>START_OF_SIGNATURES_SECTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define START_OF_SIGNATURES_SECTION&#160;&#160;&#160;&quot;directory-signature &quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Line-prefix indicating the beginning of the signatures section that we intend to delete. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acb47b826381871e64738c0e0b4799406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb47b826381871e64738c0e0b4799406">&#9670;&nbsp;</a></span>router_id_iterator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrouter__id__iterator__t.html">router_id_iterator_t</a>  <a class="el" href="structrouter__id__iterator__t.html">router_id_iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Structure used to remember the previous and current identity hash of the "r " lines in a consensus, to enforce well-ordering. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7632812f17c85a551a7663711cf77dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7632812f17c85a551a7663711cf77dbd">&#9670;&nbsp;</a></span>apply_ed_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC <a class="el" href="structsmartlist__t.html">smartlist_t</a>* apply_ed_diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>cons1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>diff_starting_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the ed diff, starting at <b>diff_starting_line</b>, to the consensus and return a new consensus, also as a line-based smartlist. Will return NULL if the ed diff is not properly formatted.</p>
<p>All cdline_t objects in the resulting object are references to lines in one of the inputs; nothing is copied. </p>
<p>$ is not allowed with non-d actions. </p>

</div>
</div>
<a id="a8a21fba70e780340e95c15fce46cb765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a21fba70e780340e95c15fce46cb765">&#9670;&nbsp;</a></span>base64cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int base64cmp </td>
          <td>(</td>
          <td class="paramtype">const cdline_t *&#160;</td>
          <td class="paramname"><em>hash1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cdline_t *&#160;</td>
          <td class="paramname"><em>hash2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper: compare two base64-encoded identity hashes, which may be of different lengths. Comparison ends when the first non-base64 char is found. </p>

</div>
</div>
<a id="a93e600f2ec2f92de2a906ae8a73737a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e600f2ec2f92de2a906ae8a73737a1">&#9670;&nbsp;</a></span>calc_changes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC void calc_changes </td>
          <td>(</td>
          <td class="paramtype">smartlist_slice_t *&#160;</td>
          <td class="paramname"><em>slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smartlist_slice_t *&#160;</td>
          <td class="paramname"><em>slice2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitarray_t *&#160;</td>
          <td class="paramname"><em>changed1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitarray_t *&#160;</td>
          <td class="paramname"><em>changed2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper: Figure out what elements are new or gone on the second smartlist relative to the first smartlist, and store the booleans in the bitarrays. True on the first bitarray means the element is gone, true on the second bitarray means it's new.</p>
<p>In its base case, either of the smartlists is of length &lt;= 1 and we can quickly see what elements are new or are gone. In the other case, we will split one smartlist by half and we'll use optimal_column_to_split to find the optimal column at which to split the second smartlist so that we are finding the smallest diff possible. </p>

</div>
</div>
<a id="ac6f13c2103d9b38a05cdd327c7ab5009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f13c2103d9b38a05cdd327c7ab5009">&#9670;&nbsp;</a></span>consdiff_apply_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* consdiff_apply_diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>cons1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const consensus_digest_t *&#160;</td>
          <td class="paramname"><em>digests1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the consensus diff to the given consensus and return a new consensus, also as a line-based smartlist. Will return NULL if the diff could not be applied. Neither the consensus nor the diff are modified in any way, so it's up to the caller to free their resources. </p>

</div>
</div>
<a id="a7705423da427c72ba7509701c5287e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7705423da427c72ba7509701c5287e81">&#9670;&nbsp;</a></span>consdiff_gen_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsmartlist__t.html">smartlist_t</a>* consdiff_gen_diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>cons1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>cons2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const consensus_digest_t *&#160;</td>
          <td class="paramname"><em>digests1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const consensus_digest_t *&#160;</td>
          <td class="paramname"><em>digests2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmemarea__t.html">memarea_t</a> *&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a consensus diff as a smartlist from two given consensuses, also as smartlists. Will return NULL if the consensus diff could not be generated. Neither of the two consensuses are modified in any way, so it's up to the caller to free their resources. </p>

</div>
</div>
<a id="afc4774743d3040ade43dea06eb121d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4774743d3040ade43dea06eb121d82">&#9670;&nbsp;</a></span>consdiff_get_digests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int consdiff_get_digests </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>digest1_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>digest2_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetch the digest of the base consensus in the consensus diff, encoded in base16 as found in the diff itself. digest1_out and digest2_out must be of length DIGEST256_LEN or larger if not NULL. </p>

</div>
</div>
<a id="af00c3918b44fa3e2f32ed7190281ed18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00c3918b44fa3e2f32ed7190281ed18">&#9670;&nbsp;</a></span>consensus_diff_apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* consensus_diff_apply </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>consensus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a consensus document and a diff, try to apply the diff to the consensus. On success return a newly allocated string containing the new consensus. On failure, return NULL. </p>

</div>
</div>
<a id="ac771ef7ed5aa589e9a3ea3c48f2313f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac771ef7ed5aa589e9a3ea3c48f2313f2">&#9670;&nbsp;</a></span>consensus_diff_generate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* consensus_diff_generate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cons1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cons2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two consensus documents, try to compute a diff between them. On success, retun a newly allocated string containing that diff. On failure, return NULL. </p>

</div>
</div>
<a id="af1ff16a6b550703e7a23bfc9a1f59867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ff16a6b550703e7a23bfc9a1f59867">&#9670;&nbsp;</a></span>consensus_split_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int consensus_split_lines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmemarea__t.html">memarea_t</a> *&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper: For every NL-terminated line in <b>s</b>, add a cdline referring to that line (without trailing newline) to <b>out</b>. Return -1 if there are any non-NL terminated lines; 0 otherwise.</p>
<p>Unlike tor_split_lines, this function avoids ambiguity on its handling of a final line that isn't NL-terminated.</p>
<p>All cdline_t objects are allocated in the provided memarea. Strings are not copied: if <b>s</b> changes or becomes invalid, then all generated cdlines will become invalid. </p>

</div>
</div>
<a id="ae0687383d619c3e157da44c9c43615c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0687383d619c3e157da44c9c43615c4">&#9670;&nbsp;</a></span>gen_ed_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC <a class="el" href="structsmartlist__t.html">smartlist_t</a>* gen_ed_diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>cons1_orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>cons2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmemarea__t.html">memarea_t</a> *&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an ed diff as a smartlist from two consensuses, also given as smartlists. Will return NULL if the diff could not be generated, which can happen if any lines the script had to add matched "." or if the routers were not properly ordered.</p>
<p>All cdline_t objects in the resulting object are either references to lines in one of the inputs, or are newly allocated lines in the provided memarea.</p>
<p>This implementation is consensus-specific. To generate an ed diff for any given input in quadratic time, you can replace all the code until the navigation in reverse order with the following:</p>
<p>int len1 = smartlist_len(cons1); int len2 = smartlist_len(cons2); bitarray_t *changed1 = bitarray_init_zero(len1); bitarray_t *changed2 = bitarray_init_zero(len2); cons1_sl = smartlist_slice(cons1, 0, -1); cons2_sl = smartlist_slice(cons2, 0, -1); calc_changes(cons1_sl, cons2_sl, changed1, changed2); </p>

</div>
</div>
<a id="aea93027d581ed848a9225a951cfc96cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea93027d581ed848a9225a951cfc96cb">&#9670;&nbsp;</a></span>get_id_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int get_id_hash </td>
          <td>(</td>
          <td class="paramtype">const cdline_t *&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cdline_t *&#160;</td>
          <td class="paramname"><em>hash_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper: Get the identity hash from a router line, assuming that the line at least appears to be a router line and thus starts with "r ".</p>
<p>If an identity hash is found, store it (without decoding it) in <b>hash_out</b>, and return 0. On failure, return -1. </p>

</div>
</div>
<a id="aba46559ed750532b53f83b29fd4569f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba46559ed750532b53f83b29fd4569f0">&#9670;&nbsp;</a></span>is_valid_router_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int is_valid_router_entry </td>
          <td>(</td>
          <td class="paramtype">const cdline_t *&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper: Check that a line is a valid router entry. We must at least be able to fetch a proper identity hash from it for it to be valid. </p>

</div>
</div>
<a id="a5d34451f43f802b7a490a684af67830d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d34451f43f802b7a490a684af67830d">&#9670;&nbsp;</a></span>lcs_lengths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int* lcs_lengths </td>
          <td>(</td>
          <td class="paramtype">const smartlist_slice_t *&#160;</td>
          <td class="paramname"><em>slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const smartlist_slice_t *&#160;</td>
          <td class="paramname"><em>slice2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper: Compute the longest common subsequence lengths for the two slices. Used as part of the diff generation to find the column at which to split slice2 while still having the optimal solution. If direction is -1, the navigation is reversed. Otherwise it must be 1. The length of the resulting integer array is that of the second slice plus one. </p>

</div>
</div>
<a id="a296b2ba2a51a5e86b31543dddb2721d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296b2ba2a51a5e86b31543dddb2721d3">&#9670;&nbsp;</a></span>line_str_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int line_str_eq </td>
          <td>(</td>
          <td class="paramtype">const cdline_t *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff a has the same contents as the nul-terminated string b. </p>

</div>
</div>
<a id="aedb26ab4096d0cbd46c879450b5724a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb26ab4096d0cbd46c879450b5724a2">&#9670;&nbsp;</a></span>lines_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int lines_eq </td>
          <td>(</td>
          <td class="paramtype">const cdline_t *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cdline_t *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff a and b have the same contents. </p>

</div>
</div>
<a id="aee547e5b36f9a6e0d89d5f95980bdb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee547e5b36f9a6e0d89d5f95980bdb55">&#9670;&nbsp;</a></span>looks_like_a_consensus_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int looks_like_a_consensus_diff </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>document</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff, based on its header, <b>document</b> is likely to be a consensus diff. </p>

</div>
</div>
<a id="acad1bd2854dbda99120910f106726c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad1bd2854dbda99120910f106726c07">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">STATIC&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">consensus_compute_digest&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(const char *cons, consensus_digest_t *digest_out)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the digest of <b>cons</b>, and store the result in <b>digest_out</b>. Return 0 on success, -1 on failure. </p>

</div>
</div>
<a id="af0b81e4502db10522c1051647963be2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b81e4502db10522c1051647963be2f">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">STATIC&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">consensus_compute_digest_as_signed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(const char *cons, consensus_digest_t *digest_out)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the digest-as-signed of <b>cons</b>, and store the result in <b>digest_out</b>. Return 0 on success, -1 on failure. </p>

</div>
</div>
<a id="a39f06324bb1e886838ffb6995295cda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f06324bb1e886838ffb6995295cda0">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">STATIC&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">consensus_digest_eq&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(const uint8_t *d1, const uint8_t *d2)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <b>d1</b> and <b>d2</b> contain the same digest </p>

</div>
</div>
<a id="a8ea8373194d59b92419294611aa7c77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea8373194d59b92419294611aa7c77b">&#9670;&nbsp;</a></span>next_router()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int next_router </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper: Find the next router line starting at the current position. Assumes that cur is lower than the length of the smartlist, i.e. it is a line within the bounds of the consensus. The only exception is when we don't want to skip the first line, in which case cur will be -1. </p>

</div>
</div>
<a id="a6293383be931683a9ccd524751c99cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6293383be931683a9ccd524751c99cb1">&#9670;&nbsp;</a></span>set_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC void set_changed </td>
          <td>(</td>
          <td class="paramtype">bitarray_t *&#160;</td>
          <td class="paramname"><em>changed1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitarray_t *&#160;</td>
          <td class="paramname"><em>changed2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const smartlist_slice_t *&#160;</td>
          <td class="paramname"><em>slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const smartlist_slice_t *&#160;</td>
          <td class="paramname"><em>slice2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper: Set all the appropriate changed booleans to true. The first slice must be of length 0 or 1. All the lines of slice1 and slice2 which are not present in the other slice will be set to changed in their bool array. The two changed bool arrays are passed in the same order as the slices. </p>

</div>
</div>
<a id="a16cbdd8439ee2d3727e6ed1b670d31e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cbdd8439ee2d3727e6ed1b670d31e5">&#9670;&nbsp;</a></span>smartlist_add_linecpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC void smartlist_add_linecpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmemarea__t.html">memarea_t</a> *&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a cdline_t to <b>lst</b> holding as its contents the nul-terminated string s. Use the provided memory area for storage. </p>

</div>
</div>
<a id="a9230afcb4352fead94a2e8341e971fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9230afcb4352fead94a2e8341e971fdc">&#9670;&nbsp;</a></span>smartlist_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC smartlist_slice_t* smartlist_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create (allocate) a new slice from a smartlist. Assumes that the start and the end indexes are within the bounds of the initial smartlist. The end element is not part of the resulting slice. If end is -1, the slice is to reach the end of the smartlist. </p>

</div>
</div>
<a id="af131136ce4b0bdead45911f3426d28d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af131136ce4b0bdead45911f3426d28d0">&#9670;&nbsp;</a></span>smartlist_slice_string_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC int smartlist_slice_string_pos </td>
          <td>(</td>
          <td class="paramtype">const smartlist_slice_t *&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cdline_t *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like smartlist_string_pos, but uses a cdline_t, and is restricted to the bounds of the slice. </p>

</div>
</div>
<a id="a450c29ea724a0271bfc227a157e24332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450c29ea724a0271bfc227a157e24332">&#9670;&nbsp;</a></span>trim_slices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC void trim_slices </td>
          <td>(</td>
          <td class="paramtype">smartlist_slice_t *&#160;</td>
          <td class="paramname"><em>slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smartlist_slice_t *&#160;</td>
          <td class="paramname"><em>slice2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper: Trim any number of lines that are equally at the start or the end of both slices. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
