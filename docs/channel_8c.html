<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: /home/user/_my/code/bwauth-related/tor/src/or/channel.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97b64286d42c5ef1697cb5f17129db19.html">tor</a></li><li class="navelem"><a class="el" href="dir_3cb0ba3f4b82dbe34a1a06276e96bc8d.html">src</a></li><li class="navelem"><a class="el" href="dir_386635fabd7f6c74e9d9c7a8604514a0.html">or</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">channel.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>OR/OP-to-OR channel abstraction layer. A channel's job is to transfer cells from Tor instance to Tor instance. Currently, there is only one implementation of the channel abstraction: in <a class="el" href="channeltls_8c.html" title="A concrete subclass of channel_t using or_connection_t to transfer cells between Tor instances...">channeltls.c</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="or_8h_source.html">or.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="channel_8h_source.html">channel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="channeltls_8h_source.html">channeltls.h</a>&quot;</code><br />
<code>#include &quot;channelpadding.h&quot;</code><br />
<code>#include &quot;<a class="el" href="circuitbuild_8h_source.html">circuitbuild.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="circuitlist_8h_source.html">circuitlist.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="circuitstats_8h_source.html">circuitstats.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="config_8h_source.html">config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="connection__or_8h_source.html">connection_or.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="circuitmux_8h_source.html">circuitmux.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="entrynodes_8h_source.html">entrynodes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geoip_8h_source.html">geoip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="main_8h_source.html">main.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="nodelist_8h_source.html">nodelist.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="relay_8h_source.html">relay.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rephist_8h_source.html">rephist.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="router_8h_source.html">router.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="routerlist_8h_source.html">routerlist.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="scheduler_8h_source.html">scheduler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="compat__time_8h_source.html">compat_time.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="networkstatus_8h_source.html">networkstatus.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rendservice_8h_source.html">rendservice.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for channel.c:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8c" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8c" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2channel_8c">
<area shape="rect" id="node2" href="or_8h.html" title="Master header file for Tor&#45;specific functionality. " alt="" coords="918,333,962,360"/>
<area shape="rect" id="node24" href="channel_8h.html" title="Header file for channel.c. " alt="" coords="1242,184,1321,211"/>
<area shape="rect" id="node25" href="circuitmux_8h.html" title="Header file for circuitmux.c. " alt="" coords="1151,259,1244,285"/>
<area shape="rect" id="node28" href="channeltls_8h.html" title="Header file for channeltls.c. " alt="" coords="814,109,906,136"/>
<area shape="rect" id="node29" href="channelpadding_8h_source.html" title="channelpadding.h" alt="" coords="616,109,739,136"/>
<area shape="rect" id="node31" href="circuitbuild_8h.html" title="Header file for circuitbuild.c. " alt="" coords="930,109,1025,136"/>
<area shape="rect" id="node32" href="circuitlist_8h.html" title="Header file for circuitlist.c. " alt="" coords="430,333,515,360"/>
<area shape="rect" id="node34" href="circuitstats_8h.html" title="Header file for circuitstats.c. " alt="" coords="1101,109,1198,136"/>
<area shape="rect" id="node35" href="config_8h.html" title="Header file for config.c. " alt="" coords="1950,259,2018,285"/>
<area shape="rect" id="node36" href="connection__or_8h.html" title="Header file for connection_or.c. " alt="" coords="1274,109,1388,136"/>
<area shape="rect" id="node37" href="entrynodes_8h.html" title="Header file for circuitbuild.c. " alt="" coords="1914,184,2012,211"/>
<area shape="rect" id="node38" href="geoip_8h.html" title="Header file for geoip.c. " alt="" coords="1527,109,1591,136"/>
<area shape="rect" id="node40" href="main_8h.html" title="Header file for main.c. " alt="" coords="1615,109,1676,136"/>
<area shape="rect" id="node41" href="nodelist_8h.html" title="Header file for nodelist.c. " alt="" coords="1701,109,1780,136"/>
<area shape="rect" id="node42" href="relay_8h.html" title="Header file for relay.c. " alt="" coords="1804,109,1866,136"/>
<area shape="rect" id="node43" href="rephist_8h.html" title="Header file for rephist.c. " alt="" coords="1890,109,1962,136"/>
<area shape="rect" id="node44" href="router_8h.html" title="Header file for router.c. " alt="" coords="1990,333,2056,360"/>
<area shape="rect" id="node45" href="routerlist_8h.html" title="Header file for routerlist.c. " alt="" coords="2138,184,2220,211"/>
<area shape="rect" id="node46" href="scheduler_8h.html" title="Header file for scheduler*.c. " alt="" coords="1413,109,1502,136"/>
<area shape="rect" id="node47" href="compat__time_8h.html" title="Functions and types for monotonic times. " alt="" coords="2244,632,2352,659"/>
<area shape="rect" id="node48" href="networkstatus_8h.html" title="Header file for networkstatus.c. " alt="" coords="2154,259,2268,285"/>
<area shape="rect" id="node49" href="rendservice_8h.html" title="Header file for rendservice.c. " alt="" coords="510,259,610,285"/>
<area shape="rect" id="node3" href="orconfig_8h_source.html" title="orconfig.h" alt="" coords="1164,707,1242,733"/>
<area shape="rect" id="node4" href="torint_8h.html" title="Header file to define uint32_t and friends. " alt="" coords="637,632,700,659"/>
<area shape="rect" id="node6" href="crypto_8h.html" title="Headers for crypto.c. " alt="" coords="242,557,311,584"/>
<area shape="rect" id="node7" href="crypto__format_8h_source.html" title="crypto_format.h" alt="" coords="549,408,662,435"/>
<area shape="rect" id="node9" href="crypto__ed25519_8h_source.html" title="crypto_ed25519.h" alt="" coords="394,483,519,509"/>
<area shape="rect" id="node10" href="crypto__curve25519_8h_source.html" title="crypto_curve25519.h" alt="" coords="437,557,580,584"/>
<area shape="rect" id="node11" href="tortls_8h.html" title="Headers for tortls.c. " alt="" coords="1394,483,1457,509"/>
<area shape="rect" id="node12" href="torlog_8h.html" title="Headers for log.c. " alt="" coords="1481,483,1546,509"/>
<area shape="rect" id="node13" href="container_8h_source.html" title="container.h" alt="" coords="1284,483,1370,509"/>
<area shape="rect" id="node14" href="compress_8h.html" title="Headers for compress.c. " alt="" coords="1132,408,1223,435"/>
<area shape="rect" id="node15" href="address_8h.html" title="Headers for address.h. " alt="" coords="1029,408,1108,435"/>
<area shape="rect" id="node16" href="compat__libevent_8h_source.html" title="compat_libevent.h" alt="" coords="1063,557,1191,584"/>
<area shape="rect" id="node17" href="ht_8h_source.html" title="ht.h" alt="" coords="1248,408,1292,435"/>
<area shape="rect" id="node18" href="confline_8h_source.html" title="confline.h" alt="" coords="1316,408,1394,435"/>
<area shape="rect" id="node19" href="replaycache_8h.html" title="Header file for replaycache.c. " alt="" coords="141,408,244,435"/>
<area shape="rect" id="node20" href="tor__queue_8h_source.html" title="tor_queue.h" alt="" coords="1672,408,1763,435"/>
<area shape="rect" id="node21" href="token__bucket_8h_source.html" title="token_bucket.h" alt="" coords="928,557,1038,584"/>
<area shape="rect" id="node22" href="util__format_8h_source.html" title="util_format.h" alt="" coords="706,557,801,584"/>
<area shape="rect" id="node23" href="hs__circuitmap_8h.html" title="Header file for hs_circuitmap.c. " alt="" coords="788,408,903,435"/>
<area shape="rect" id="node8" href="testsupport_8h_source.html" title="testsupport.h" alt="" coords="1464,632,1563,659"/>
<area shape="rect" id="node26" href="timers_8h_source.html" title="timers.h" alt="" coords="1612,557,1682,584"/>
<area shape="rect" id="node27" href="handles_8h.html" title="Macros for C weak&#45;handle implementation. " alt="" coords="1785,259,1864,285"/>
<area shape="rect" id="node30" href="channelpadding__negotiation_8h_source.html" title="channelpadding_negotiation.h" alt="" coords="580,184,773,211"/>
<area shape="rect" id="node33" href="hs__ident_8h.html" title="Header file containing circuit and connection identifier data for the whole HS subsytem. " alt="" coords="34,408,116,435"/>
<area shape="rect" id="node39" href="dos_8h_source.html" title="dos.h" alt="" coords="1836,184,1890,211"/>
<area shape="rect" id="node50" href="hs__service_8h.html" title="Header file containing service data for the HS subsytem. " alt="" coords="27,333,123,360"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab2eda2cfbeb176ae5a0ed6613d53022a"><td class="memItemLeft" align="right" valign="top"><a id="ab2eda2cfbeb176ae5a0ed6613d53022a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TOR_CHANNEL_INTERNAL_</b></td></tr>
<tr class="separator:ab2eda2cfbeb176ae5a0ed6613d53022a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4309c0844d736c45f510cd11b1fa9aa6"><td class="memItemLeft" align="right" valign="top"><a id="a4309c0844d736c45f510cd11b1fa9aa6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHANNEL_PRIVATE_</b></td></tr>
<tr class="separator:a4309c0844d736c45f510cd11b1fa9aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c03e6a689e54d3619b4f096c508979e"><td class="memItemLeft" align="right" valign="top"><a id="a7c03e6a689e54d3619b4f096c508979e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN_RELAY_CONNECTIONS_TO_WARN</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a7c03e6a689e54d3619b4f096c508979e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bac158c25f8c448289831d330fa6af"><td class="memItemLeft" align="right" valign="top"><a id="ad7bac158c25f8c448289831d330fa6af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_CELLS_TO_GET_FROM_CIRCUITS_FOR_UNLIMITED</b>&#160;&#160;&#160;256</td></tr>
<tr class="separator:ad7bac158c25f8c448289831d330fa6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad47201fb54e0db44f552c018d59e535d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ad47201fb54e0db44f552c018d59e535d">HT_PROTOTYPE</a> (HT_GENERATE2(channel_gid_map, HT_GENERATE2(<a class="el" href="structchannel__s.html">channel_s</a>, HT_GENERATE2(gidmap_node, HT_GENERATE2(channel_id_hash, HT_GENERATE2(channel_id_eq)</td></tr>
<tr class="separator:ad47201fb54e0db44f552c018d59e535d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdf98e720a6acc2e476e681e91e4fde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a5bdf98e720a6acc2e476e681e91e4fde">channel_listener_state_is_valid</a> (channel_listener_state_t state)</td></tr>
<tr class="separator:a5bdf98e720a6acc2e476e681e91e4fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727f5f4b03dca7d9b0ef71842709c055"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a727f5f4b03dca7d9b0ef71842709c055">channel_state_can_transition</a> (channel_state_t from, channel_state_t to)</td></tr>
<tr class="separator:a727f5f4b03dca7d9b0ef71842709c055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447edc0876c6c437ae72b5c49b8e038a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a447edc0876c6c437ae72b5c49b8e038a">channel_listener_state_can_transition</a> (channel_listener_state_t from, channel_listener_state_t to)</td></tr>
<tr class="separator:a447edc0876c6c437ae72b5c49b8e038a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5368fc8c3c7f7b0ce1020927961c92a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ac5368fc8c3c7f7b0ce1020927961c92a">channel_state_to_string</a> (channel_state_t state)</td></tr>
<tr class="separator:ac5368fc8c3c7f7b0ce1020927961c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0cac4ba2733cffddc9ff59be701687"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#aee0cac4ba2733cffddc9ff59be701687">channel_listener_state_to_string</a> (channel_listener_state_t state)</td></tr>
<tr class="separator:aee0cac4ba2733cffddc9ff59be701687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7becc4cc5e7dd116f44f86a1b826dc9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a7becc4cc5e7dd116f44f86a1b826dc9a">channel_register</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a7becc4cc5e7dd116f44f86a1b826dc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbc6210c258ddbc944e9f0d6d386b45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a9bbc6210c258ddbc944e9f0d6d386b45">channel_unregister</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a9bbc6210c258ddbc944e9f0d6d386b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc659d90d9518f8f8bcf5a4d4f49acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a7fc659d90d9518f8f8bcf5a4d4f49acb">channel_listener_register</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a7fc659d90d9518f8f8bcf5a4d4f49acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d954d609b0decab6e56e2ab7e2444f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a2d954d609b0decab6e56e2ab7e2444f6">channel_listener_unregister</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a2d954d609b0decab6e56e2ab7e2444f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479196792d3ddd821bdfe24cc25364b1"><td class="memItemLeft" align="right" valign="top">STATIC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a479196792d3ddd821bdfe24cc25364b1">channel_add_to_digest_map</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a479196792d3ddd821bdfe24cc25364b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ce362c180c51c5018668bae7bb4f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a03ce362c180c51c5018668bae7bb4f24">channel_find_by_global_id</a> (uint64_t global_identifier)</td></tr>
<tr class="separator:a03ce362c180c51c5018668bae7bb4f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ab9bd6d990fc6d07b0c8842a3aee71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a04ab9bd6d990fc6d07b0c8842a3aee71">channel_find_by_remote_identity</a> (const char *rsa_id_digest, const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *ed_id)</td></tr>
<tr class="separator:a04ab9bd6d990fc6d07b0c8842a3aee71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb42fd943884ecec3e7a7469c4e52f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a1bb42fd943884ecec3e7a7469c4e52f3">channel_next_with_rsa_identity</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a1bb42fd943884ecec3e7a7469c4e52f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea19d2f4cb7ba545fffa00bf86b6559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a4ea19d2f4cb7ba545fffa00bf86b6559">channel_check_for_duplicates</a> (void)</td></tr>
<tr class="separator:a4ea19d2f4cb7ba545fffa00bf86b6559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af394d37fffd7367c8c882834e6451a89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#af394d37fffd7367c8c882834e6451a89">channel_init</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:af394d37fffd7367c8c882834e6451a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4259678584b7e032533f1144a7412616"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a4259678584b7e032533f1144a7412616">channel_init_listener</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a4259678584b7e032533f1144a7412616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa138124aa840cbabbbe2065c933b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#afaa138124aa840cbabbbe2065c933b09">channel_free_</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:afaa138124aa840cbabbbe2065c933b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa917fccb124ebe2d88705c5893875984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#aa917fccb124ebe2d88705c5893875984">channel_listener_free_</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:aa917fccb124ebe2d88705c5893875984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770610a2b8d7a5c3060778b63a3d4030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a770610a2b8d7a5c3060778b63a3d4030">channel_listener_set_listener_fn</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l, channel_listener_fn_ptr listener)</td></tr>
<tr class="separator:a770610a2b8d7a5c3060778b63a3d4030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3b8c3a3d91967c63fea496d2fe1b2e"><td class="memItemLeft" align="right" valign="top">channel_cell_handler_fn_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a9f3b8c3a3d91967c63fea496d2fe1b2e">channel_get_cell_handler</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a9f3b8c3a3d91967c63fea496d2fe1b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee619f7637f1a10fec2da20ea004e998"><td class="memItemLeft" align="right" valign="top">channel_var_cell_handler_fn_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#aee619f7637f1a10fec2da20ea004e998">channel_get_var_cell_handler</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:aee619f7637f1a10fec2da20ea004e998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c26cbf4843fb4609f3f0c1eee87498c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a5c26cbf4843fb4609f3f0c1eee87498c">channel_set_cell_handlers</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, channel_cell_handler_fn_ptr cell_handler, channel_var_cell_handler_fn_ptr var_cell_handler)</td></tr>
<tr class="separator:a5c26cbf4843fb4609f3f0c1eee87498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c51ad12ff89e0f63cc386ccda8493f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ac5c51ad12ff89e0f63cc386ccda8493f">channel_mark_for_close</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ac5c51ad12ff89e0f63cc386ccda8493f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d328d0eebd17c646ec3a1ff4442d827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a4d328d0eebd17c646ec3a1ff4442d827">channel_listener_mark_for_close</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a4d328d0eebd17c646ec3a1ff4442d827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e837dc6a0d539d5f38ed4b0977448f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a4e837dc6a0d539d5f38ed4b0977448f5">channel_close_from_lower_layer</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a4e837dc6a0d539d5f38ed4b0977448f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b91c363817271b75f1f75fa967e5e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#aa5b91c363817271b75f1f75fa967e5e3">channel_close_for_error</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:aa5b91c363817271b75f1f75fa967e5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a07dcb3da5d642570a8ed069c27450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a41a07dcb3da5d642570a8ed069c27450">channel_closed</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a41a07dcb3da5d642570a8ed069c27450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7370451f8b2f2b79a84f7f9b902de34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ac7370451f8b2f2b79a84f7f9b902de34">channel_clear_identity_digest</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ac7370451f8b2f2b79a84f7f9b902de34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232c3afb3714be50f965df83b2d2d40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a232c3afb3714be50f965df83b2d2d40d">channel_set_identity_digest</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, const char *identity_digest, const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *ed_identity)</td></tr>
<tr class="separator:a232c3afb3714be50f965df83b2d2d40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd708a0b9e8474dd133f87a50d341f7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#acd708a0b9e8474dd133f87a50d341f7b">channel_clear_remote_end</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:acd708a0b9e8474dd133f87a50d341f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea762ac9b96570c55daa5dd57c95eafa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#aea762ac9b96570c55daa5dd57c95eafa">channel_write_packed_cell</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *cell)</td></tr>
<tr class="separator:aea762ac9b96570c55daa5dd57c95eafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae0c20f03e6a224c2d730ec96342097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#afae0c20f03e6a224c2d730ec96342097">channel_change_state</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, channel_state_t to_state)</td></tr>
<tr class="separator:afae0c20f03e6a224c2d730ec96342097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f33612da14ec718ecaf16bfdd12908d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a4f33612da14ec718ecaf16bfdd12908d">channel_change_state_open</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a4f33612da14ec718ecaf16bfdd12908d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0126606a15537e0647e81a9c2ca8b74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ad0126606a15537e0647e81a9c2ca8b74">channel_listener_change_state</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l, channel_listener_state_t to_state)</td></tr>
<tr class="separator:ad0126606a15537e0647e81a9c2ca8b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9de3211fa3b2007ca0f42e9022dc800"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ae9de3211fa3b2007ca0f42e9022dc800">MOCK_IMPL</a> (ssize_t, channel_flush_some_cells,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, ssize_t num_cells))</td></tr>
<tr class="separator:ae9de3211fa3b2007ca0f42e9022dc800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8cfb44344a590f1ac113dfd415b02f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a4c8cfb44344a590f1ac113dfd415b02f">MOCK_IMPL</a> (int, channel_more_to_flush,(<a class="el" href="structchannel__s.html">channel_t</a> *chan))</td></tr>
<tr class="separator:a4c8cfb44344a590f1ac113dfd415b02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5a904f9dc44b21911ceed8d18fd218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#abc5a904f9dc44b21911ceed8d18fd218">channel_notify_flushed</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:abc5a904f9dc44b21911ceed8d18fd218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a020ddaa5f55c078d4513c47128f263"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a1a020ddaa5f55c078d4513c47128f263">channel_listener_process_incoming</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *listener)</td></tr>
<tr class="separator:a1a020ddaa5f55c078d4513c47128f263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb9524073333e156da271ca623a772d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a4bb9524073333e156da271ca623a772d">channel_do_open_actions</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a4bb9524073333e156da271ca623a772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f08cb6c0828f43f1253018f9fe3650"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a54f08cb6c0828f43f1253018f9fe3650">channel_listener_queue_incoming</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *listener, <a class="el" href="structchannel__s.html">channel_t</a> *incoming)</td></tr>
<tr class="separator:a54f08cb6c0828f43f1253018f9fe3650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee1b816cf17de95ff399e365f1725bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a4ee1b816cf17de95ff399e365f1725bd">channel_process_cell</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structcell__t.html">cell_t</a> *cell)</td></tr>
<tr class="separator:a4ee1b816cf17de95ff399e365f1725bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa036957ef1d90c086c403814da8de52f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#aa036957ef1d90c086c403814da8de52f">packed_cell_is_destroy</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, const <a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *packed_cell, <a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> *circid_out)</td></tr>
<tr class="separator:aa036957ef1d90c086c403814da8de52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e3e2de528821cdda969fba6de1e4f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a85e3e2de528821cdda969fba6de1e4f2">channel_send_destroy</a> (<a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> circ_id, <a class="el" href="structchannel__s.html">channel_t</a> *chan, int reason)</td></tr>
<tr class="separator:a85e3e2de528821cdda969fba6de1e4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef365ba78cdfea35f694be31bfd6e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a1ef365ba78cdfea35f694be31bfd6e91">channel_dumpstats</a> (int severity)</td></tr>
<tr class="separator:a1ef365ba78cdfea35f694be31bfd6e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0519ba6c6b14de83e886ed42095fe68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ab0519ba6c6b14de83e886ed42095fe68">channel_listener_dumpstats</a> (int severity)</td></tr>
<tr class="separator:ab0519ba6c6b14de83e886ed42095fe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d874b0dd28680dd7f9661e2490d9091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a1d874b0dd28680dd7f9661e2490d9091">channel_run_cleanup</a> (void)</td></tr>
<tr class="separator:a1d874b0dd28680dd7f9661e2490d9091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7838364ded7b78a661a1f3f2f1c266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a3e7838364ded7b78a661a1f3f2f1c266">channel_listener_run_cleanup</a> (void)</td></tr>
<tr class="separator:a3e7838364ded7b78a661a1f3f2f1c266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d84e3ecc8f662ed2072a2104d0b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#adb2d84e3ecc8f662ed2072a2104d0b6b">channel_free_all</a> (void)</td></tr>
<tr class="separator:adb2d84e3ecc8f662ed2072a2104d0b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de1eedac60a9f05dd621bc9b07909dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a2de1eedac60a9f05dd621bc9b07909dd">channel_connect</a> (const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr, uint16_t port, const char *id_digest, const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *ed_id)</td></tr>
<tr class="separator:a2de1eedac60a9f05dd621bc9b07909dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098e7f8cd053cab6477b2ff9dcbd7190"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a098e7f8cd053cab6477b2ff9dcbd7190">channel_is_better</a> (<a class="el" href="structchannel__s.html">channel_t</a> *a, <a class="el" href="structchannel__s.html">channel_t</a> *b)</td></tr>
<tr class="separator:a098e7f8cd053cab6477b2ff9dcbd7190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225a9a8dab25e6fa224525867d0a056e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a225a9a8dab25e6fa224525867d0a056e">channel_get_for_extend</a> (const char *rsa_id_digest, const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *ed_id, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *target_addr, const char **msg_out, int *launch_out)</td></tr>
<tr class="separator:a225a9a8dab25e6fa224525867d0a056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185d59ac3e69ab26d2b71804cb882993"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a185d59ac3e69ab26d2b71804cb882993">channel_describe_transport</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a185d59ac3e69ab26d2b71804cb882993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0104c379fab8d5cf7dc3eddf113dc44e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a0104c379fab8d5cf7dc3eddf113dc44e">channel_listener_describe_transport</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a0104c379fab8d5cf7dc3eddf113dc44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56dc7ecc8a31e8bfa4dc5281b72c21e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ab56dc7ecc8a31e8bfa4dc5281b72c21e">MOCK_IMPL</a> (void, channel_dump_statistics,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, int severity))</td></tr>
<tr class="separator:ab56dc7ecc8a31e8bfa4dc5281b72c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e2ae335dbe5af256b18df4f3c1070e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a31e2ae335dbe5af256b18df4f3c1070e">channel_listener_dump_statistics</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l, int severity)</td></tr>
<tr class="separator:a31e2ae335dbe5af256b18df4f3c1070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2704646dbc4d5113c2160fd9842f128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ae2704646dbc4d5113c2160fd9842f128">channel_dump_transport_statistics</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, int severity)</td></tr>
<tr class="separator:ae2704646dbc4d5113c2160fd9842f128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8193e4c4351e724edc8ecaddd09f8e10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a8193e4c4351e724edc8ecaddd09f8e10">channel_listener_dump_transport_statistics</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l, int severity)</td></tr>
<tr class="separator:a8193e4c4351e724edc8ecaddd09f8e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8608773117c50600ebe58ffc331b6b3e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a8608773117c50600ebe58ffc331b6b3e">channel_get_actual_remote_descr</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a8608773117c50600ebe58ffc331b6b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1c9c62855d488fa17eaa4c4dd3f6e5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a3c1c9c62855d488fa17eaa4c4dd3f6e5">channel_get_actual_remote_address</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a3c1c9c62855d488fa17eaa4c4dd3f6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a5bd1e17411b06028d4839ad6e6df"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a5a9a5bd1e17411b06028d4839ad6e6df">channel_get_canonical_remote_descr</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a5a9a5bd1e17411b06028d4839ad6e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026e3719d86173650d21c6f28124514e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a026e3719d86173650d21c6f28124514e">MOCK_IMPL</a> (int, channel_get_addr_if_possible,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr_out))</td></tr>
<tr class="separator:a026e3719d86173650d21c6f28124514e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02db0f9ae91b50323bd345a224d9d1d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a02db0f9ae91b50323bd345a224d9d1d8">channel_has_queued_writes</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a02db0f9ae91b50323bd345a224d9d1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118d357c7f7accb2f220b000f33ea714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a118d357c7f7accb2f220b000f33ea714">channel_is_bad_for_new_circs</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a118d357c7f7accb2f220b000f33ea714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b61336ba7b19572a83d335a6aad65f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a93b61336ba7b19572a83d335a6aad65f">channel_mark_bad_for_new_circs</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a93b61336ba7b19572a83d335a6aad65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e699a108ac50e3f7e356b336734a56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a94e699a108ac50e3f7e356b336734a56">channel_is_client</a> (const <a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a94e699a108ac50e3f7e356b336734a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad8f3da9b53f2a239196da6a822420a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a3ad8f3da9b53f2a239196da6a822420a">channel_mark_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a3ad8f3da9b53f2a239196da6a822420a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9de3ab9c23adb8e2646a4767e7d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ae5c9de3ab9c23adb8e2646a4767e7d37">channel_clear_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ae5c9de3ab9c23adb8e2646a4767e7d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58978b931d8b11d4673287e59f8d54bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a58978b931d8b11d4673287e59f8d54bc">channel_is_canonical</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a58978b931d8b11d4673287e59f8d54bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2175e5e47f323e17e518474e8210907f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a2175e5e47f323e17e518474e8210907f">channel_is_canonical_is_reliable</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a2175e5e47f323e17e518474e8210907f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94903f24f674c7a4dd95dd51e6b6b047"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a94903f24f674c7a4dd95dd51e6b6b047">channel_is_incoming</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a94903f24f674c7a4dd95dd51e6b6b047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40184005ca97cc8b3e70ac3a82b9d1fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a40184005ca97cc8b3e70ac3a82b9d1fa">channel_mark_incoming</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a40184005ca97cc8b3e70ac3a82b9d1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7950c59a4fefcd76e3e3b327d86114f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ab7950c59a4fefcd76e3e3b327d86114f">channel_is_local</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ab7950c59a4fefcd76e3e3b327d86114f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366226ae4d3bca86afd5eff78e61cc27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a366226ae4d3bca86afd5eff78e61cc27">channel_mark_local</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a366226ae4d3bca86afd5eff78e61cc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9d0a934832b0444951a374a78025cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a9a9d0a934832b0444951a374a78025cb">channel_mark_remote</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a9a9d0a934832b0444951a374a78025cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150180857a5c09e9ab16095b6011fd06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a150180857a5c09e9ab16095b6011fd06">channel_is_outgoing</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a150180857a5c09e9ab16095b6011fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad513e8317c2960176b7a646bb675b2e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ad513e8317c2960176b7a646bb675b2e9">channel_mark_outgoing</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ad513e8317c2960176b7a646bb675b2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbcbfef4049d88a2975b9cf4ca71645"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#abcbcbfef4049d88a2975b9cf4ca71645">channel_num_cells_writeable</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:abcbcbfef4049d88a2975b9cf4ca71645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63986ced82f0d5c58fd872e40ed46598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a63986ced82f0d5c58fd872e40ed46598">channel_timestamp_created</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a63986ced82f0d5c58fd872e40ed46598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c86ea4153b077173702319f0fa5b196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a7c86ea4153b077173702319f0fa5b196">channel_listener_timestamp_created</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a7c86ea4153b077173702319f0fa5b196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dea4276de8427cb789cda94be8eea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a08dea4276de8427cb789cda94be8eea7">channel_timestamp_active</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a08dea4276de8427cb789cda94be8eea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccf1c1d0d34e84bb663fea0426051b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a7ccf1c1d0d34e84bb663fea0426051b5">channel_listener_timestamp_active</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:a7ccf1c1d0d34e84bb663fea0426051b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3b198fd2e78a28eda3228892847baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#abc3b198fd2e78a28eda3228892847baa">channel_listener_timestamp_accepted</a> (<a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *chan_l)</td></tr>
<tr class="separator:abc3b198fd2e78a28eda3228892847baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cdde3933fc1ca5c83494d1fb0e684f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a20cdde3933fc1ca5c83494d1fb0e684f">channel_timestamp_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a20cdde3933fc1ca5c83494d1fb0e684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc7e87f9acbb2d5954540f997cf0b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a1cc7e87f9acbb2d5954540f997cf0b57">channel_timestamp_recv</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a1cc7e87f9acbb2d5954540f997cf0b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbe03d1c68e1ebc7133e4195fbfca29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#abdbe03d1c68e1ebc7133e4195fbfca29">channel_timestamp_xmit</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:abdbe03d1c68e1ebc7133e4195fbfca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff1eebb5bba0a9371c5679994d51329"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#aeff1eebb5bba0a9371c5679994d51329">channel_when_created</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:aeff1eebb5bba0a9371c5679994d51329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c9bb52317ac2f0189a286108bdc7e"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a7c7c9bb52317ac2f0189a286108bdc7e">channel_when_last_client</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a7c7c9bb52317ac2f0189a286108bdc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce5cc93d2f7a10ad18300c4049108ef"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a3ce5cc93d2f7a10ad18300c4049108ef">channel_when_last_xmit</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:a3ce5cc93d2f7a10ad18300c4049108ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb4f4e8f649a753d3d22fb84653c05b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a6cb4f4e8f649a753d3d22fb84653c05b">channel_matches_extend_info</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structextend__info__t.html">extend_info_t</a> *extend_info)</td></tr>
<tr class="separator:a6cb4f4e8f649a753d3d22fb84653c05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9744cd45d925184288dc3751fc1d455"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ae9744cd45d925184288dc3751fc1d455">channel_matches_target_addr_for_extend</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *target)</td></tr>
<tr class="separator:ae9744cd45d925184288dc3751fc1d455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae541683374c3002a6218c576c9775910"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ae541683374c3002a6218c576c9775910">channel_num_circuits</a> (<a class="el" href="structchannel__s.html">channel_t</a> *chan)</td></tr>
<tr class="separator:ae541683374c3002a6218c576c9775910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d6f1fad148b483bdb8d2443dab0718"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#ae9d6f1fad148b483bdb8d2443dab0718">MOCK_IMPL</a> (void, channel_set_circid_type,(<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structcrypto__pk__t.html">crypto_pk_t</a> *identity_rcvd, int consider_identity))</td></tr>
<tr class="separator:ae9d6f1fad148b483bdb8d2443dab0718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4bd42593d0df3646e947bf4661648f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="channel_8c.html#a1e4bd42593d0df3646e947bf4661648f">channel_update_bad_for_new_circs</a> (const char *digest, int force)</td></tr>
<tr class="separator:a1e4bd42593d0df3646e947bf4661648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a92ce228e454d19690e5dad548a4cd29b"><td class="memItemLeft" align="right" valign="top"><a id="a92ce228e454d19690e5dad548a4cd29b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>channel_idmap_entry_t</b></td></tr>
<tr class="separator:a92ce228e454d19690e5dad548a4cd29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>OR/OP-to-OR channel abstraction layer. A channel's job is to transfer cells from Tor instance to Tor instance. Currently, there is only one implementation of the channel abstraction: in <a class="el" href="channeltls_8c.html" title="A concrete subclass of channel_t using or_connection_t to transfer cells between Tor instances...">channeltls.c</a>. </p>
<p>Channels are a higher-level abstraction than <a class="el" href="structor__connection__t.html">or_connection_t</a>: In general, any means that two Tor relays use to exchange cells, or any means that a relay and a client use to exchange cells, is a channel.</p>
<p>Channels differ from pluggable transports in that they do not wrap an underlying protocol over which cells are transmitted: they <em>are</em> the underlying protocol.</p>
<p>This module defines the generic parts of the channel_t interface, and provides the machinery necessary for specialized implementations to be created. At present, there is one specialized implementation in <a class="el" href="channeltls_8c.html" title="A concrete subclass of channel_t using or_connection_t to transfer cells between Tor instances...">channeltls.c</a>, which uses <a class="el" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. ">connection_or.c</a> to send cells over a TLS connection.</p>
<p>Every channel implementation is responsible for being able to transmit cells that are passed to it</p>
<p>For <em>inbound</em> cells, the entry point is: <a class="el" href="channel_8c.html#a4ee1b816cf17de95ff399e365f1725bd">channel_process_cell()</a>. It takes a cell and will pass it to the cell handler set by <a class="el" href="channel_8c.html#a5c26cbf4843fb4609f3f0c1eee87498c">channel_set_cell_handlers()</a>. Currently, this is passed back to the command subsystem which is <a class="el" href="command_8c.html#a1e6109e2d1a1b76f296a7abd9afac9d4">command_process_cell()</a>.</p>
<p>NOTE: For now, the separation between channels and specialized channels (like channeltls) is not that well defined. So the channeltls layer calls <a class="el" href="channel_8c.html#a4ee1b816cf17de95ff399e365f1725bd">channel_process_cell()</a> which originally comes from the connection subsytem. This should be hopefully be fixed with #23993.</p>
<p>For <em>outbound</em> cells, the entry point is: <a class="el" href="channel_8c.html#aea762ac9b96570c55daa5dd57c95eafa">channel_write_packed_cell()</a>. Only packed cells are dequeued from the circuit queue by the scheduler which uses channel_flush_from_first_active_circuit() to decide which cells to flush from which circuit on the channel. They are then passed down to the channel subsystem. This calls the low layer with the function pointer .write_packed_cell().</p>
<p>Each specialized channel (currently only channeltls_t) MUST implement a series of function found in channel_t. See <a class="el" href="channel_8h.html" title="Header file for channel.c. ">channel.h</a> for more documentation. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a479196792d3ddd821bdfe24cc25364b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479196792d3ddd821bdfe24cc25364b1">&#9670;&nbsp;</a></span>channel_add_to_digest_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATIC void channel_add_to_digest_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a channel to the digest map.</p>
<p>This function adds a channel to the digest map and inserts it into the correct linked list if channels with that remote endpoint identity digest already exist. </p>

</div>
</div>
<a id="afae0c20f03e6a224c2d730ec96342097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae0c20f03e6a224c2d730ec96342097">&#9670;&nbsp;</a></span>channel_change_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_change_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>to_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As channel_change_state_, but change the state to any state but open. </p>

</div>
</div>
<a id="a4f33612da14ec718ecaf16bfdd12908d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f33612da14ec718ecaf16bfdd12908d">&#9670;&nbsp;</a></span>channel_change_state_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_change_state_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As channel_change_state, but change the state to open. </p>

</div>
</div>
<a id="a4ea19d2f4cb7ba545fffa00bf86b6559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea19d2f4cb7ba545fffa00bf86b6559">&#9670;&nbsp;</a></span>channel_check_for_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_check_for_duplicates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relays run this once an hour to look over our list of channels to other relays. It prints out some statistics if there are multiple connections to many relays.</p>
<p>This function is similar to connection_or_set_bad_connections(), and probably could be adapted to replace it, if it was modified to actually take action on any of these connections. </p>

</div>
</div>
<a id="ae5c9de3ab9c23adb8e2646a4767e7d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c9de3ab9c23adb8e2646a4767e7d37">&#9670;&nbsp;</a></span>channel_clear_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_clear_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the client flag.</p>
<p>Mark a channel as being <em>not</em> from a client. </p>

</div>
</div>
<a id="ac7370451f8b2f2b79a84f7f9b902de34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7370451f8b2f2b79a84f7f9b902de34">&#9670;&nbsp;</a></span>channel_clear_identity_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_clear_identity_digest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the identity_digest of a channel.</p>
<p>This function clears the identity digest of the remote endpoint for a channel; this is intended for use by the lower layer. </p>

</div>
</div>
<a id="acd708a0b9e8474dd133f87a50d341f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd708a0b9e8474dd133f87a50d341f7b">&#9670;&nbsp;</a></span>channel_clear_remote_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_clear_remote_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the remote end metadata (identity_digest) of a channel.</p>
<p>This function clears all the remote end info from a channel; this is intended for use by the lower layer. </p>

</div>
</div>
<a id="aa5b91c363817271b75f1f75fa967e5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b91c363817271b75f1f75fa967e5e3">&#9670;&nbsp;</a></span>channel_close_for_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_close_for_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify that the channel is being closed due to an error condition.</p>
<p>This function is called by the lower layer implementing the transport when a channel must be closed due to an error condition. This does not call the channel's close method, since the lower layer already knows. </p>

</div>
</div>
<a id="a4e837dc6a0d539d5f38ed4b0977448f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e837dc6a0d539d5f38ed4b0977448f5">&#9670;&nbsp;</a></span>channel_close_from_lower_layer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_close_from_lower_layer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a channel from the lower layer.</p>
<p>Notify the channel code that the channel is being closed due to a non-error condition in the lower layer. This does not call the close() method, since the lower layer already knows. </p>

</div>
</div>
<a id="a41a07dcb3da5d642570a8ed069c27450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a07dcb3da5d642570a8ed069c27450">&#9670;&nbsp;</a></span>channel_closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_closed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify that the lower layer is finished closing the channel.</p>
<p>This function should be called by the lower layer when a channel is finished closing and it should be regarded as inactive and freed by the channel code. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a41a07dcb3da5d642570a8ed069c27450_icgraph.png" border="0" usemap="#channel_8c_a41a07dcb3da5d642570a8ed069c27450_icgraph" alt=""/></div>
<map name="channel_8c_a41a07dcb3da5d642570a8ed069c27450_icgraph" id="channel_8c_a41a07dcb3da5d642570a8ed069c27450_icgraph">
<area shape="rect" id="node2" href="connection__or_8h.html#a75f21aa5fe9678cceceadc67298afa2d" title="connection_or_about\l_to_close" alt="" coords="165,5,308,47"/>
</map>
</div>

</div>
</div>
<a id="a2de1eedac60a9f05dd621bc9b07909dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de1eedac60a9f05dd621bc9b07909dd">&#9670;&nbsp;</a></span>channel_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>ed_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect to a given addr/port/digest.</p>
<p>This sets up a new outgoing channel; in the future if multiple channel_t subclasses are available, this is where the selection policy should go. It may also be desirable to fold port into <a class="el" href="structtor__addr__t.html">tor_addr_t</a> or make a new type including a <a class="el" href="structtor__addr__t.html">tor_addr_t</a> and port, so we have a single abstract object encapsulating all the protocol details of how to contact an OR. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a2de1eedac60a9f05dd621bc9b07909dd_cgraph.png" border="0" usemap="#channel_8c_a2de1eedac60a9f05dd621bc9b07909dd_cgraph" alt=""/></div>
<map name="channel_8c_a2de1eedac60a9f05dd621bc9b07909dd_cgraph" id="channel_8c_a2de1eedac60a9f05dd621bc9b07909dd_cgraph">
<area shape="rect" id="node2" href="channeltls_8c.html#a8178dc802e84ceb764d8d5803e8d9a6b" title="channel_tls_connect" alt="" coords="173,5,315,32"/>
</map>
</div>

</div>
</div>
<a id="a185d59ac3e69ab26d2b71804cb882993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185d59ac3e69ab26d2b71804cb882993">&#9670;&nbsp;</a></span>channel_describe_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_describe_transport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describe the transport subclass for a channel.</p>
<p>Invoke a method to get a string description of the lower-layer transport for this channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a185d59ac3e69ab26d2b71804cb882993_icgraph.png" border="0" usemap="#channel_8c_a185d59ac3e69ab26d2b71804cb882993_icgraph" alt=""/></div>
<map name="channel_8c_a185d59ac3e69ab26d2b71804cb882993_icgraph" id="channel_8c_a185d59ac3e69ab26d2b71804cb882993_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ab56dc7ecc8a31e8bfa4dc5281b72c21e" title="MOCK_IMPL" alt="" coords="235,5,335,32"/>
</map>
</div>

</div>
</div>
<a id="a4bb9524073333e156da271ca623a772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb9524073333e156da271ca623a772d">&#9670;&nbsp;</a></span>channel_do_open_actions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_do_open_actions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take actions required when a channel becomes open.</p>
<p>Handle actions we should do when we know a channel is open; a lot of this comes from the old <a class="el" href="connection__or_8c.html#a10910510a0e668c958457783ccf154c9">connection_or_set_state_open()</a> of <a class="el" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. ">connection_or.c</a>.</p>
<p>Because of this mechanism, future channel_t subclasses should take care not to change a channel from CHANNEL_STATE_OPENING to CHANNEL_STATE_OPEN until there is positive confirmation that the network is operational. In particular, anything UDP-based should not make this transition until a packet is received from the other side. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a4bb9524073333e156da271ca623a772d_cgraph.png" border="0" usemap="#channel_8c_a4bb9524073333e156da271ca623a772d_cgraph" alt=""/></div>
<map name="channel_8c_a4bb9524073333e156da271ca623a772d_cgraph" id="channel_8c_a4bb9524073333e156da271ca623a772d_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a150180857a5c09e9ab16095b6011fd06" title="channel_is_outgoing" alt="" coords="233,5,373,32"/>
<area shape="rect" id="node3" href="circuitstats_8c.html#a2b95a37e26723de09e38d46549c9fba0" title="circuit_build_times\l_network_is_live" alt="" coords="237,57,368,98"/>
<area shape="rect" id="node5" href="circuitstats_8c.html#ab6607aa51a9503278d8f893f8092aabc" title="get_circuit_build_times\l_mutable" alt="" coords="225,122,380,163"/>
<area shape="rect" id="node6" href="nodelist_8c.html#af9b98a83a74416a5d6cb256c66110b1b" title="router_set_status" alt="" coords="241,188,364,215"/>
<area shape="rect" id="node7" href="channel_8c.html#a94e699a108ac50e3f7e356b336734a56" title="channel_is_client" alt="" coords="241,239,364,265"/>
<area shape="rect" id="node4" href="util_8c.html#aca03d8cb6a22d540b13b92ea5945df33" title="approx_time" alt="" coords="428,64,521,91"/>
</map>
</div>

</div>
</div>
<a id="ae2704646dbc4d5113c2160fd9842f128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2704646dbc4d5113c2160fd9842f128">&#9670;&nbsp;</a></span>channel_dump_transport_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_dump_transport_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoke transport-specific stats dump for channel.</p>
<p>If there is a lower-layer statistics dump method, invoke it. </p>

</div>
</div>
<a id="a1ef365ba78cdfea35f694be31bfd6e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef365ba78cdfea35f694be31bfd6e91">&#9670;&nbsp;</a></span>channel_dumpstats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_dumpstats </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel statistics to the log.</p>
<p>This is called from dumpstats() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a> and spams the log with statistics on channels. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a1ef365ba78cdfea35f694be31bfd6e91_cgraph.png" border="0" usemap="#channel_8c_a1ef365ba78cdfea35f694be31bfd6e91_cgraph" alt=""/></div>
<map name="channel_8c_a1ef365ba78cdfea35f694be31bfd6e91_cgraph" id="channel_8c_a1ef365ba78cdfea35f694be31bfd6e91_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="188,5,249,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a1ef365ba78cdfea35f694be31bfd6e91_icgraph.png" border="0" usemap="#channel_8c_a1ef365ba78cdfea35f694be31bfd6e91_icgraph" alt=""/></div>
<map name="channel_8c_a1ef365ba78cdfea35f694be31bfd6e91_icgraph" id="channel_8c_a1ef365ba78cdfea35f694be31bfd6e91_icgraph">
<area shape="rect" id="node2" href="fakechans_8h.html#a2cff55df4a9516484aba4c6302c9deda" title="scheduler_release_channel_mock" alt="" coords="188,5,407,32"/>
</map>
</div>

</div>
</div>
<a id="a03ce362c180c51c5018668bae7bb4f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ce362c180c51c5018668bae7bb4f24">&#9670;&nbsp;</a></span>channel_find_by_global_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_find_by_global_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>global_identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find channel by global ID.</p>
<p>This function searches for a channel by the global_identifier assigned at initialization time. This identifier is unique for the lifetime of the Tor process. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a03ce362c180c51c5018668bae7bb4f24_icgraph.png" border="0" usemap="#channel_8c_a03ce362c180c51c5018668bae7bb4f24_icgraph" alt=""/></div>
<map name="channel_8c_a03ce362c180c51c5018668bae7bb4f24_icgraph" id="channel_8c_a03ce362c180c51c5018668bae7bb4f24_icgraph">
<area shape="rect" id="node2" href="circuitmux_8h.html#a4a5fff70da3c5abf8e3ae7abd1aee1cc" title="circuitmux_set_policy" alt="" coords="228,5,376,32"/>
<area shape="rect" id="node3" href="circuitmux_8h.html#a1eefa6dc14786d08f7dcc6a9d33c11b2" title="circuitmux_clear_policy" alt="" coords="424,5,583,32"/>
</map>
</div>

</div>
</div>
<a id="a04ab9bd6d990fc6d07b0c8842a3aee71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ab9bd6d990fc6d07b0c8842a3aee71">&#9670;&nbsp;</a></span>channel_find_by_remote_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_find_by_remote_identity </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rsa_id_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>ed_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find channel by RSA/Ed25519 identity of of the remote endpoint.</p>
<p>This function looks up a channel by the digest of its remote endpoint's RSA identity key. If <b>ed_id</b> is provided and nonzero, only a channel matching the <b>ed_id</b> will be returned.</p>
<p>It's possible that more than one channel to a given endpoint exists. Use <a class="el" href="channel_8c.html#a1bb42fd943884ecec3e7a7469c4e52f3">channel_next_with_rsa_identity()</a> to walk the list of channels; make sure to test for Ed25519 identity match too (as appropriate) </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a04ab9bd6d990fc6d07b0c8842a3aee71_icgraph.png" border="0" usemap="#channel_8c_a04ab9bd6d990fc6d07b0c8842a3aee71_icgraph" alt=""/></div>
<map name="channel_8c_a04ab9bd6d990fc6d07b0c8842a3aee71_icgraph" id="channel_8c_a04ab9bd6d990fc6d07b0c8842a3aee71_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a225a9a8dab25e6fa224525867d0a056e" title="channel_get_for_extend" alt="" coords="216,13,376,39"/>
</map>
</div>

</div>
</div>
<a id="afaa138124aa840cbabbbe2065c933b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa138124aa840cbabbbe2065c933b09">&#9670;&nbsp;</a></span>channel_free_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_free_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a channel; nothing outside of <a class="el" href="channel_8c.html" title="OR/OP-to-OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ...">channel.c</a> and subclasses should call this - it frees channels after they have closed and been unregistered. </p>

</div>
</div>
<a id="adb2d84e3ecc8f662ed2072a2104d0b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2d84e3ecc8f662ed2072a2104d0b6b">&#9670;&nbsp;</a></span>channel_free_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_free_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close all channels and free everything.</p>
<p>This gets called from <a class="el" href="main_8c.html#a3d840759318fbf94fb7009cc0fba5c5d">tor_free_all()</a> in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a> to clean up on exit. It will close all registered channels and free associated storage, then free the all_channels, active_channels, listening_channels and finished_channels lists and also channel_identity_map. </p>

</div>
</div>
<a id="a3c1c9c62855d488fa17eaa4c4dd3f6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1c9c62855d488fa17eaa4c4dd3f6e5">&#9670;&nbsp;</a></span>channel_get_actual_remote_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_get_actual_remote_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the text address of the remote endpoint.</p>
<p>Subsequent calls to channel_get_{actual,canonical}_remote_{address,descr} may invalidate the return value from this function. </p>

</div>
</div>
<a id="a8608773117c50600ebe58ffc331b6b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8608773117c50600ebe58ffc331b6b3e">&#9670;&nbsp;</a></span>channel_get_actual_remote_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_get_actual_remote_descr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return text description of the remote endpoint.</p>
<p>This function return a test provided by the lower layer of the remote endpoint for this channel; it should specify the actual address connected to/from.</p>
<p>Subsequent calls to channel_get_{actual,canonical}_remote_{address,descr} may invalidate the return value from this function. </p>

</div>
</div>
<a id="a5a9a5bd1e17411b06028d4839ad6e6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a5bd1e17411b06028d4839ad6e6df">&#9670;&nbsp;</a></span>channel_get_canonical_remote_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_get_canonical_remote_descr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return text description of the remote endpoint canonical address.</p>
<p>This function return a test provided by the lower layer of the remote endpoint for this channel; it should use the known canonical address for this OR's identity digest if possible.</p>
<p>Subsequent calls to channel_get_{actual,canonical}_remote_{address,descr} may invalidate the return value from this function. </p>

</div>
</div>
<a id="a9f3b8c3a3d91967c63fea496d2fe1b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3b8c3a3d91967c63fea496d2fe1b2e">&#9670;&nbsp;</a></span>channel_get_cell_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">channel_cell_handler_fn_ptr channel_get_cell_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the fixed-length cell handler for a channel.</p>
<p>This function gets the handler for incoming fixed-length cells installed on a channel. </p>

</div>
</div>
<a id="a225a9a8dab25e6fa224525867d0a056e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225a9a8dab25e6fa224525867d0a056e">&#9670;&nbsp;</a></span>channel_get_for_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_get_for_extend </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rsa_id_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>ed_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>target_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>msg_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>launch_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a channel to extend a circuit.</p>
<p>Pick a suitable channel to extend a circuit to given the desired digest the address we believe is correct for that digest; this tries to see if we already have one for the requested endpoint, but if there is no good channel, set *msg_out to a message describing the channel's state and our next action, and set *launch_out to a boolean indicated whether the caller should try to launch a new channel with <a class="el" href="channel_8c.html#a2de1eedac60a9f05dd621bc9b07909dd">channel_connect()</a>. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a225a9a8dab25e6fa224525867d0a056e_cgraph.png" border="0" usemap="#channel_8c_a225a9a8dab25e6fa224525867d0a056e_cgraph" alt=""/></div>
<map name="channel_8c_a225a9a8dab25e6fa224525867d0a056e_cgraph" id="channel_8c_a225a9a8dab25e6fa224525867d0a056e_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a04ab9bd6d990fc6d07b0c8842a3aee71" title="channel_find_by_remote\l_identity" alt="" coords="213,5,376,47"/>
<area shape="rect" id="node3" href="channel_8c.html#a1bb42fd943884ecec3e7a7469c4e52f3" title="channel_next_with_rsa\l_identity" alt="" coords="217,71,372,112"/>
<area shape="rect" id="node4" href="di__ops_8c.html#a473334ee93cca0aea10523321a444ea3" title="tor_memeq" alt="" coords="251,137,338,163"/>
</map>
</div>

</div>
</div>
<a id="aee619f7637f1a10fec2da20ea004e998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee619f7637f1a10fec2da20ea004e998">&#9670;&nbsp;</a></span>channel_get_var_cell_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">channel_var_cell_handler_fn_ptr channel_get_var_cell_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the variable-length cell handler for a channel.</p>
<p>This function gets the handler for incoming variable-length cells installed on a channel. </p>

</div>
</div>
<a id="a02db0f9ae91b50323bd345a224d9d1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02db0f9ae91b50323bd345a224d9d1d8">&#9670;&nbsp;</a></span>channel_has_queued_writes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_has_queued_writes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff the channel has any cells on the connection outbuf waiting to be sent onto the network. </p>

</div>
</div>
<a id="af394d37fffd7367c8c882834e6451a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af394d37fffd7367c8c882834e6451a89">&#9670;&nbsp;</a></span>channel_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a channel.</p>
<p>This function should be called by subclasses to set up some per-channel variables. I.e., this is the superclass constructor. Before this, the channel should be allocated with tor_malloc_zero(). </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_af394d37fffd7367c8c882834e6451a89_cgraph.png" border="0" usemap="#channel_8c_af394d37fffd7367c8c882834e6451a89_cgraph" alt=""/></div>
<map name="channel_8c_af394d37fffd7367c8c882834e6451a89_cgraph" id="channel_8c_af394d37fffd7367c8c882834e6451a89_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a63986ced82f0d5c58fd872e40ed46598" title="channel_timestamp_created" alt="" coords="144,5,329,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_af394d37fffd7367c8c882834e6451a89_icgraph.png" border="0" usemap="#channel_8c_af394d37fffd7367c8c882834e6451a89_icgraph" alt=""/></div>
<map name="channel_8c_af394d37fffd7367c8c882834e6451a89_icgraph" id="channel_8c_af394d37fffd7367c8c882834e6451a89_icgraph">
<area shape="rect" id="node2" href="channeltls_8c.html#af1ad4a1777eab15f13e8478802ac5d5e" title="channel_tls_common_init" alt="" coords="144,5,313,32"/>
</map>
</div>

</div>
</div>
<a id="a4259678584b7e032533f1144a7412616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4259678584b7e032533f1144a7412616">&#9670;&nbsp;</a></span>channel_init_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_init_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a channel listener.</p>
<p>This function should be called by subclasses to set up some per-channel variables. I.e., this is the superclass constructor. Before this, the channel listener should be allocated with tor_malloc_zero(). </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a4259678584b7e032533f1144a7412616_cgraph.png" border="0" usemap="#channel_8c_a4259678584b7e032533f1144a7412616_cgraph" alt=""/></div>
<map name="channel_8c_a4259678584b7e032533f1144a7412616_cgraph" id="channel_8c_a4259678584b7e032533f1144a7412616_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a7c86ea4153b077173702319f0fa5b196" title="channel_listener_timestamp\l_created" alt="" coords="193,5,377,47"/>
</map>
</div>

</div>
</div>
<a id="a118d357c7f7accb2f220b000f33ea714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118d357c7f7accb2f220b000f33ea714">&#9670;&nbsp;</a></span>channel_is_bad_for_new_circs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_bad_for_new_circs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the is_bad_for_new_circs flag.</p>
<p>This function returns the is_bad_for_new_circs flag of the specified channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a118d357c7f7accb2f220b000f33ea714_icgraph.png" border="0" usemap="#channel_8c_a118d357c7f7accb2f220b000f33ea714_icgraph" alt=""/></div>
<map name="channel_8c_a118d357c7f7accb2f220b000f33ea714_icgraph" id="channel_8c_a118d357c7f7accb2f220b000f33ea714_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a098e7f8cd053cab6477b2ff9dcbd7190" title="channel_is_better" alt="" coords="188,13,312,39"/>
</map>
</div>

</div>
</div>
<a id="a098e7f8cd053cab6477b2ff9dcbd7190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098e7f8cd053cab6477b2ff9dcbd7190">&#9670;&nbsp;</a></span>channel_is_better()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_better </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decide which of two channels to prefer for extending a circuit.</p>
<p>This function is called while extending a circuit and returns true iff a is 'better' than b. The most important criterion here is that a canonical channel is always better than a non-canonical one, but the number of circuits and the age are used as tie-breakers.</p>
<p>This is based on the former connection_or_is_better() of <a class="el" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. ">connection_or.c</a> </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a098e7f8cd053cab6477b2ff9dcbd7190_cgraph.png" border="0" usemap="#channel_8c_a098e7f8cd053cab6477b2ff9dcbd7190_cgraph" alt=""/></div>
<map name="channel_8c_a098e7f8cd053cab6477b2ff9dcbd7190_cgraph" id="channel_8c_a098e7f8cd053cab6477b2ff9dcbd7190_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a118d357c7f7accb2f220b000f33ea714" title="channel_is_bad_for\l_new_circs" alt="" coords="187,5,322,47"/>
<area shape="rect" id="node3" href="channel_8c.html#a58978b931d8b11d4673287e59f8d54bc" title="channel_is_canonical" alt="" coords="181,71,328,98"/>
<area shape="rect" id="node4" href="channel_8c.html#aeff1eebb5bba0a9371c5679994d51329" title="channel_when_created" alt="" coords="177,122,332,149"/>
<area shape="rect" id="node5" href="channel_8c.html#ae541683374c3002a6218c576c9775910" title="channel_num_circuits" alt="" coords="181,173,329,199"/>
</map>
</div>

</div>
</div>
<a id="a58978b931d8b11d4673287e59f8d54bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58978b931d8b11d4673287e59f8d54bc">&#9670;&nbsp;</a></span>channel_is_canonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_canonical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the canonical flag for a channel.</p>
<p>This returns the is_canonical for a channel; this flag is determined by the lower layer and can't be set in a transport-independent way. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a58978b931d8b11d4673287e59f8d54bc_icgraph.png" border="0" usemap="#channel_8c_a58978b931d8b11d4673287e59f8d54bc_icgraph" alt=""/></div>
<map name="channel_8c_a58978b931d8b11d4673287e59f8d54bc_icgraph" id="channel_8c_a58978b931d8b11d4673287e59f8d54bc_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a098e7f8cd053cab6477b2ff9dcbd7190" title="channel_is_better" alt="" coords="200,5,324,32"/>
</map>
</div>

</div>
</div>
<a id="a2175e5e47f323e17e518474e8210907f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2175e5e47f323e17e518474e8210907f">&#9670;&nbsp;</a></span>channel_is_canonical_is_reliable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_canonical_is_reliable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if the canonical flag is reliable.</p>
<p>This function asks if the lower layer thinks it's safe to trust the result of <a class="el" href="channel_8c.html#a58978b931d8b11d4673287e59f8d54bc">channel_is_canonical()</a>. </p>

</div>
</div>
<a id="a94e699a108ac50e3f7e356b336734a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e699a108ac50e3f7e356b336734a56">&#9670;&nbsp;</a></span>channel_is_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the client flag.</p>
<p>This returns the client flag of a channel, which will be set if command_process_create_cell() in <a class="el" href="command_8c.html" title="Functions for processing incoming cells. ">command.c</a> thinks this is a connection from a client. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a94e699a108ac50e3f7e356b336734a56_icgraph.png" border="0" usemap="#channel_8c_a94e699a108ac50e3f7e356b336734a56_icgraph" alt=""/></div>
<map name="channel_8c_a94e699a108ac50e3f7e356b336734a56_icgraph" id="channel_8c_a94e699a108ac50e3f7e356b336734a56_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#a4bb9524073333e156da271ca623a772d" title="channel_do_open_actions" alt="" coords="176,5,348,32"/>
</map>
</div>

</div>
</div>
<a id="a94903f24f674c7a4dd95dd51e6b6b047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94903f24f674c7a4dd95dd51e6b6b047">&#9670;&nbsp;</a></span>channel_is_incoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_incoming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test incoming flag.</p>
<p>This function gets the incoming flag; this is set when a listener spawns a channel. If this returns true the channel was remotely initiated. </p>

</div>
</div>
<a id="ab7950c59a4fefcd76e3e3b327d86114f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7950c59a4fefcd76e3e3b327d86114f">&#9670;&nbsp;</a></span>channel_is_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test local flag.</p>
<p>This function gets the local flag; the lower layer should set this when setting up the channel if is_local_addr() is true for all of the destinations it will communicate with on behalf of this channel. It's used to decide whether to declare the network reachable when seeing incoming traffic on the channel. </p>

</div>
</div>
<a id="a150180857a5c09e9ab16095b6011fd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150180857a5c09e9ab16095b6011fd06">&#9670;&nbsp;</a></span>channel_is_outgoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_is_outgoing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test outgoing flag.</p>
<p>This function gets the outgoing flag; this is the inverse of the incoming bit set when a listener spawns a channel. If this returns true the channel was locally initiated. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a150180857a5c09e9ab16095b6011fd06_icgraph.png" border="0" usemap="#channel_8c_a150180857a5c09e9ab16095b6011fd06_icgraph" alt=""/></div>
<map name="channel_8c_a150180857a5c09e9ab16095b6011fd06_icgraph" id="channel_8c_a150180857a5c09e9ab16095b6011fd06_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#a4bb9524073333e156da271ca623a772d" title="channel_do_open_actions" alt="" coords="193,5,365,32"/>
<area shape="rect" id="node3" href="channel_8c.html#ae9d6f1fad148b483bdb8d2443dab0718" title="MOCK_IMPL" alt="" coords="229,56,329,83"/>
</map>
</div>

</div>
</div>
<a id="ad0126606a15537e0647e81a9c2ca8b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0126606a15537e0647e81a9c2ca8b74">&#9670;&nbsp;</a></span>channel_listener_change_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_change_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>to_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change channel listener state.</p>
<p>This internal and subclass use only function is used to change channel listener state, performing all transition validity checks and whatever actions are appropriate to the state transition in question. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_ad0126606a15537e0647e81a9c2ca8b74_cgraph.png" border="0" usemap="#channel_8c_ad0126606a15537e0647e81a9c2ca8b74_cgraph" alt=""/></div>
<map name="channel_8c_ad0126606a15537e0647e81a9c2ca8b74_cgraph" id="channel_8c_ad0126606a15537e0647e81a9c2ca8b74_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a5bdf98e720a6acc2e476e681e91e4fde" title="channel_listener_state\l_is_valid" alt="" coords="219,5,371,47"/>
<area shape="rect" id="node3" href="channel_8c.html#a447edc0876c6c437ae72b5c49b8e038a" title="channel_listener_state\l_can_transition" alt="" coords="219,71,371,112"/>
</map>
</div>

</div>
</div>
<a id="a0104c379fab8d5cf7dc3eddf113dc44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0104c379fab8d5cf7dc3eddf113dc44e">&#9670;&nbsp;</a></span>channel_listener_describe_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_listener_describe_transport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describe the transport subclass for a channel listener.</p>
<p>Invoke a method to get a string description of the lower-layer transport for this channel listener. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph.png" border="0" usemap="#channel_8c_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph" alt=""/></div>
<map name="channel_8c_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph" id="channel_8c_a0104c379fab8d5cf7dc3eddf113dc44e_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="225,5,380,47"/>
<area shape="rect" id="node3" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="428,13,612,39"/>
</map>
</div>

</div>
</div>
<a id="a31e2ae335dbe5af256b18df4f3c1070e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e2ae335dbe5af256b18df4f3c1070e">&#9670;&nbsp;</a></span>channel_listener_dump_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_dump_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel listener statistics.</p>
<p>Dump statistics for one channel listener to the log. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a31e2ae335dbe5af256b18df4f3c1070e_cgraph.png" border="0" usemap="#channel_8c_a31e2ae335dbe5af256b18df4f3c1070e_cgraph" alt=""/></div>
<map name="channel_8c_a31e2ae335dbe5af256b18df4f3c1070e_cgraph" id="channel_8c_a31e2ae335dbe5af256b18df4f3c1070e_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="263,5,325,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a0104c379fab8d5cf7dc3eddf113dc44e" title="channel_listener_describe\l_transport" alt="" coords="208,57,380,98"/>
<area shape="rect" id="node4" href="channel_8c.html#aee0cac4ba2733cffddc9ff59be701687" title="channel_listener_state\l_to_string" alt="" coords="218,122,370,163"/>
<area shape="rect" id="node5" href="channel_8c.html#a8193e4c4351e724edc8ecaddd09f8e10" title="channel_listener_dump\l_transport_statistics" alt="" coords="217,187,371,229"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a31e2ae335dbe5af256b18df4f3c1070e_icgraph.png" border="0" usemap="#channel_8c_a31e2ae335dbe5af256b18df4f3c1070e_icgraph" alt=""/></div>
<map name="channel_8c_a31e2ae335dbe5af256b18df4f3c1070e_icgraph" id="channel_8c_a31e2ae335dbe5af256b18df4f3c1070e_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="208,13,392,39"/>
</map>
</div>

</div>
</div>
<a id="a8193e4c4351e724edc8ecaddd09f8e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8193e4c4351e724edc8ecaddd09f8e10">&#9670;&nbsp;</a></span>channel_listener_dump_transport_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_dump_transport_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoke transport-specific stats dump for channel listener.</p>
<p>If there is a lower-layer statistics dump method, invoke it. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a8193e4c4351e724edc8ecaddd09f8e10_icgraph.png" border="0" usemap="#channel_8c_a8193e4c4351e724edc8ecaddd09f8e10_icgraph" alt=""/></div>
<map name="channel_8c_a8193e4c4351e724edc8ecaddd09f8e10_icgraph" id="channel_8c_a8193e4c4351e724edc8ecaddd09f8e10_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="208,5,363,47"/>
<area shape="rect" id="node3" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="411,13,595,39"/>
</map>
</div>

</div>
</div>
<a id="ab0519ba6c6b14de83e886ed42095fe68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0519ba6c6b14de83e886ed42095fe68">&#9670;&nbsp;</a></span>channel_listener_dumpstats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_dumpstats </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel listener statistics to the log.</p>
<p>This is called from dumpstats() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a> and spams the log with statistics on channel listeners. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_ab0519ba6c6b14de83e886ed42095fe68_cgraph.png" border="0" usemap="#channel_8c_ab0519ba6c6b14de83e886ed42095fe68_cgraph" alt=""/></div>
<map name="channel_8c_ab0519ba6c6b14de83e886ed42095fe68_cgraph" id="channel_8c_ab0519ba6c6b14de83e886ed42095fe68_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="495,5,557,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="237,57,392,98"/>
<area shape="rect" id="node4" href="channel_8c.html#a0104c379fab8d5cf7dc3eddf113dc44e" title="channel_listener_describe\l_transport" alt="" coords="440,57,612,98"/>
<area shape="rect" id="node5" href="channel_8c.html#aee0cac4ba2733cffddc9ff59be701687" title="channel_listener_state\l_to_string" alt="" coords="450,122,602,163"/>
<area shape="rect" id="node6" href="channel_8c.html#a8193e4c4351e724edc8ecaddd09f8e10" title="channel_listener_dump\l_transport_statistics" alt="" coords="449,187,603,229"/>
</map>
</div>

</div>
</div>
<a id="aa917fccb124ebe2d88705c5893875984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa917fccb124ebe2d88705c5893875984">&#9670;&nbsp;</a></span>channel_listener_free_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_free_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a channel listener; nothing outside of <a class="el" href="channel_8c.html" title="OR/OP-to-OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ...">channel.c</a> and subclasses should call this - it frees channel listeners after they have closed and been unregistered. </p>

</div>
</div>
<a id="a4d328d0eebd17c646ec3a1ff4442d827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d328d0eebd17c646ec3a1ff4442d827">&#9670;&nbsp;</a></span>channel_listener_mark_for_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_mark_for_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel listener for closure.</p>
<p>This function tries to close a channel_listener_t; it will go into the CLOSING state, and eventually the lower layer should put it into the CLOSED or ERROR state. Then, <a class="el" href="channel_8c.html#a1d874b0dd28680dd7f9661e2490d9091">channel_run_cleanup()</a> will eventually free it. </p>

</div>
</div>
<a id="a1a020ddaa5f55c078d4513c47128f263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a020ddaa5f55c078d4513c47128f263">&#9670;&nbsp;</a></span>channel_listener_process_incoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_process_incoming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process the queue of incoming channels on a listener.</p>
<p>Use a listener's registered callback to process as many entries in the queue of incoming channels as possible. </p>

</div>
</div>
<a id="a54f08cb6c0828f43f1253018f9fe3650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f08cb6c0828f43f1253018f9fe3650">&#9670;&nbsp;</a></span>channel_listener_queue_incoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_queue_incoming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>incoming</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue an incoming channel on a listener.</p>
<p>Internal and subclass use only function to queue an incoming channel from a listener. A subclass of channel_listener_t should call this when a new incoming channel is created. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a54f08cb6c0828f43f1253018f9fe3650_icgraph.png" border="0" usemap="#channel_8c_a54f08cb6c0828f43f1253018f9fe3650_icgraph" alt=""/></div>
<map name="channel_8c_a54f08cb6c0828f43f1253018f9fe3650_icgraph" id="channel_8c_a54f08cb6c0828f43f1253018f9fe3650_icgraph">
<area shape="rect" id="node2" href="connection__or_8c.html#a4b039b5bbe0c7cd361769189ce4d2238" title="MOCK_IMPL" alt="" coords="212,13,312,39"/>
</map>
</div>

</div>
</div>
<a id="a7fc659d90d9518f8f8bcf5a4d4f49acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc659d90d9518f8f8bcf5a4d4f49acb">&#9670;&nbsp;</a></span>channel_listener_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a channel listener.</p>
<p>This function registers a newly created channel listener in the global lists/maps of active channel listeners. </p>

</div>
</div>
<a id="a3e7838364ded7b78a661a1f3f2f1c266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7838364ded7b78a661a1f3f2f1c266">&#9670;&nbsp;</a></span>channel_listener_run_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_run_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up channel listeners.</p>
<p>This gets called periodically from run_scheduled_events() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a>; it cleans up after closed channel listeners. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a3e7838364ded7b78a661a1f3f2f1c266_cgraph.png" border="0" usemap="#channel_8c_a3e7838364ded7b78a661a1f3f2f1c266_cgraph" alt=""/></div>
<map name="channel_8c_a3e7838364ded7b78a661a1f3f2f1c266_cgraph" id="channel_8c_a3e7838364ded7b78a661a1f3f2f1c266_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a2d954d609b0decab6e56e2ab7e2444f6" title="channel_listener_unregister" alt="" coords="195,13,375,39"/>
</map>
</div>

</div>
</div>
<a id="a770610a2b8d7a5c3060778b63a3d4030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770610a2b8d7a5c3060778b63a3d4030">&#9670;&nbsp;</a></span>channel_listener_set_listener_fn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_set_listener_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_listener_fn_ptr&#160;</td>
          <td class="paramname"><em>listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the listener for a channel listener.</p>
<p>This function sets the handler for new incoming channels on a channel listener. </p>

</div>
</div>
<a id="a447edc0876c6c437ae72b5c49b8e038a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447edc0876c6c437ae72b5c49b8e038a">&#9670;&nbsp;</a></span>channel_listener_state_can_transition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_listener_state_can_transition </td>
          <td>(</td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a channel listener state transition is valid.</p>
<p>This function takes two channel listener states and indicates whether a transition between them is permitted (see the state definitions and transition table in <a class="el" href="or_8h.html" title="Master header file for Tor-specific functionality. ">or.h</a> at the channel_listener_state_t typedef). </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a447edc0876c6c437ae72b5c49b8e038a_icgraph.png" border="0" usemap="#channel_8c_a447edc0876c6c437ae72b5c49b8e038a_icgraph" alt=""/></div>
<map name="channel_8c_a447edc0876c6c437ae72b5c49b8e038a_icgraph" id="channel_8c_a447edc0876c6c437ae72b5c49b8e038a_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ad0126606a15537e0647e81a9c2ca8b74" title="channel_listener_change\l_state" alt="" coords="205,5,371,47"/>
</map>
</div>

</div>
</div>
<a id="a5bdf98e720a6acc2e476e681e91e4fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdf98e720a6acc2e476e681e91e4fde">&#9670;&nbsp;</a></span>channel_listener_state_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_listener_state_is_valid </td>
          <td>(</td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a given channel listener state is valid. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a5bdf98e720a6acc2e476e681e91e4fde_icgraph.png" border="0" usemap="#channel_8c_a5bdf98e720a6acc2e476e681e91e4fde_icgraph" alt=""/></div>
<map name="channel_8c_a5bdf98e720a6acc2e476e681e91e4fde_icgraph" id="channel_8c_a5bdf98e720a6acc2e476e681e91e4fde_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ad0126606a15537e0647e81a9c2ca8b74" title="channel_listener_change\l_state" alt="" coords="205,5,371,47"/>
</map>
</div>

</div>
</div>
<a id="aee0cac4ba2733cffddc9ff59be701687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0cac4ba2733cffddc9ff59be701687">&#9670;&nbsp;</a></span>channel_listener_state_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_listener_state_to_string </td>
          <td>(</td>
          <td class="paramtype">channel_listener_state_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a human-readable description for a channel listener state. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_aee0cac4ba2733cffddc9ff59be701687_icgraph.png" border="0" usemap="#channel_8c_aee0cac4ba2733cffddc9ff59be701687_icgraph" alt=""/></div>
<map name="channel_8c_aee0cac4ba2733cffddc9ff59be701687_icgraph" id="channel_8c_aee0cac4ba2733cffddc9ff59be701687_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a31e2ae335dbe5af256b18df4f3c1070e" title="channel_listener_dump\l_statistics" alt="" coords="205,5,360,47"/>
<area shape="rect" id="node3" href="channel_8h.html#ab0519ba6c6b14de83e886ed42095fe68" title="channel_listener_dumpstats" alt="" coords="408,13,592,39"/>
</map>
</div>

</div>
</div>
<a id="abc3b198fd2e78a28eda3228892847baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3b198fd2e78a28eda3228892847baa">&#9670;&nbsp;</a></span>channel_listener_timestamp_accepted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_timestamp_accepted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the last accepted timestamp.</p>
<p>This function updates the channel listener's last accepted timestamp; it should be called whenever a new incoming channel is accepted on a listener. </p>

</div>
</div>
<a id="a7ccf1c1d0d34e84bb663fea0426051b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccf1c1d0d34e84bb663fea0426051b5">&#9670;&nbsp;</a></span>channel_listener_timestamp_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_timestamp_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the last active timestamp for a channel listener. </p>

</div>
</div>
<a id="a7c86ea4153b077173702319f0fa5b196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c86ea4153b077173702319f0fa5b196">&#9670;&nbsp;</a></span>channel_listener_timestamp_created()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_timestamp_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the created timestamp for a channel listener.</p>
<p>This updates the channel listener's created timestamp and should only be called from <a class="el" href="channel_8c.html#a4259678584b7e032533f1144a7412616">channel_init_listener()</a>. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a7c86ea4153b077173702319f0fa5b196_icgraph.png" border="0" usemap="#channel_8c_a7c86ea4153b077173702319f0fa5b196_icgraph" alt=""/></div>
<map name="channel_8c_a7c86ea4153b077173702319f0fa5b196_icgraph" id="channel_8c_a7c86ea4153b077173702319f0fa5b196_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#a4259678584b7e032533f1144a7412616" title="channel_init_listener" alt="" coords="237,13,377,39"/>
</map>
</div>

</div>
</div>
<a id="a2d954d609b0decab6e56e2ab7e2444f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d954d609b0decab6e56e2ab7e2444f6">&#9670;&nbsp;</a></span>channel_listener_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_listener_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__listener__s.html">channel_listener_t</a> *&#160;</td>
          <td class="paramname"><em>chan_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a channel listener.</p>
<p>This function removes a channel listener from the global lists and maps and is used when freeing a closed/errored channel listener. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a2d954d609b0decab6e56e2ab7e2444f6_icgraph.png" border="0" usemap="#channel_8c_a2d954d609b0decab6e56e2ab7e2444f6_icgraph" alt=""/></div>
<map name="channel_8c_a2d954d609b0decab6e56e2ab7e2444f6_icgraph" id="channel_8c_a2d954d609b0decab6e56e2ab7e2444f6_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a3e7838364ded7b78a661a1f3f2f1c266" title="channel_listener_run\l_cleanup" alt="" coords="233,5,375,47"/>
</map>
</div>

</div>
</div>
<a id="a93b61336ba7b19572a83d335a6aad65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b61336ba7b19572a83d335a6aad65f">&#9670;&nbsp;</a></span>channel_mark_bad_for_new_circs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_bad_for_new_circs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel as bad for new circuits.</p>
<p>Set the is_bad_for_new_circs_flag on chan. </p>

</div>
</div>
<a id="a3ad8f3da9b53f2a239196da6a822420a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad8f3da9b53f2a239196da6a822420a">&#9670;&nbsp;</a></span>channel_mark_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the client flag.</p>
<p>Mark a channel as being from a client. </p>

</div>
</div>
<a id="ac5c51ad12ff89e0f63cc386ccda8493f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c51ad12ff89e0f63cc386ccda8493f">&#9670;&nbsp;</a></span>channel_mark_for_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_for_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel for closure.</p>
<p>This function tries to close a channel_t; it will go into the CLOSING state, and eventually the lower layer should put it into the CLOSED or ERROR state. Then, <a class="el" href="channel_8c.html#a1d874b0dd28680dd7f9661e2490d9091">channel_run_cleanup()</a> will eventually free it. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_ac5c51ad12ff89e0f63cc386ccda8493f_icgraph.png" border="0" usemap="#channel_8c_ac5c51ad12ff89e0f63cc386ccda8493f_icgraph" alt=""/></div>
<map name="channel_8c_ac5c51ad12ff89e0f63cc386ccda8493f_icgraph" id="channel_8c_ac5c51ad12ff89e0f63cc386ccda8493f_icgraph">
<area shape="rect" id="node2" href="fakechans_8h.html#a2cff55df4a9516484aba4c6302c9deda" title="scheduler_release_channel_mock" alt="" coords="216,5,435,32"/>
</map>
</div>

</div>
</div>
<a id="a40184005ca97cc8b3e70ac3a82b9d1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40184005ca97cc8b3e70ac3a82b9d1fa">&#9670;&nbsp;</a></span>channel_mark_incoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_incoming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the incoming flag.</p>
<p>This function is called when a channel arrives on a listening channel to mark it as incoming. </p>

</div>
</div>
<a id="a366226ae4d3bca86afd5eff78e61cc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366226ae4d3bca86afd5eff78e61cc27">&#9670;&nbsp;</a></span>channel_mark_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_local </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the local flag.</p>
<p>This internal-only function should be called by the lower layer if the channel is to a local address. See <a class="el" href="channel_8c.html#ab7950c59a4fefcd76e3e3b327d86114f">channel_is_local()</a> above or the description of the is_local bit in <a class="el" href="channel_8h.html" title="Header file for channel.c. ">channel.h</a>. </p>

</div>
</div>
<a id="ad513e8317c2960176b7a646bb675b2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad513e8317c2960176b7a646bb675b2e9">&#9670;&nbsp;</a></span>channel_mark_outgoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_outgoing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel as outgoing.</p>
<p>This function clears the incoming flag and thus marks a channel as outgoing. </p>

</div>
</div>
<a id="a9a9d0a934832b0444951a374a78025cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9d0a934832b0444951a374a78025cb">&#9670;&nbsp;</a></span>channel_mark_remote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_mark_remote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a channel as remote.</p>
<p>This internal-only function should be called by the lower layer if the channel is not to a local address but has previously been marked local. See <a class="el" href="channel_8c.html#ab7950c59a4fefcd76e3e3b327d86114f">channel_is_local()</a> above or the description of the is_local bit in <a class="el" href="channel_8h.html" title="Header file for channel.c. ">channel.h</a> </p>

</div>
</div>
<a id="a6cb4f4e8f649a753d3d22fb84653c05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb4f4e8f649a753d3d22fb84653c05b">&#9670;&nbsp;</a></span>channel_matches_extend_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_matches_extend_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structextend__info__t.html">extend_info_t</a> *&#160;</td>
          <td class="paramname"><em>extend_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a channel matches an <a class="el" href="structextend__info__t.html">extend_info_t</a>.</p>
<p>This function calls the lower layer and asks if this channel matches a given <a class="el" href="structextend__info__t.html">extend_info_t</a>. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph.png" border="0" usemap="#channel_8c_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph" alt=""/></div>
<map name="channel_8c_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph" id="channel_8c_a6cb4f4e8f649a753d3d22fb84653c05b_icgraph">
<area shape="rect" id="node2" href="circuitlist_8h.html#aaef0c4aefe50f0432478e21e51814a34" title="circuit_get_all_pending\l_on_channel" alt="" coords="252,35,407,76"/>
<area shape="rect" id="node3" href="circuitlist_8h.html#aa797a036ce04a0d14f669e656ec62408" title="circuit_count_pending\l_on_channel" alt="" coords="462,5,610,47"/>
<area shape="rect" id="node4" href="entrynodes_8h.html#a0e486d12b1fae8b40a392567b676a083" title="entry_guard_chan_failed" alt="" coords="455,71,617,98"/>
</map>
</div>

</div>
</div>
<a id="ae9744cd45d925184288dc3751fc1d455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9744cd45d925184288dc3751fc1d455">&#9670;&nbsp;</a></span>channel_matches_target_addr_for_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_matches_target_addr_for_extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a channel matches a given target address; return true iff we do.</p>
<p>This function calls into the lower layer and asks if this channel thinks it matches a given target address for circuit extension purposes. </p>

</div>
</div>
<a id="a1bb42fd943884ecec3e7a7469c4e52f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb42fd943884ecec3e7a7469c4e52f3">&#9670;&nbsp;</a></span>channel_next_with_rsa_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structchannel__s.html">channel_t</a>* channel_next_with_rsa_identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get next channel with digest.</p>
<p>This function takes a channel and finds the next channel in the list with the same digest. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a1bb42fd943884ecec3e7a7469c4e52f3_icgraph.png" border="0" usemap="#channel_8c_a1bb42fd943884ecec3e7a7469c4e52f3_icgraph" alt=""/></div>
<map name="channel_8c_a1bb42fd943884ecec3e7a7469c4e52f3_icgraph" id="channel_8c_a1bb42fd943884ecec3e7a7469c4e52f3_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a225a9a8dab25e6fa224525867d0a056e" title="channel_get_for_extend" alt="" coords="208,13,368,39"/>
</map>
</div>

</div>
</div>
<a id="abc5a904f9dc44b21911ceed8d18fd218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5a904f9dc44b21911ceed8d18fd218">&#9670;&nbsp;</a></span>channel_notify_flushed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_notify_flushed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify the channel we're done flushing the output in the lower layer.</p>
<p><a class="el" href="connection_8c.html" title="General high-level functions to handle reading and writing on connections. ">Connection.c</a> will call this when we've flushed the output; there's some dirreq-related maintenance to do. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_abc5a904f9dc44b21911ceed8d18fd218_cgraph.png" border="0" usemap="#channel_8c_abc5a904f9dc44b21911ceed8d18fd218_cgraph" alt=""/></div>
<map name="channel_8c_abc5a904f9dc44b21911ceed8d18fd218_cgraph" id="channel_8c_abc5a904f9dc44b21911ceed8d18fd218_cgraph">
<area shape="rect" id="node2" href="geoip_8c.html#a2a34cf4b056ecac0418dcc5927b03bb6" title="geoip_change_dirreq\l_state" alt="" coords="208,5,349,47"/>
</map>
</div>

</div>
</div>
<a id="abcbcbfef4049d88a2975b9cf4ca71645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbcbfef4049d88a2975b9cf4ca71645">&#9670;&nbsp;</a></span>channel_num_cells_writeable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_num_cells_writeable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the number of writeable cells.</p>
<p>Ask the lower layer for an estimate of how many cells it can accept. </p>

</div>
</div>
<a id="ae541683374c3002a6218c576c9775910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae541683374c3002a6218c576c9775910">&#9670;&nbsp;</a></span>channel_num_circuits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int channel_num_circuits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of circuits used by a channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>Channel to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of circuits using this as n_chan or p_chan </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_ae541683374c3002a6218c576c9775910_icgraph.png" border="0" usemap="#channel_8c_ae541683374c3002a6218c576c9775910_icgraph" alt=""/></div>
<map name="channel_8c_ae541683374c3002a6218c576c9775910_icgraph" id="channel_8c_ae541683374c3002a6218c576c9775910_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a098e7f8cd053cab6477b2ff9dcbd7190" title="channel_is_better" alt="" coords="201,5,325,32"/>
<area shape="rect" id="node3" href="connection__or_8c.html#a91065ac60ede0c2ccdaf7d2ff4892d5d" title="MOCK_IMPL" alt="" coords="213,56,313,83"/>
</map>
</div>

</div>
</div>
<a id="a4ee1b816cf17de95ff399e365f1725bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee1b816cf17de95ff399e365f1725bd">&#9670;&nbsp;</a></span>channel_process_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_process_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a cell from the given channel. </p>

</div>
</div>
<a id="a7becc4cc5e7dd116f44f86a1b826dc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7becc4cc5e7dd116f44f86a1b826dc9a">&#9670;&nbsp;</a></span>channel_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a channel.</p>
<p>This function registers a newly created channel in the global lists/maps of active channels. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a7becc4cc5e7dd116f44f86a1b826dc9a_icgraph.png" border="0" usemap="#channel_8c_a7becc4cc5e7dd116f44f86a1b826dc9a_icgraph" alt=""/></div>
<map name="channel_8c_a7becc4cc5e7dd116f44f86a1b826dc9a_icgraph" id="channel_8c_a7becc4cc5e7dd116f44f86a1b826dc9a_icgraph">
<area shape="rect" id="node2" href="fakechans_8h.html#a2cff55df4a9516484aba4c6302c9deda" title="scheduler_release_channel_mock" alt="" coords="171,5,389,32"/>
</map>
</div>

</div>
</div>
<a id="a1d874b0dd28680dd7f9661e2490d9091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d874b0dd28680dd7f9661e2490d9091">&#9670;&nbsp;</a></span>channel_run_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_run_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up channels.</p>
<p>This gets called periodically from run_scheduled_events() in <a class="el" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop...">main.c</a>; it cleans up after closed channels. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a1d874b0dd28680dd7f9661e2490d9091_cgraph.png" border="0" usemap="#channel_8c_a1d874b0dd28680dd7f9661e2490d9091_cgraph" alt=""/></div>
<map name="channel_8c_a1d874b0dd28680dd7f9661e2490d9091_cgraph" id="channel_8c_a1d874b0dd28680dd7f9661e2490d9091_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a9bbc6210c258ddbc944e9f0d6d386b45" title="channel_unregister" alt="" coords="197,5,328,32"/>
</map>
</div>

</div>
</div>
<a id="a85e3e2de528821cdda969fba6de1e4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e3e2de528821cdda969fba6de1e4f2">&#9670;&nbsp;</a></span>channel_send_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_send_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a>&#160;</td>
          <td class="paramname"><em>circ_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send destroy cell on a channel.</p>
<p>Write a destroy cell with circ ID <b>circ_id</b> and reason <b>reason</b> onto channel <b>chan</b>. Don't perform range-checking on reason: we may want to propagate reasons from other cells. </p>

</div>
</div>
<a id="a5c26cbf4843fb4609f3f0c1eee87498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c26cbf4843fb4609f3f0c1eee87498c">&#9670;&nbsp;</a></span>channel_set_cell_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_set_cell_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_cell_handler_fn_ptr&#160;</td>
          <td class="paramname"><em>cell_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_var_cell_handler_fn_ptr&#160;</td>
          <td class="paramname"><em>var_cell_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set both cell handlers for a channel.</p>
<p>This function sets both the fixed-length and variable length cell handlers for a channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph.png" border="0" usemap="#channel_8c_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph" alt=""/></div>
<map name="channel_8c_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph" id="channel_8c_a5c26cbf4843fb4609f3f0c1eee87498c_icgraph">
<area shape="rect" id="node2" href="command_8h.html#ad5d1278e8abe0ae9ca6ff9d04bed82f2" title="command_setup_channel" alt="" coords="228,5,399,32"/>
</map>
</div>

</div>
</div>
<a id="a232c3afb3714be50f965df83b2d2d40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232c3afb3714be50f965df83b2d2d40d">&#9670;&nbsp;</a></span>channel_set_identity_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_set_identity_digest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>identity_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structed25519__public__key__t.html">ed25519_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>ed_identity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the identity_digest of a channel.</p>
<p>This function sets the identity digest of the remote endpoint for a channel; this is intended for use by the lower layer. </p>

</div>
</div>
<a id="a727f5f4b03dca7d9b0ef71842709c055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727f5f4b03dca7d9b0ef71842709c055">&#9670;&nbsp;</a></span>channel_state_can_transition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_state_can_transition </td>
          <td>(</td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a channel state transition is valid.</p>
<p>This function takes two channel states and indicates whether a transition between them is permitted (see the state definitions and transition table in <a class="el" href="or_8h.html" title="Master header file for Tor-specific functionality. ">or.h</a> at the channel_state_t typedef). </p>

</div>
</div>
<a id="ac5368fc8c3c7f7b0ce1020927961c92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5368fc8c3c7f7b0ce1020927961c92a">&#9670;&nbsp;</a></span>channel_state_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* channel_state_to_string </td>
          <td>(</td>
          <td class="paramtype">channel_state_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a human-readable description for a channel state. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph.png" border="0" usemap="#channel_8c_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph" alt=""/></div>
<map name="channel_8c_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph" id="channel_8c_ac5368fc8c3c7f7b0ce1020927961c92a_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ab56dc7ecc8a31e8bfa4dc5281b72c21e" title="MOCK_IMPL" alt="" coords="213,5,313,32"/>
</map>
</div>

</div>
</div>
<a id="a08dea4276de8427cb789cda94be8eea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dea4276de8427cb789cda94be8eea7">&#9670;&nbsp;</a></span>channel_timestamp_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_timestamp_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the last active timestamp for a channel.</p>
<p>This function updates the channel's last active timestamp; it should be called by the lower layer whenever there is activity on the channel which does not lead to a cell being transmitted or received; the active timestamp is also updated from <a class="el" href="channel_8c.html#a1cc7e87f9acbb2d5954540f997cf0b57">channel_timestamp_recv()</a> and <a class="el" href="channel_8c.html#abdbe03d1c68e1ebc7133e4195fbfca29">channel_timestamp_xmit()</a>, but it should be updated for things like the v3 handshake and stuff that produce activity only visible to the lower layer. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a08dea4276de8427cb789cda94be8eea7_icgraph.png" border="0" usemap="#channel_8c_a08dea4276de8427cb789cda94be8eea7_icgraph" alt=""/></div>
<map name="channel_8c_a08dea4276de8427cb789cda94be8eea7_icgraph" id="channel_8c_a08dea4276de8427cb789cda94be8eea7_icgraph">
<area shape="rect" id="node2" href="connection__or_8h.html#a8e6891862efd73402fed97a4353b2b24" title="connection_or_flushed_some" alt="" coords="231,5,421,32"/>
</map>
</div>

</div>
</div>
<a id="a20cdde3933fc1ca5c83494d1fb0e684f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cdde3933fc1ca5c83494d1fb0e684f">&#9670;&nbsp;</a></span>channel_timestamp_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_timestamp_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update client timestamp.</p>
<p>This function is called by <a class="el" href="relay_8c.html" title="Handle relay cell encryption/decryption, plus packaging and receiving from circuits, plus queuing on circuits. ">relay.c</a> to timestamp a channel that appears to be used as a client. </p>

</div>
</div>
<a id="a63986ced82f0d5c58fd872e40ed46598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63986ced82f0d5c58fd872e40ed46598">&#9670;&nbsp;</a></span>channel_timestamp_created()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_timestamp_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the created timestamp for a channel.</p>
<p>This updates the channel's created timestamp and should only be called from <a class="el" href="channel_8c.html#af394d37fffd7367c8c882834e6451a89">channel_init()</a>. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a63986ced82f0d5c58fd872e40ed46598_icgraph.png" border="0" usemap="#channel_8c_a63986ced82f0d5c58fd872e40ed46598_icgraph" alt=""/></div>
<map name="channel_8c_a63986ced82f0d5c58fd872e40ed46598_icgraph" id="channel_8c_a63986ced82f0d5c58fd872e40ed46598_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#af394d37fffd7367c8c882834e6451a89" title="channel_init" alt="" coords="239,5,329,32"/>
<area shape="rect" id="node3" href="channeltls_8c.html#af1ad4a1777eab15f13e8478802ac5d5e" title="channel_tls_common_init" alt="" coords="377,5,547,32"/>
</map>
</div>

</div>
</div>
<a id="a1cc7e87f9acbb2d5954540f997cf0b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc7e87f9acbb2d5954540f997cf0b57">&#9670;&nbsp;</a></span>channel_timestamp_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_timestamp_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the recv timestamp.</p>
<p>This is called whenever we get an incoming cell from the lower layer. This also updates the active timestamp. </p>

</div>
</div>
<a id="abdbe03d1c68e1ebc7133e4195fbfca29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbe03d1c68e1ebc7133e4195fbfca29">&#9670;&nbsp;</a></span>channel_timestamp_xmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_timestamp_xmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the xmit timestamp.</p>
<p>This is called whenever we pass an outgoing cell to the lower layer. This also updates the active timestamp. </p>

</div>
</div>
<a id="a9bbc6210c258ddbc944e9f0d6d386b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbc6210c258ddbc944e9f0d6d386b45">&#9670;&nbsp;</a></span>channel_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a channel.</p>
<p>This function removes a channel from the global lists and maps and is used when freeing a closed/errored channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a9bbc6210c258ddbc944e9f0d6d386b45_icgraph.png" border="0" usemap="#channel_8c_a9bbc6210c258ddbc944e9f0d6d386b45_icgraph" alt=""/></div>
<map name="channel_8c_a9bbc6210c258ddbc944e9f0d6d386b45_icgraph" id="channel_8c_a9bbc6210c258ddbc944e9f0d6d386b45_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a1d874b0dd28680dd7f9661e2490d9091" title="channel_run_cleanup" alt="" coords="184,5,328,32"/>
</map>
</div>

</div>
</div>
<a id="a1e4bd42593d0df3646e947bf4661648f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4bd42593d0df3646e947bf4661648f">&#9670;&nbsp;</a></span>channel_update_bad_for_new_circs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void channel_update_bad_for_new_circs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Go through all the channels (or if <b>digest</b> is non-NULL, just the OR connections with that digest), and set the is_bad_for_new_circs flag based on the rules in connection_or_group_set_badness() (or just always set it if <b>force</b> is true). </p>

</div>
</div>
<a id="aeff1eebb5bba0a9371c5679994d51329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff1eebb5bba0a9371c5679994d51329">&#9670;&nbsp;</a></span>channel_when_created()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query created timestamp for a channel. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_aeff1eebb5bba0a9371c5679994d51329_icgraph.png" border="0" usemap="#channel_8c_aeff1eebb5bba0a9371c5679994d51329_icgraph" alt=""/></div>
<map name="channel_8c_aeff1eebb5bba0a9371c5679994d51329_icgraph" id="channel_8c_aeff1eebb5bba0a9371c5679994d51329_icgraph">
<area shape="rect" id="node2" href="channel_8h.html#a098e7f8cd053cab6477b2ff9dcbd7190" title="channel_is_better" alt="" coords="208,5,332,32"/>
</map>
</div>

</div>
</div>
<a id="a7c7c9bb52317ac2f0189a286108bdc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7c9bb52317ac2f0189a286108bdc7e">&#9670;&nbsp;</a></span>channel_when_last_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_last_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query client timestamp. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph.png" border="0" usemap="#channel_8c_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph" alt=""/></div>
<map name="channel_8c_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph" id="channel_8c_a7c7c9bb52317ac2f0189a286108bdc7e_icgraph">
<area shape="rect" id="node2" href="connection__or_8h.html#a28d99e23c45ae40c245a0474ef4cfb98" title="connection_or_client_used" alt="" coords="224,5,400,32"/>
</map>
</div>

</div>
</div>
<a id="a3ce5cc93d2f7a10ad18300c4049108ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce5cc93d2f7a10ad18300c4049108ef">&#9670;&nbsp;</a></span>channel_when_last_xmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t channel_when_last_xmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query xmit timestamp. </p>

</div>
</div>
<a id="aea762ac9b96570c55daa5dd57c95eafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea762ac9b96570c55daa5dd57c95eafa">&#9670;&nbsp;</a></span>channel_write_packed_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channel_write_packed_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a packed cell to a channel.</p>
<p>Write a packed cell to a channel using the write_cell() method. This is called by the transport-independent code to deliver a packed cell to a channel for transmission.</p>
<p>Return 0 on success else a negative value. In both cases, the caller should not access the cell anymore, it is freed both on success and error. </p>

</div>
</div>
<a id="ad47201fb54e0db44f552c018d59e535d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47201fb54e0db44f552c018d59e535d">&#9670;&nbsp;</a></span>HT_PROTOTYPE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HT_PROTOTYPE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate whether a given channel state is valid. </p>

</div>
</div>
<a id="ae9de3211fa3b2007ca0f42e9022dc800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9de3211fa3b2007ca0f42e9022dc800">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_flush_some_cells&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(<a class="el" href="structchannel__s.html">channel_t</a> *chan, ssize_t num_cells)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to flush cells of the given channel chan up to a maximum of num_cells.</p>
<p>This is called by the scheduler when it wants to flush cells from the channel's circuit queue(s) to the connection outbuf (not yet on the wire).</p>
<p>If the channel is not in state CHANNEL_STATE_OPEN, this does nothing and will return 0 meaning no cells were flushed.</p>
<p>If num_cells is -1, we'll try to flush up to the maximum cells allowed defined in MAX_CELLS_TO_GET_FROM_CIRCUITS_FOR_UNLIMITED.</p>
<p>On success, the number of flushed cells are returned and it can never be above num_cells. If 0 is returned, no cells were flushed either because the channel was not opened or we had no cells on the channel. A negative number can NOT be sent back.</p>
<p>This function is part of the fast path. </p>

</div>
</div>
<a id="a4c8cfb44344a590f1ac113dfd415b02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8cfb44344a590f1ac113dfd415b02f">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_more_to_flush&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(<a class="el" href="structchannel__s.html">channel_t</a> *chan)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if any cells are available.</p>
<p>This is used by the scheduler to know if the channel has more to flush after a scheduling round. </p>

</div>
</div>
<a id="ab56dc7ecc8a31e8bfa4dc5281b72c21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56dc7ecc8a31e8bfa4dc5281b72c21e">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_dump_statistics&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(<a class="el" href="structchannel__s.html">channel_t</a> *chan, int severity)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump channel statistics.</p>
<p>Dump statistics for one channel to the log. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_ab56dc7ecc8a31e8bfa4dc5281b72c21e_cgraph.png" border="0" usemap="#channel_8c_ab56dc7ecc8a31e8bfa4dc5281b72c21e_cgraph" alt=""/></div>
<map name="channel_8c_ab56dc7ecc8a31e8bfa4dc5281b72c21e_cgraph" id="channel_8c_ab56dc7ecc8a31e8bfa4dc5281b72c21e_cgraph">
<area shape="rect" id="node2" href="log_8c.html#a048192107dfd3f8f22b9e599e45d0b34" title="tor_log" alt="" coords="213,5,275,32"/>
<area shape="rect" id="node3" href="channel_8c.html#a185d59ac3e69ab26d2b71804cb882993" title="channel_describe_transport" alt="" coords="153,56,335,83"/>
<area shape="rect" id="node4" href="channel_8c.html#ac5368fc8c3c7f7b0ce1020927961c92a" title="channel_state_to_string" alt="" coords="164,107,324,133"/>
<area shape="rect" id="node5" href="util_8c.html#add0703747195c2abd042572426e80266" title="tor_digest_is_zero" alt="" coords="180,157,308,184"/>
<area shape="rect" id="node7" href="util_8c.html#a17effd59ed2f9bf4cfebb12e423ded7f" title="hex_str" alt="" coords="211,208,277,235"/>
<area shape="rect" id="node6" href="di__ops_8c.html#a473334ee93cca0aea10523321a444ea3" title="tor_memeq" alt="" coords="396,157,483,184"/>
<area shape="rect" id="node8" href="util__format_8c.html#a8b8940b2ef607928eb3dca4850567ea5" title="base16_encode" alt="" coords="383,208,496,235"/>
</map>
</div>

</div>
</div>
<a id="a026e3719d86173650d21c6f28124514e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026e3719d86173650d21c6f28124514e">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_get_addr_if_possible&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr_out)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get remote address if possible.</p>
<p>Write the remote address out to a <a class="el" href="structtor__addr__t.html">tor_addr_t</a> if the underlying transport supports this operation, and return 1. Return 0 if the underlying transport doesn't let us do this. </p>

</div>
</div>
<a id="ae9d6f1fad148b483bdb8d2443dab0718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d6f1fad148b483bdb8d2443dab0718">&#9670;&nbsp;</a></span>MOCK_IMPL() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MOCK_IMPL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_set_circid_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">(<a class="el" href="structchannel__s.html">channel_t</a> *chan, <a class="el" href="structcrypto__pk__t.html">crypto_pk_t</a> *identity_rcvd, int consider_identity)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up circuit ID generation.</p>
<p>This is called when setting up a channel and replaces the old connection_or_set_circid_type(). </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="channel_8c_ae9d6f1fad148b483bdb8d2443dab0718_cgraph.png" border="0" usemap="#channel_8c_ae9d6f1fad148b483bdb8d2443dab0718_cgraph" alt=""/></div>
<map name="channel_8c_ae9d6f1fad148b483bdb8d2443dab0718_cgraph" id="channel_8c_ae9d6f1fad148b483bdb8d2443dab0718_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a150180857a5c09e9ab16095b6011fd06" title="channel_is_outgoing" alt="" coords="168,5,308,32"/>
<area shape="rect" id="node3" href="router_8c.html#aef981f743b968779701f12f26922d523" title="get_tlsclient_identity_key" alt="" coords="153,56,323,83"/>
<area shape="rect" id="node4" href="router_8c.html#a8fb30f05264b37bff37fe8824b4d854b" title="get_server_identity_key" alt="" coords="158,107,318,133"/>
<area shape="rect" id="node5" href="crypto__rsa_8c.html#a46a418431f50aacae8a7392edcbb1d2b" title="crypto_pk_cmp_keys" alt="" coords="165,157,311,184"/>
<area shape="rect" id="node6" href="di__ops_8c.html#a47393c6ace65b9b2173d60ac6ae119aa" title="tor_memcmp" alt="" coords="371,157,469,184"/>
</map>
</div>

</div>
</div>
<a id="aa036957ef1d90c086c403814da8de52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa036957ef1d90c086c403814da8de52f">&#9670;&nbsp;</a></span>packed_cell_is_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int packed_cell_is_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__s.html">channel_t</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *&#160;</td>
          <td class="paramname"><em>packed_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="or_8h.html#a6607d3e1cd2b5deca02212435116a2ac">circid_t</a> *&#160;</td>
          <td class="paramname"><em>circid_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <b>packed_cell</b> on <b>chan</b> is a destroy cell, then set *<b>circid_out</b> to its circuit ID, and return true. Otherwise, return false. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
