<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: /home/user/_my/code/bwauth-related/tor/src/or/connection_or.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97b64286d42c5ef1697cb5f17129db19.html">tor</a></li><li class="navelem"><a class="el" href="dir_3cb0ba3f4b82dbe34a1a06276e96bc8d.html">src</a></li><li class="navelem"><a class="el" href="dir_386635fabd7f6c74e9d9c7a8604514a0.html">or</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">connection_or.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for <a class="el" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. ">connection_or.c</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h__dep__incl.png" border="0" usemap="#_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__or_8hdep" alt=""/></div>
<map name="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__or_8hdep" id="_2home_2user_2__my_2code_2bwauth-related_2tor_2src_2or_2connection__or_8hdep">
<area shape="rect" id="node2" href="buffers_8c.html" title="Implements a generic buffer interface. " alt="" coords="5,109,153,165"/>
<area shape="rect" id="node3" href="channel_8c.html" title="OR/OP&#45;to&#45;OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ..." alt="" coords="177,109,325,165"/>
<area shape="rect" id="node4" href="channeltls_8c.html" title="A concrete subclass of channel_t using or_connection_t to transfer cells between Tor instances..." alt="" coords="349,109,497,165"/>
<area shape="rect" id="node5" href="circuitbuild_8c.html" title="Implements the details of building circuits (by chosing paths, constructing/sending create/extend cel..." alt="" coords="521,109,669,165"/>
<area shape="rect" id="node6" href="circuitlist_8c.html" title="Manage the global circuit list, and looking up circuits within it. " alt="" coords="693,109,841,165"/>
<area shape="rect" id="node7" href="command_8c.html" title="Functions for processing incoming cells. " alt="" coords="865,109,1013,165"/>
<area shape="rect" id="node8" href="config_8c.html" title="Code to parse and interpret configuration files. " alt="" coords="1037,109,1185,165"/>
<area shape="rect" id="node9" href="connection_8c.html" title="General high&#45;level functions to handle reading and writing on connections. " alt="" coords="1209,109,1357,165"/>
<area shape="rect" id="node10" href="connection__edge_8c.html" title="Handle edge streams. " alt="" coords="1381,109,1553,165"/>
<area shape="rect" id="node11" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. " alt="" coords="1578,109,1733,165"/>
<area shape="rect" id="node12" href="control_8c.html" title="Implementation for Tor&#39;s control&#45;socket interface. " alt="" coords="1757,109,1905,165"/>
<area shape="rect" id="node13" href="cpuworker_8c.html" title="Uses the workqueue/threadpool code to farm CPU&#45;intensive activities out to subprocesses. " alt="" coords="1929,109,2077,165"/>
<area shape="rect" id="node14" href="dirserv_8c.html" title="Directory server core implementation. Manages directory contents and generates directories. " alt="" coords="2101,109,2249,165"/>
<area shape="rect" id="node15" href="entrynodes_8c.html" title="Code to manage our fixed first nodes for various functions. " alt="" coords="2273,109,2421,165"/>
<area shape="rect" id="node16" href="ext__orport_8c.html" title="Code implementing the Extended ORPort. " alt="" coords="2445,109,2593,165"/>
<area shape="rect" id="node17" href="main_8c.html" title="Toplevel module. Handles signals, multiplexes between connections, implements main loop..." alt="" coords="2617,109,2765,165"/>
<area shape="rect" id="node18" href="networkstatus_8c.html" title="Functions and structures for handling network status documents as a client or cache. " alt="" coords="2789,109,2945,165"/>
<area shape="rect" id="node19" href="relay_8c.html" title="Handle relay cell encryption/decryption, plus packaging and receiving from circuits, plus queuing on circuits. " alt="" coords="2969,109,3117,165"/>
<area shape="rect" id="node20" href="transports_8c.html" title="Pluggable Transports related code. " alt="" coords="3141,109,3289,165"/>
</map>
</div>
</div>
<p><a href="connection__or_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a991da1884c1df8d35b5cfbe754ef54e3"><td class="memItemLeft" align="right" valign="top"><a id="a991da1884c1df8d35b5cfbe754ef54e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN_LINK_PROTO_FOR_WIDE_CIRC_IDS</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a991da1884c1df8d35b5cfbe754ef54e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af2d555975120054c38db70b91234678c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#af2d555975120054c38db70b91234678c">connection_or_remove_from_identity_map</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:af2d555975120054c38db70b91234678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af395c50f9f998656fe273222574dadeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#af395c50f9f998656fe273222574dadeb">connection_or_clear_identity_map</a> (void)</td></tr>
<tr class="separator:af395c50f9f998656fe273222574dadeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4530d14a12bb544ea8cab0ff159e6d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a4530d14a12bb544ea8cab0ff159e6d0d">clear_broken_connection_map</a> (int disable)</td></tr>
<tr class="separator:a4530d14a12bb544ea8cab0ff159e6d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94ebd9e3d612f1570f189699f6c155b"><td class="memItemLeft" align="right" valign="top"><a id="ad94ebd9e3d612f1570f189699f6c155b"></a>
<a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>connection_or_get_for_extend</b> (const char *digest, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *target_addr, const char **msg_out, int *launch_out)</td></tr>
<tr class="separator:ad94ebd9e3d612f1570f189699f6c155b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3154bc0f1773329e4c86012d07397dfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a3154bc0f1773329e4c86012d07397dfe">connection_or_set_bad_connections</a> (const char *digest, int force)</td></tr>
<tr class="separator:a3154bc0f1773329e4c86012d07397dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfd6590f4dd5c079f371e48eb1e09f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#aecfd6590f4dd5c079f371e48eb1e09f2">connection_or_block_renegotiation</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:aecfd6590f4dd5c079f371e48eb1e09f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cff8523e1f4b95674f2b227a46c862"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a11cff8523e1f4b95674f2b227a46c862">connection_or_reached_eof</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a11cff8523e1f4b95674f2b227a46c862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9c08479c7f8118438c42edb7046d32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a1c9c08479c7f8118438c42edb7046d32">connection_or_process_inbuf</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a1c9c08479c7f8118438c42edb7046d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f9c88b79431319b84a9094761372be"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#ae7f9c88b79431319b84a9094761372be">connection_or_num_cells_writeable</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:ae7f9c88b79431319b84a9094761372be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6891862efd73402fed97a4353b2b24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a8e6891862efd73402fed97a4353b2b24">connection_or_flushed_some</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a8e6891862efd73402fed97a4353b2b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f2d552138b0e015906710a045a6c55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a61f2d552138b0e015906710a045a6c55">connection_or_finished_flushing</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a61f2d552138b0e015906710a045a6c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d6b6b0a229f81ab6f109cd6a44c310"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a94d6b6b0a229f81ab6f109cd6a44c310">connection_or_finished_connecting</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a94d6b6b0a229f81ab6f109cd6a44c310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f21aa5fe9678cceceadc67298afa2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a75f21aa5fe9678cceceadc67298afa2d">connection_or_about_to_close</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a75f21aa5fe9678cceceadc67298afa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8573b49df7ffc3ad6df0faa6e7a12f10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a8573b49df7ffc3ad6df0faa6e7a12f10">connection_or_digest_is_known_relay</a> (const char *id_digest)</td></tr>
<tr class="separator:a8573b49df7ffc3ad6df0faa6e7a12f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb65c80b10f299f06144b83628e74ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#abb65c80b10f299f06144b83628e74ce1">connection_or_update_token_buckets</a> (<a class="el" href="structsmartlist__t.html">smartlist_t</a> *conns, const <a class="el" href="structor__options__t.html">or_options_t</a> *options)</td></tr>
<tr class="separator:abb65c80b10f299f06144b83628e74ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a75b0592cc90f11549ed8899454a1f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a6a75b0592cc90f11549ed8899454a1f0">connection_or_connect_failed</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, int reason, const char *msg)</td></tr>
<tr class="separator:a6a75b0592cc90f11549ed8899454a1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1782f56c8e2a13ef3db44eed29c83d28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a1782f56c8e2a13ef3db44eed29c83d28">connection_or_notify_error</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, int reason, const char *msg)</td></tr>
<tr class="separator:a1782f56c8e2a13ef3db44eed29c83d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54edf676fd9876f181588b834ce98f1"><td class="memItemLeft" align="right" valign="top"><a id="ae54edf676fd9876f181588b834ce98f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *, connection_or_connect,(const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr, uint16_t port, const char *id_digest, channel_tls_t *chan))</td></tr>
<tr class="separator:ae54edf676fd9876f181588b834ce98f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d087b0c7ef9745ce0296b5e28160c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#af4d087b0c7ef9745ce0296b5e28160c7">connection_or_close_normally</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *orconn, int flush)</td></tr>
<tr class="separator:af4d087b0c7ef9745ce0296b5e28160c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e51ba23a771a63d9085548ff188d4b"><td class="memItemLeft" align="right" valign="top"><a id="a33e51ba23a771a63d9085548ff188d4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (void, connection_or_close_for_error,(<a class="el" href="structor__connection__t.html">or_connection_t</a> *orconn, int flush))</td></tr>
<tr class="separator:a33e51ba23a771a63d9085548ff188d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7feaa6ab5ddfb6f1c64357cffbd5e70d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a7feaa6ab5ddfb6f1c64357cffbd5e70d">connection_or_report_broken_states</a> (int severity, int domain)</td></tr>
<tr class="separator:a7feaa6ab5ddfb6f1c64357cffbd5e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ec62968cdb9e577d0868ab00ea920a"><td class="memItemLeft" align="right" valign="top"><a id="a55ec62968cdb9e577d0868ab00ea920a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (int, connection_tls_start_handshake,(<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, int receiving))</td></tr>
<tr class="separator:a55ec62968cdb9e577d0868ab00ea920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ee02cde3308ff45253cd8832bf9dfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a15ee02cde3308ff45253cd8832bf9dfd">connection_tls_continue_handshake</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a15ee02cde3308ff45253cd8832bf9dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e2ac3bf5089e2a988c8ab994c4893e"><td class="memItemLeft" align="right" valign="top"><a id="a69e2ac3bf5089e2a988c8ab994c4893e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>connection_or_set_canonical</b> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *or_conn, int is_canonical)</td></tr>
<tr class="separator:a69e2ac3bf5089e2a988c8ab994c4893e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9044e4d4dd0ad7d56e37ff633c223d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#aeb9044e4d4dd0ad7d56e37ff633c223d">connection_init_or_handshake_state</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, int started_here)</td></tr>
<tr class="separator:aeb9044e4d4dd0ad7d56e37ff633c223d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f0c0f45bf6e7d920db1c1603f448f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a81f0c0f45bf6e7d920db1c1603f448f9">connection_or_init_conn_from_address</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *addr, uint16_t port, const char *id_digest, int started_here)</td></tr>
<tr class="separator:a81f0c0f45bf6e7d920db1c1603f448f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641743095fae21749e9f4bdf36c8e9e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a641743095fae21749e9f4bdf36c8e9e6">connection_or_client_learned_peer_id</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, const uint8_t *peer_id)</td></tr>
<tr class="separator:a641743095fae21749e9f4bdf36c8e9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d99e23c45ae40c245a0474ef4cfb98"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a28d99e23c45ae40c245a0474ef4cfb98">connection_or_client_used</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a28d99e23c45ae40c245a0474ef4cfb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac820fb109b3ec26f5a979be197e3662"><td class="memItemLeft" align="right" valign="top"><a id="aac820fb109b3ec26f5a979be197e3662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (int, connection_or_get_num_circuits,(<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn))</td></tr>
<tr class="separator:aac820fb109b3ec26f5a979be197e3662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4b4ee00896c43391106b72f6bd31ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#afa4b4ee00896c43391106b72f6bd31ac">or_handshake_state_free</a> (<a class="el" href="structor__handshake__state__t.html">or_handshake_state_t</a> *state)</td></tr>
<tr class="separator:afa4b4ee00896c43391106b72f6bd31ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741e61a567306a7cc5aaaf9634ecda4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a741e61a567306a7cc5aaaf9634ecda4e">or_handshake_state_record_cell</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, <a class="el" href="structor__handshake__state__t.html">or_handshake_state_t</a> *state, const <a class="el" href="structcell__t.html">cell_t</a> *cell, int incoming)</td></tr>
<tr class="separator:a741e61a567306a7cc5aaaf9634ecda4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eac340c62c1d3844d69235a6a53c15e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a5eac340c62c1d3844d69235a6a53c15e">or_handshake_state_record_var_cell</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, <a class="el" href="structor__handshake__state__t.html">or_handshake_state_t</a> *state, const <a class="el" href="structvar__cell__t.html">var_cell_t</a> *cell, int incoming)</td></tr>
<tr class="separator:a5eac340c62c1d3844d69235a6a53c15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10910510a0e668c958457783ccf154c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a10910510a0e668c958457783ccf154c9">connection_or_set_state_open</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a10910510a0e668c958457783ccf154c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a80590d68a6d8ea9b011ae44245929b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a1a80590d68a6d8ea9b011ae44245929b">connection_or_write_cell_to_buf</a> (const <a class="el" href="structcell__t.html">cell_t</a> *cell, <a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a1a80590d68a6d8ea9b011ae44245929b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2971caf6775cdc0f63448bbb8ad07361"><td class="memItemLeft" align="right" valign="top"><a id="a2971caf6775cdc0f63448bbb8ad07361"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (void, connection_or_write_var_cell_to_buf,(const <a class="el" href="structvar__cell__t.html">var_cell_t</a> *cell, <a class="el" href="structor__connection__t.html">or_connection_t</a> *conn))</td></tr>
<tr class="separator:a2971caf6775cdc0f63448bbb8ad07361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cfebfdf4ea8cb551ab8d243b56b811"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a23cfebfdf4ea8cb551ab8d243b56b811">connection_or_send_versions</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, int v3_plus)</td></tr>
<tr class="separator:a23cfebfdf4ea8cb551ab8d243b56b811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab6671547a2cb2f45c04e7a4682b736"><td class="memItemLeft" align="right" valign="top"><a id="a1ab6671547a2cb2f45c04e7a4682b736"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (int, connection_or_send_netinfo,(<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn))</td></tr>
<tr class="separator:a1ab6671547a2cb2f45c04e7a4682b736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373bc2ce63f7b8a6530d1b16e420f7c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a373bc2ce63f7b8a6530d1b16e420f7c4">connection_or_send_certs_cell</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:a373bc2ce63f7b8a6530d1b16e420f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda2ead17f44091558bb27dd084517b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#acda2ead17f44091558bb27dd084517b9">connection_or_send_auth_challenge_cell</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn)</td></tr>
<tr class="separator:acda2ead17f44091558bb27dd084517b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ef7fb7062854e94bc474ccd0e51fbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#ab1ef7fb7062854e94bc474ccd0e51fbc">connection_or_compute_authenticate_cell_body</a> (<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, uint8_t *out, size_t outlen, <a class="el" href="structcrypto__pk__t.html">crypto_pk_t</a> *signing_key, int server)</td></tr>
<tr class="separator:ab1ef7fb7062854e94bc474ccd0e51fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6365b56ab3262347297d4096f7b2da70"><td class="memItemLeft" align="right" valign="top"><a id="a6365b56ab3262347297d4096f7b2da70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MOCK_DECL</b> (int, connection_or_send_authenticate_cell,(<a class="el" href="structor__connection__t.html">or_connection_t</a> *conn, int type))</td></tr>
<tr class="separator:a6365b56ab3262347297d4096f7b2da70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0791fc12ab0cc5e212947e10d14a3374"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a0791fc12ab0cc5e212947e10d14a3374">is_or_protocol_version_known</a> (uint16_t version)</td></tr>
<tr class="separator:a0791fc12ab0cc5e212947e10d14a3374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9d7322cd3dd3f5b1c1d9eb9a6bf509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#aac9d7322cd3dd3f5b1c1d9eb9a6bf509">cell_pack</a> (<a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *dest, const <a class="el" href="structcell__t.html">cell_t</a> *src, int wide_circ_ids)</td></tr>
<tr class="separator:aac9d7322cd3dd3f5b1c1d9eb9a6bf509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c229ce284577c48c7a51f9532d8e15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a61c229ce284577c48c7a51f9532d8e15">var_cell_pack_header</a> (const <a class="el" href="structvar__cell__t.html">var_cell_t</a> *cell, char *hdr_out, int wide_circ_ids)</td></tr>
<tr class="separator:a61c229ce284577c48c7a51f9532d8e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e8e7d75e478e23ba78046d4bf17088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvar__cell__t.html">var_cell_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a23e8e7d75e478e23ba78046d4bf17088">var_cell_new</a> (uint16_t payload_len)</td></tr>
<tr class="separator:a23e8e7d75e478e23ba78046d4bf17088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70378434d9f152969cf835cb7df59de1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvar__cell__t.html">var_cell_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#a70378434d9f152969cf835cb7df59de1">var_cell_copy</a> (const <a class="el" href="structvar__cell__t.html">var_cell_t</a> *src)</td></tr>
<tr class="separator:a70378434d9f152969cf835cb7df59de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf174ef822b1a9135e9802171d39a082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="connection__or_8h.html#aaf174ef822b1a9135e9802171d39a082">var_cell_free</a> (<a class="el" href="structvar__cell__t.html">var_cell_t</a> *cell)</td></tr>
<tr class="separator:aaf174ef822b1a9135e9802171d39a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for <a class="el" href="connection__or_8c.html" title="Functions to handle OR connections, TLS handshaking, and cells on the network. ">connection_or.c</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aac9d7322cd3dd3f5b1c1d9eb9a6bf509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9d7322cd3dd3f5b1c1d9eb9a6bf509">&#9670;&nbsp;</a></span>cell_pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cell_pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpacked__cell__t.html">packed_cell_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wide_circ_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pack the <a class="el" href="structcell__t.html">cell_t</a> host-order structure <b>src</b> into network-order in the buffer <b>dest</b>. See tor-spec.txt for details about the wire format.</p>
<p>Note that this function doesn't touch <b>dst</b>-&gt;next: the caller should set it or clear it as appropriate. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_aac9d7322cd3dd3f5b1c1d9eb9a6bf509_cgraph.png" border="0" usemap="#connection__or_8h_aac9d7322cd3dd3f5b1c1d9eb9a6bf509_cgraph" alt=""/></div>
<map name="connection__or_8h_aac9d7322cd3dd3f5b1c1d9eb9a6bf509_cgraph" id="connection__or_8h_aac9d7322cd3dd3f5b1c1d9eb9a6bf509_cgraph">
<area shape="rect" id="node2" href="compat_8c.html#ac4d2010c31db105982e47dc345116b5f" title="set_uint32" alt="" coords="131,5,213,32"/>
<area shape="rect" id="node3" href="compat_8c.html#adbf52deccd4f2b9244d6911488b907f3" title="set_uint16" alt="" coords="131,56,213,83"/>
</map>
</div>

</div>
</div>
<a id="a4530d14a12bb544ea8cab0ff159e6d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4530d14a12bb544ea8cab0ff159e6d0d">&#9670;&nbsp;</a></span>clear_broken_connection_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_broken_connection_map </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop_recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forget all recorded states for failed connections. If <b>stop_recording</b> is true, don't record any more. </p>

</div>
</div>
<a id="aeb9044e4d4dd0ad7d56e37ff633c223d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9044e4d4dd0ad7d56e37ff633c223d">&#9670;&nbsp;</a></span>connection_init_or_handshake_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_init_or_handshake_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>started_here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new connection handshake state for the connection <b>conn</b>. Return 0 on success, -1 on failure. </p>

</div>
</div>
<a id="a75f21aa5fe9678cceceadc67298afa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f21aa5fe9678cceceadc67298afa2d">&#9670;&nbsp;</a></span>connection_or_about_to_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_about_to_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>or_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when we're about to finally unlink and free an OR connection: perform necessary accounting and cleanup </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a75f21aa5fe9678cceceadc67298afa2d_cgraph.png" border="0" usemap="#connection__or_8h_a75f21aa5fe9678cceceadc67298afa2d_cgraph" alt=""/></div>
<map name="connection__or_8h_a75f21aa5fe9678cceceadc67298afa2d_cgraph" id="connection__or_8h_a75f21aa5fe9678cceceadc67298afa2d_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a41a07dcb3da5d642570a8ed069c27450" title="channel_closed" alt="" coords="196,13,308,39"/>
</map>
</div>

</div>
</div>
<a id="aecfd6590f4dd5c079f371e48eb1e09f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfd6590f4dd5c079f371e48eb1e09f2">&#9670;&nbsp;</a></span>connection_or_block_renegotiation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_block_renegotiation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block all future attempts to renegotiate on 'conn' </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_aecfd6590f4dd5c079f371e48eb1e09f2_cgraph.png" border="0" usemap="#connection__or_8h_aecfd6590f4dd5c079f371e48eb1e09f2_cgraph" alt=""/></div>
<map name="connection__or_8h_aecfd6590f4dd5c079f371e48eb1e09f2_cgraph" id="connection__or_8h_aecfd6590f4dd5c079f371e48eb1e09f2_cgraph">
<area shape="rect" id="node2" href="tortls_8c.html#a5823cfa710f0f7987d09dfececae28d0" title="tor_tls_set_renegotiate\l_callback" alt="" coords="206,35,361,76"/>
<area shape="rect" id="node5" href="tortls_8c.html#a08342968552b84d5dfbd6493338f6058" title="tor_tls_block_renegotiation" alt="" coords="195,101,372,127"/>
<area shape="rect" id="node3" href="tortls_8c.html#a3b0c0880a231328e1b5d7faa01fddcd9" title="tor_tls_server_info\l_callback" alt="" coords="420,5,549,47"/>
<area shape="rect" id="node4" href="tortls_8c.html#a6f66b1039c2f3e00e4d4602f19d5ab02" title="tor_tls_debug_state\l_callback" alt="" coords="597,35,733,76"/>
</map>
</div>

</div>
</div>
<a id="af395c50f9f998656fe273222574dadeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af395c50f9f998656fe273222574dadeb">&#9670;&nbsp;</a></span>connection_or_clear_identity_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_clear_identity_map </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all entries from the identity-to-orconn map, and clear all identities in OR conns. </p>

</div>
</div>
<a id="a641743095fae21749e9f4bdf36c8e9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641743095fae21749e9f4bdf36c8e9e6">&#9670;&nbsp;</a></span>connection_or_client_learned_peer_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_client_learned_peer_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>peer_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when we (as a connection initiator) have definitively, authenticatedly, learned that ID of the Tor instance on the other side of <b>conn</b> is <b>peer_id</b>. For v1 and v2 handshakes, this is right after we get a certificate chain in a TLS handshake or renegotiation. For v3 handshakes, this is right after we get a certificate chain in a CERTS cell.</p>
<p>If we did not know the ID before, record the one we got.</p>
<p>If we wanted an ID, but we didn't get the one we expected, log a message and return -1. On relays:</p><ul>
<li>log a protocol warning whenever the fingerprints don't match; On clients:</li>
<li>if a relay's fingerprint doesn't match, log a warning;</li>
<li>if we don't have updated relay fingerprints from a recent consensus, and a fallback directory mirror's hard-coded fingerprint has changed, log an info explaining that we will try another fallback.</li>
</ul>
<p>If we're testing reachability, remember what we learned.</p>
<p>Return 0 on success, -1 on failure. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a641743095fae21749e9f4bdf36c8e9e6_cgraph.png" border="0" usemap="#connection__or_8h_a641743095fae21749e9f4bdf36c8e9e6_cgraph" alt=""/></div>
<map name="connection__or_8h_a641743095fae21749e9f4bdf36c8e9e6_cgraph" id="connection__or_8h_a641743095fae21749e9f4bdf36c8e9e6_cgraph">
<area shape="rect" id="node2" href="util_8c.html#add0703747195c2abd042572426e80266" title="tor_digest_is_zero" alt="" coords="195,13,323,39"/>
<area shape="rect" id="node3" href="di__ops_8c.html#a473334ee93cca0aea10523321a444ea3" title="tor_memeq" alt="" coords="371,13,457,39"/>
</map>
</div>

</div>
</div>
<a id="a28d99e23c45ae40c245a0474ef4cfb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d99e23c45ae40c245a0474ef4cfb98">&#9670;&nbsp;</a></span>connection_or_client_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t connection_or_client_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return when a client used this, for <a class="el" href="connection_8c.html" title="General high-level functions to handle reading and writing on connections. ">connection.c</a>, since client_used is now one of the timestamps of channel_t </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a28d99e23c45ae40c245a0474ef4cfb98_cgraph.png" border="0" usemap="#connection__or_8h_a28d99e23c45ae40c245a0474ef4cfb98_cgraph" alt=""/></div>
<map name="connection__or_8h_a28d99e23c45ae40c245a0474ef4cfb98_cgraph" id="connection__or_8h_a28d99e23c45ae40c245a0474ef4cfb98_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#a7c7c9bb52317ac2f0189a286108bdc7e" title="channel_when_last_client" alt="" coords="229,5,400,32"/>
</map>
</div>

</div>
</div>
<a id="af4d087b0c7ef9745ce0296b5e28160c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d087b0c7ef9745ce0296b5e28160c7">&#9670;&nbsp;</a></span>connection_or_close_normally()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_close_normally </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>orconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark orconn for close and transition the associated channel, if any, to the closing state.</p>
<p>It's safe to call this and connection_or_close_for_error() any time, and channel layer will treat it as a connection closing for reasons outside its control, like the remote end closing it. It can also be a local reason that's specific to connection_t/or_connection_t rather than the channel mechanism, such as expiration of old connections in run_connection_housekeeping(). If you want to close a channel_t from somewhere that logically works in terms of generic channels rather than connections, use <a class="el" href="channel_8c.html#ac5c51ad12ff89e0f63cc386ccda8493f">channel_mark_for_close()</a>; see also the comment on that function in <a class="el" href="channel_8c.html" title="OR/OP-to-OR channel abstraction layer. A channel&#39;s job is to transfer cells from Tor instance to Tor ...">channel.c</a>. </p>

</div>
</div>
<a id="ab1ef7fb7062854e94bc474ccd0e51fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ef7fb7062854e94bc474ccd0e51fbc">&#9670;&nbsp;</a></span>connection_or_compute_authenticate_cell_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_compute_authenticate_cell_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrypto__pk__t.html">crypto_pk_t</a> *&#160;</td>
          <td class="paramname"><em>signing_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the main body of an AUTHENTICATE cell that a client can use to authenticate itself on a v3 handshake for <b>conn</b>. Write it to the <b>outlen</b>-byte buffer at <b>out</b>.</p>
<p>If <b>server</b> is true, only calculate the first V3_AUTH_FIXED_PART_LEN bytes &ndash; the part of the authenticator that's determined by the rest of the handshake, and which match the provided value exactly.</p>
<p>If <b>server</b> is false and <b>signing_key</b> is NULL, calculate the first V3_AUTH_BODY_LEN bytes of the authenticator (that is, everything that should be signed), but don't actually sign it.</p>
<p>If <b>server</b> is false and <b>signing_key</b> is provided, calculate the entire authenticator, signed with <b>signing_key</b>.</p>
<p>Return the length of the cell body on success, and -1 on failure. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_ab1ef7fb7062854e94bc474ccd0e51fbc_cgraph.png" border="0" usemap="#connection__or_8h_ab1ef7fb7062854e94bc474ccd0e51fbc_cgraph" alt=""/></div>
<map name="connection__or_8h_ab1ef7fb7062854e94bc474ccd0e51fbc_cgraph" id="connection__or_8h_ab1ef7fb7062854e94bc474ccd0e51fbc_cgraph">
<area shape="rect" id="node2" href="tortls_8c.html#a7aa93459dd4e3641e885932d682db4a0" title="tor_tls_get_my_certs" alt="" coords="216,5,360,32"/>
<area shape="rect" id="node3" href="tortls_8c.html#aeb4713a168234b69a9d25312a3a15770" title="tor_x509_cert_get_id\l_digests" alt="" coords="217,57,359,98"/>
</map>
</div>

</div>
</div>
<a id="a6a75b0592cc90f11549ed8899454a1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a75b0592cc90f11549ed8899454a1f0">&#9670;&nbsp;</a></span>connection_or_connect_failed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_connect_failed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>conn</b> is in the 'connecting' state, and it failed to complete a TCP connection. Send notifications appropriately.</p>
<p><b>reason</b> specifies the or_conn_end_reason for the failure; <b>msg</b> specifies the strerror-style error message. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a6a75b0592cc90f11549ed8899454a1f0_cgraph.png" border="0" usemap="#connection__or_8h_a6a75b0592cc90f11549ed8899454a1f0_cgraph" alt=""/></div>
<map name="connection__or_8h_a6a75b0592cc90f11549ed8899454a1f0_cgraph" id="connection__or_8h_a6a75b0592cc90f11549ed8899454a1f0_cgraph">
<area shape="rect" id="node2" href="control_8c.html#a7ec5a96f0e43d4719b7992819bb3f1ac" title="control_event_or_conn\l_status" alt="" coords="209,5,363,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a6a75b0592cc90f11549ed8899454a1f0_icgraph.png" border="0" usemap="#connection__or_8h_a6a75b0592cc90f11549ed8899454a1f0_icgraph" alt=""/></div>
<map name="connection__or_8h_a6a75b0592cc90f11549ed8899454a1f0_icgraph" id="connection__or_8h_a6a75b0592cc90f11549ed8899454a1f0_icgraph">
<area shape="rect" id="node2" href="connection__or_8h.html#a1782f56c8e2a13ef3db44eed29c83d28" title="connection_or_notify\l_error" alt="" coords="209,5,352,47"/>
</map>
</div>

</div>
</div>
<a id="a8573b49df7ffc3ad6df0faa6e7a12f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8573b49df7ffc3ad6df0faa6e7a12f10">&#9670;&nbsp;</a></span>connection_or_digest_is_known_relay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_digest_is_known_relay </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id_digest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 1 if identity digest <b>id_digest</b> is known to be a currently or recently running relay. Otherwise return 0. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a8573b49df7ffc3ad6df0faa6e7a12f10_cgraph.png" border="0" usemap="#connection__or_8h_a8573b49df7ffc3ad6df0faa6e7a12f10_cgraph" alt=""/></div>
<map name="connection__or_8h_a8573b49df7ffc3ad6df0faa6e7a12f10_cgraph" id="connection__or_8h_a8573b49df7ffc3ad6df0faa6e7a12f10_cgraph">
<area shape="rect" id="node2" href="networkstatus_8c.html#a810a06fe9e7c7bd3a1c5c5ee8cc13b52" title="router_get_consensus\l_status_by_id" alt="" coords="203,30,354,71"/>
<area shape="rect" id="node8" href="routerlist_8c.html#a9eb1861cedcb477a2e455b6c02eb56d8" title="router_get_by_id_digest" alt="" coords="199,97,359,124"/>
<area shape="rect" id="node3" href="networkstatus_8c.html#abeb917388a503fd5c8e727d7a6bd675f" title="router_get_mutable\l_consensus_status_by_id" alt="" coords="407,27,580,69"/>
<area shape="rect" id="node4" href="container_8c.html#a6722b8c6ca501b524958b3cdac2bc70c" title="smartlist_bsearch" alt="" coords="669,5,795,32"/>
<area shape="rect" id="node6" href="networkstatus_8c.html#a998a1af9202b3a8eec2327819b84bcee" title="compare_digest_to_routerstatus\l_entry" alt="" coords="628,57,836,98"/>
<area shape="rect" id="node5" href="container_8c.html#af0f195f396d7f97e7f2f2367453da119" title="smartlist_bsearch_idx" alt="" coords="884,5,1033,32"/>
<area shape="rect" id="node7" href="di__ops_8c.html#a47393c6ace65b9b2173d60ac6ae119aa" title="tor_memcmp" alt="" coords="909,64,1008,91"/>
<area shape="rect" id="node9" href="routerlist_8c.html#a848eea1698b3361538f190f55f2cc0e6" title="router_get_mutable\l_by_digest" alt="" coords="427,93,560,134"/>
</map>
</div>

</div>
</div>
<a id="a94d6b6b0a229f81ab6f109cd6a44c310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d6b6b0a229f81ab6f109cd6a44c310">&#9670;&nbsp;</a></span>connection_or_finished_connecting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_finished_connecting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>or_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connected handler for OR connections: begin the TLS handshake. </p>

</div>
</div>
<a id="a61f2d552138b0e015906710a045a6c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f2d552138b0e015906710a045a6c55">&#9670;&nbsp;</a></span>connection_or_finished_flushing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_finished_flushing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connection <b>conn</b> has finished writing and has no bytes left on its outbuf.</p>
<p>Otherwise it's in state "open": stop writing and return.</p>
<p>If <b>conn</b> is broken, mark it for close and return -1, else return 0. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a61f2d552138b0e015906710a045a6c55_cgraph.png" border="0" usemap="#connection__or_8h_a61f2d552138b0e015906710a045a6c55_cgraph" alt=""/></div>
<map name="connection__or_8h_a61f2d552138b0e015906710a045a6c55_cgraph" id="connection__or_8h_a61f2d552138b0e015906710a045a6c55_cgraph">
<area shape="rect" id="node2" href="connection_8c.html#a738d9e7ef0c4a101c2adbd4cade35475" title="assert_connection_ok" alt="" coords="208,13,357,39"/>
</map>
</div>

</div>
</div>
<a id="a8e6891862efd73402fed97a4353b2b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6891862efd73402fed97a4353b2b24">&#9670;&nbsp;</a></span>connection_or_flushed_some()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_flushed_some </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called whenever we have flushed some data on an or_conn: add more data from active circuits. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a8e6891862efd73402fed97a4353b2b24_cgraph.png" border="0" usemap="#connection__or_8h_a8e6891862efd73402fed97a4353b2b24_cgraph" alt=""/></div>
<map name="connection__or_8h_a8e6891862efd73402fed97a4353b2b24_cgraph" id="connection__or_8h_a8e6891862efd73402fed97a4353b2b24_cgraph">
<area shape="rect" id="node2" href="channel_8c.html#abf9310a1fa1a4d1cb1e3af383a98d902" title="channel_update_xmit\l_queue_size" alt="" coords="244,5,389,47"/>
</map>
</div>

</div>
</div>
<a id="a81f0c0f45bf6e7d920db1c1603f448f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f0c0f45bf6e7d920db1c1603f448f9">&#9670;&nbsp;</a></span>connection_or_init_conn_from_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_init_conn_from_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtor__addr__t.html">tor_addr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id_digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>started_here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If we don't necessarily know the router we're connecting to, but we have an addr/port/id_digest, then fill in as much as we can. Start by checking to see if this describes a router we know. <b>started_here</b> is 1 if we are the initiator of <b>conn</b> and 0 if it's an incoming connection. </p>

</div>
</div>
<a id="a1782f56c8e2a13ef3db44eed29c83d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1782f56c8e2a13ef3db44eed29c83d28">&#9670;&nbsp;</a></span>connection_or_notify_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_notify_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>conn</b> got an error in connection_handle_read_impl() or connection_handle_write_impl() and is going to die soon.</p>
<p><b>reason</b> specifies the or_conn_end_reason for the failure; <b>msg</b> specifies the strerror-style error message. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a1782f56c8e2a13ef3db44eed29c83d28_cgraph.png" border="0" usemap="#connection__or_8h_a1782f56c8e2a13ef3db44eed29c83d28_cgraph" alt=""/></div>
<map name="connection__or_8h_a1782f56c8e2a13ef3db44eed29c83d28_cgraph" id="connection__or_8h_a1782f56c8e2a13ef3db44eed29c83d28_cgraph">
<area shape="rect" id="node2" href="connection__or_8c.html#a6a75b0592cc90f11549ed8899454a1f0" title="connection_or_connect\l_failed" alt="" coords="196,5,352,47"/>
<area shape="rect" id="node3" href="control_8c.html#a7ec5a96f0e43d4719b7992819bb3f1ac" title="control_event_or_conn\l_status" alt="" coords="400,5,553,47"/>
</map>
</div>

</div>
</div>
<a id="ae7f9c88b79431319b84a9094761372be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f9c88b79431319b84a9094761372be">&#9670;&nbsp;</a></span>connection_or_num_cells_writeable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t connection_or_num_cells_writeable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is for <a class="el" href="channeltls_8c.html" title="A concrete subclass of channel_t using or_connection_t to transfer cells between Tor instances...">channeltls.c</a> to ask how many cells we could accept if they were available. </p>

</div>
</div>
<a id="a1c9c08479c7f8118438c42edb7046d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9c08479c7f8118438c42edb7046d32">&#9670;&nbsp;</a></span>connection_or_process_inbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_process_inbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle any new bytes that have come in on connection <b>conn</b>. If conn is in 'open' state, hand it to connection_or_process_cells_from_inbuf() (else do nothing). </p>
<p>Don't let the inbuf of a nonopen OR connection grow beyond this many bytes: it's either a broken client, a non-Tor client, or a DOS attempt. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a1c9c08479c7f8118438c42edb7046d32_cgraph.png" border="0" usemap="#connection__or_8h_a1c9c08479c7f8118438c42edb7046d32_cgraph" alt=""/></div>
<map name="connection__or_8h_a1c9c08479c7f8118438c42edb7046d32_cgraph" id="connection__or_8h_a1c9c08479c7f8118438c42edb7046d32_cgraph">
<area shape="rect" id="node2" href="connection_8c.html#a762af8c79046607b86c5be3a403c736b" title="connection_read_proxy\l_handshake" alt="" coords="209,5,365,47"/>
</map>
</div>

</div>
</div>
<a id="a11cff8523e1f4b95674f2b227a46c862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cff8523e1f4b95674f2b227a46c862">&#9670;&nbsp;</a></span>connection_or_reached_eof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_reached_eof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We've received an EOF from <b>conn</b>. Mark it for close and return. </p>

</div>
</div>
<a id="af2d555975120054c38db70b91234678c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d555975120054c38db70b91234678c">&#9670;&nbsp;</a></span>connection_or_remove_from_identity_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_remove_from_identity_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If conn is listed in orconn_identity_map, remove it, and clear conn-&gt;identity_digest. Otherwise do nothing. </p>

</div>
</div>
<a id="a7feaa6ab5ddfb6f1c64357cffbd5e70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7feaa6ab5ddfb6f1c64357cffbd5e70d">&#9670;&nbsp;</a></span>connection_or_report_broken_states()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_report_broken_states </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>severity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Report a list of the top states for failed OR connections at log level <b>severity</b>, in log domain <b>domain</b>. </p>

</div>
</div>
<a id="acda2ead17f44091558bb27dd084517b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda2ead17f44091558bb27dd084517b9">&#9670;&nbsp;</a></span>connection_or_send_auth_challenge_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_send_auth_challenge_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an AUTH_CHALLENGE cell on the connection <b>conn</b>. Return 0 on success, -1 on failure. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_acda2ead17f44091558bb27dd084517b9_cgraph.png" border="0" usemap="#connection__or_8h_acda2ead17f44091558bb27dd084517b9_cgraph" alt=""/></div>
<map name="connection__or_8h_acda2ead17f44091558bb27dd084517b9_cgraph" id="connection__or_8h_acda2ead17f44091558bb27dd084517b9_cgraph">
<area shape="rect" id="node2" href="connection__or_8c.html#a23e8e7d75e478e23ba78046d4bf17088" title="var_cell_new" alt="" coords="196,13,295,39"/>
</map>
</div>

</div>
</div>
<a id="a373bc2ce63f7b8a6530d1b16e420f7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373bc2ce63f7b8a6530d1b16e420f7c4">&#9670;&nbsp;</a></span>connection_or_send_certs_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_send_certs_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a CERTS cell on the connection <b>conn</b>. Return 0 on success, -1 on failure. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a373bc2ce63f7b8a6530d1b16e420f7c4_cgraph.png" border="0" usemap="#connection__or_8h_a373bc2ce63f7b8a6530d1b16e420f7c4_cgraph" alt=""/></div>
<map name="connection__or_8h_a373bc2ce63f7b8a6530d1b16e420f7c4_cgraph" id="connection__or_8h_a373bc2ce63f7b8a6530d1b16e420f7c4_cgraph">
<area shape="rect" id="node2" href="tortls_8c.html#a7aa93459dd4e3641e885932d682db4a0" title="tor_tls_get_my_certs" alt="" coords="195,5,339,32"/>
<area shape="rect" id="node3" href="tortls_8c.html#ae138ea45f150f1291b09f0b5dfa34ad4" title="tor_x509_cert_get_der" alt="" coords="192,56,343,83"/>
<area shape="rect" id="node4" href="connection__or_8c.html#a23e8e7d75e478e23ba78046d4bf17088" title="var_cell_new" alt="" coords="218,107,317,133"/>
</map>
</div>

</div>
</div>
<a id="a23cfebfdf4ea8cb551ab8d243b56b811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cfebfdf4ea8cb551ab8d243b56b811">&#9670;&nbsp;</a></span>connection_or_send_versions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_send_versions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v3_plus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a VERSIONS cell on <b>conn</b>, telling the other host about the link protocol versions that this Tor can support.</p>
<p>If <b>v3_plus</b>, this is part of a V3 protocol handshake, so only allow protocol version v3 or later. If not <b>v3_plus</b>, this is not part of a v3 protocol handshake, so don't allow protocol v3 or later. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a23cfebfdf4ea8cb551ab8d243b56b811_cgraph.png" border="0" usemap="#connection__or_8h_a23cfebfdf4ea8cb551ab8d243b56b811_cgraph" alt=""/></div>
<map name="connection__or_8h_a23cfebfdf4ea8cb551ab8d243b56b811_cgraph" id="connection__or_8h_a23cfebfdf4ea8cb551ab8d243b56b811_cgraph">
<area shape="rect" id="node2" href="connection__or_8c.html#a23e8e7d75e478e23ba78046d4bf17088" title="var_cell_new" alt="" coords="192,13,291,39"/>
</map>
</div>

</div>
</div>
<a id="a3154bc0f1773329e4c86012d07397dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3154bc0f1773329e4c86012d07397dfe">&#9670;&nbsp;</a></span>connection_or_set_bad_connections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_set_bad_connections </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Go through all the OR connections (or if <b>digest</b> is non-NULL, just the OR connections with that digest), and set the is_bad_for_new_circs flag based on the rules in connection_or_group_set_badness() (or just always set it if <b>force</b> is true). </p>

</div>
</div>
<a id="a10910510a0e668c958457783ccf154c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10910510a0e668c958457783ccf154c9">&#9670;&nbsp;</a></span>connection_or_set_state_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_or_set_state_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set <b>conn</b>'s state to OR_CONN_STATE_OPEN, and tell other subsystems as appropriate. Called when we are done with all TLS and OR handshaking. </p>

</div>
</div>
<a id="abb65c80b10f299f06144b83628e74ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb65c80b10f299f06144b83628e74ce1">&#9670;&nbsp;</a></span>connection_or_update_token_buckets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_update_token_buckets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsmartlist__t.html">smartlist_t</a> *&#160;</td>
          <td class="paramname"><em>conns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structor__options__t.html">or_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Either our set of relays or our per-conn rate limits have changed. Go through all the OR connections and update their token buckets to make sure they don't exceed their maximum values. </p>

</div>
</div>
<a id="a1a80590d68a6d8ea9b011ae44245929b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a80590d68a6d8ea9b011ae44245929b">&#9670;&nbsp;</a></span>connection_or_write_cell_to_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_or_write_cell_to_buf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pack <b>cell</b> into wire-format, and write it onto <b>conn</b>'s outbuf. For cells that use or affect a circuit, this should only be called by connection_or_flush_from_first_active_circuit(). </p>

</div>
</div>
<a id="a15ee02cde3308ff45253cd8832bf9dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ee02cde3308ff45253cd8832bf9dfd">&#9670;&nbsp;</a></span>connection_tls_continue_handshake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_tls_continue_handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move forward with the tls handshake. If it finishes, hand <b>conn</b> to connection_tls_finish_handshake().</p>
<p>Return -1 if <b>conn</b> is broken, else return 0. </p>

</div>
</div>
<a id="a0791fc12ab0cc5e212947e10d14a3374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0791fc12ab0cc5e212947e10d14a3374">&#9670;&nbsp;</a></span>is_or_protocol_version_known()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_or_protocol_version_known </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <b>v</b> is a link protocol version that this Tor implementation believes it can support. </p>

</div>
</div>
<a id="afa4b4ee00896c43391106b72f6bd31ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4b4ee00896c43391106b72f6bd31ac">&#9670;&nbsp;</a></span>or_handshake_state_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void or_handshake_state_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__handshake__state__t.html">or_handshake_state_t</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free all storage held by <b>state</b>. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_afa4b4ee00896c43391106b72f6bd31ac_cgraph.png" border="0" usemap="#connection__or_8h_afa4b4ee00896c43391106b72f6bd31ac_cgraph" alt=""/></div>
<map name="connection__or_8h_afa4b4ee00896c43391106b72f6bd31ac_cgraph" id="connection__or_8h_afa4b4ee00896c43391106b72f6bd31ac_cgraph">
<area shape="rect" id="node2" href="crypto_8c.html#a4ca581f3cf1db8b08e696a7c4efb8a90" title="crypto_digest_free" alt="" coords="222,5,351,32"/>
<area shape="rect" id="node3" href="tortls_8c.html#a1bc75295b83d26baab00ad0cc44f46d4" title="tor_x509_cert_free" alt="" coords="221,56,352,83"/>
<area shape="rect" id="node4" href="crypto_8c.html#a955f8d276e5213dd68600bf6dee0b9ae" title="memwipe" alt="" coords="400,81,479,108"/>
</map>
</div>

</div>
</div>
<a id="a741e61a567306a7cc5aaaf9634ecda4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741e61a567306a7cc5aaaf9634ecda4e">&#9670;&nbsp;</a></span>or_handshake_state_record_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void or_handshake_state_record_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structor__handshake__state__t.html">or_handshake_state_t</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incoming</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remember that <b>cell</b> has been transmitted (if <b>incoming</b> is false) or received (if <b>incoming</b> is true) during a V3 handshake using <b>state</b>.</p>
<p>(We don't record the cell, but we keep a digest of everything sent or received during the v3 handshake, and the client signs it in an authenticate cell.) </p>

</div>
</div>
<a id="a5eac340c62c1d3844d69235a6a53c15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eac340c62c1d3844d69235a6a53c15e">&#9670;&nbsp;</a></span>or_handshake_state_record_var_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void or_handshake_state_record_var_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structor__connection__t.html">or_connection_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structor__handshake__state__t.html">or_handshake_state_t</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvar__cell__t.html">var_cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incoming</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remember that a variable-length <b>cell</b> has been transmitted (if <b>incoming</b> is false) or received (if <b>incoming</b> is true) during a V3 handshake using <b>state</b>.</p>
<p>(We don't record the cell, but we keep a digest of everything sent or received during the v3 handshake, and the client signs it in an authenticate cell.) </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a5eac340c62c1d3844d69235a6a53c15e_cgraph.png" border="0" usemap="#connection__or_8h_a5eac340c62c1d3844d69235a6a53c15e_cgraph" alt=""/></div>
<map name="connection__or_8h_a5eac340c62c1d3844d69235a6a53c15e_cgraph" id="connection__or_8h_a5eac340c62c1d3844d69235a6a53c15e_cgraph">
<area shape="rect" id="node2" href="crypto_8c.html#ab13a3ab6f6ca1febd6a1f0e0c7f52966" title="crypto_digest256_new" alt="" coords="192,13,344,39"/>
</map>
</div>

</div>
</div>
<a id="a70378434d9f152969cf835cb7df59de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70378434d9f152969cf835cb7df59de1">&#9670;&nbsp;</a></span>var_cell_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvar__cell__t.html">var_cell_t</a>* var_cell_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvar__cell__t.html">var_cell_t</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a <a class="el" href="structvar__cell__t.html">var_cell_t</a> </p>

</div>
</div>
<a id="aaf174ef822b1a9135e9802171d39a082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf174ef822b1a9135e9802171d39a082">&#9670;&nbsp;</a></span>var_cell_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void var_cell_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvar__cell__t.html">var_cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all space held by <b>cell</b>. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_aaf174ef822b1a9135e9802171d39a082_icgraph.png" border="0" usemap="#connection__or_8h_aaf174ef822b1a9135e9802171d39a082_icgraph" alt=""/></div>
<map name="connection__or_8h_aaf174ef822b1a9135e9802171d39a082_icgraph" id="connection__or_8h_aaf174ef822b1a9135e9802171d39a082_icgraph">
<area shape="rect" id="node2" href="channel_8c.html#ae06da2fa9517932c784776910a727575" title="cell_queue_entry_free" alt="" coords="149,5,299,32"/>
</map>
</div>

</div>
</div>
<a id="a23e8e7d75e478e23ba78046d4bf17088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e8e7d75e478e23ba78046d4bf17088">&#9670;&nbsp;</a></span>var_cell_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvar__cell__t.html">var_cell_t</a>* var_cell_new </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>payload_len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and return a new <a class="el" href="structvar__cell__t.html">var_cell_t</a> with <b>payload_len</b> bytes of payload space. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a23e8e7d75e478e23ba78046d4bf17088_icgraph.png" border="0" usemap="#connection__or_8h_a23e8e7d75e478e23ba78046d4bf17088_icgraph" alt=""/></div>
<map name="connection__or_8h_a23e8e7d75e478e23ba78046d4bf17088_icgraph" id="connection__or_8h_a23e8e7d75e478e23ba78046d4bf17088_icgraph">
<area shape="rect" id="node2" href="connection__or_8h.html#a23cfebfdf4ea8cb551ab8d243b56b811" title="connection_or_send\l_versions" alt="" coords="154,5,293,47"/>
<area shape="rect" id="node3" href="connection__or_8h.html#a373bc2ce63f7b8a6530d1b16e420f7c4" title="connection_or_send\l_certs_cell" alt="" coords="154,71,293,112"/>
<area shape="rect" id="node4" href="connection__or_8h.html#acda2ead17f44091558bb27dd084517b9" title="connection_or_send\l_auth_challenge_cell" alt="" coords="152,136,295,177"/>
</map>
</div>

</div>
</div>
<a id="a61c229ce284577c48c7a51f9532d8e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c229ce284577c48c7a51f9532d8e15">&#9670;&nbsp;</a></span>var_cell_pack_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int var_cell_pack_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvar__cell__t.html">var_cell_t</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hdr_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wide_circ_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the header of <b>cell</b> into the first VAR_CELL_MAX_HEADER_SIZE bytes of <b>hdr_out</b>. Returns number of bytes used. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a61c229ce284577c48c7a51f9532d8e15_cgraph.png" border="0" usemap="#connection__or_8h_a61c229ce284577c48c7a51f9532d8e15_cgraph" alt=""/></div>
<map name="connection__or_8h_a61c229ce284577c48c7a51f9532d8e15_cgraph" id="connection__or_8h_a61c229ce284577c48c7a51f9532d8e15_cgraph">
<area shape="rect" id="node2" href="compat_8c.html#ac4d2010c31db105982e47dc345116b5f" title="set_uint32" alt="" coords="201,5,284,32"/>
<area shape="rect" id="node3" href="compat_8c.html#adbf52deccd4f2b9244d6911488b907f3" title="set_uint16" alt="" coords="201,56,284,83"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="connection__or_8h_a61c229ce284577c48c7a51f9532d8e15_icgraph.png" border="0" usemap="#connection__or_8h_a61c229ce284577c48c7a51f9532d8e15_icgraph" alt=""/></div>
<map name="connection__or_8h_a61c229ce284577c48c7a51f9532d8e15_icgraph" id="connection__or_8h_a61c229ce284577c48c7a51f9532d8e15_icgraph">
<area shape="rect" id="node2" href="connection__or_8c.html#aaf43644cf527a6655657b8f4aa1d1e1e" title="MOCK_IMPL" alt="" coords="201,5,301,32"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
