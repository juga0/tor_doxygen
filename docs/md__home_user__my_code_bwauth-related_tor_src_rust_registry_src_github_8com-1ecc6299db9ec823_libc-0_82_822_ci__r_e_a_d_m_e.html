<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tor: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tor
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The goal of the libc crate is to have CI running everywhere to have the strongest guarantees about the definitions that this library contains, and as a result the CI is pretty complicated and also pretty large! Hopefully this can serve as a guide through the sea of scripts in this directory and elsewhere in this project.</p>
<h1>Files</h1>
<p>First up, let's talk about the files in this directory:</p>
<ul>
<li><code>run-travis.sh</code> - a shell script run by all Travis builders, this is responsible for setting up the rest of the environment such as installing new packages, downloading Rust target libraries, etc.</li>
<li><code>run.sh</code> - the actual script which runs tests for a particular architecture. Called from the <code>run-travis.sh</code> script this will run all tests for the target specified.</li>
<li><code>cargo-config</code> - Cargo configuration of linkers to use copied into place by the <code>run-travis.sh</code> script before builds are run.</li>
<li><code>dox.sh</code> - script called from <code>run-travis.sh</code> on only the linux 64-bit nightly Travis bots to build documentation for this crate.</li>
<li><code>landing-page-*.html</code> - used by <code>dox.sh</code> to generate a landing page for all architectures' documentation.</li>
<li><code>run-qemu.sh</code> - see discussion about QEMU below</li>
<li><code>mips</code>, <code>rumprun</code> - instructions to build the docker image for each respective CI target</li>
</ul>
<h1>CI Systems</h1>
<p>Currently this repository leverages a combination of Travis CI and AppVeyor for running tests. The triples tested are:</p>
<ul>
<li>AppVeyor<ul>
<li><code>{i686,x86_64}-pc-windows-{msvc,gnu}</code></li>
</ul>
</li>
<li>Travis<ul>
<li><code>{i686,x86_64,mips,aarch64}-unknown-linux-gnu</code></li>
<li><code>x86_64-unknown-linux-musl</code></li>
<li><code>arm-unknown-linux-gnueabihf</code></li>
<li><code>arm-linux-androideabi</code></li>
<li><code>{i686,x86_64}-apple-{darwin,ios}</code></li>
<li><code>x86_64-rumprun-netbsd</code></li>
<li><code>x86_64-unknown-freebsd</code></li>
<li><code>x86_64-unknown-openbsd</code></li>
</ul>
</li>
</ul>
<p>The Windows triples are all pretty standard, they just set up their environment then run tests, no need for downloading any extra target libs (we just download the right installer). The Intel Linux/OSX builds are similar in that we just download the right target libs and run tests. Note that the Intel Linux/OSX builds are run on stable/beta/nightly, but are the only ones that do so.</p>
<p>The remaining architectures look like:</p>
<ul>
<li>Android runs in a <a href="https://github.com/rust-lang/rust-buildbot/blob/master/slaves/android/Dockerfile">docker image</a> with an emulator, the NDK, and the SDK already set up. The entire build happens within the docker image.</li>
<li>The MIPS, ARM, and AArch64 builds all use the QEMU userspace emulator to run the generated binary to actually verify the tests pass.</li>
<li>The MUSL build just has to download a MUSL compiler and target libraries and then otherwise runs tests normally.</li>
<li>iOS builds need an extra linker flag currently, but beyond that they're built as standard as everything else.</li>
<li>The rumprun target builds an entire kernel from the test suite and then runs it inside QEMU using the serial console to test whether it succeeded or failed.</li>
<li>The BSD builds, currently OpenBSD and FreeBSD, use QEMU to boot up a system and compile/run tests. More information on that below.</li>
</ul>
<h2>QEMU</h2>
<p>Lots of the architectures tested here use QEMU in the tests, so it's worth going over all the crazy capabilities QEMU has and the various flavors in which we use it!</p>
<p>First up, QEMU has userspace emulation where it doesn't boot a full kernel, it just runs a binary from another architecture (using the <code>qemu-&lt;arch&gt;</code> wrappers). We provide it the runtime path for the dynamically loaded system libraries, however. This strategy is used for all Linux architectures that aren't intel. Note that one downside of this QEMU system is that threads are barely implemented, so we're careful to not spawn many threads.</p>
<p>For the rumprun target the only output is a kernel image, so we just use that plus the <code>rumpbake</code> command to create a full kernel image which is then run from within QEMU.</p>
<p>Finally, the fun part, the BSDs. Quite a few hoops are jumped through to get CI working for these platforms, but the gist of it looks like:</p>
<ul>
<li>Cross compiling from Linux to any of the BSDs seems to be quite non-standard. We may be able to get it working but it might be difficult at that point to ensure that the libc definitions align with what you'd get on the BSD itself. As a result, we try to do compiles within the BSD distro.</li>
<li>On Travis we can't run a VM-in-a-VM, so we resort to userspace emulation (QEMU).</li>
<li>Unfortunately on Travis we also can't use KVM, so the emulation is super slow.</li>
</ul>
<p>With all that in mind, the way BSD is tested looks like:</p>
<ol type="1">
<li>Download a pre-prepared image for the OS being tested.</li>
<li>Generate the tests for the OS being tested. This involves running the <code>ctest</code> library over libc to generate a Rust file and a C file which will then be compiled into the final test.</li>
<li>Generate a disk image which will later be mounted by the OS being tested. This image is mostly just the libc directory, but some modifications are made to compile the generated files from step 2.</li>
<li>The kernel is booted in QEMU, and it is configured to detect the libc-test image being available, run the test script, and then shut down afterwards.</li>
<li>Look for whether the tests passed in the serial console output of the kernel.</li>
</ol>
<p>There's some pretty specific instructions for setting up each image (detailed below), but the main gist of this is that we must avoid a vanilla <code>cargo run</code> inside of the <code>libc-test</code> directory (which is what it's intended for) because that would compile <code>syntex_syntax</code>, a large library, with userspace emulation. This invariably times out on Travis, so we can't do that.</p>
<p>Once all those hoops are jumped through, however, we can be happy that we're testing almost everything!</p>
<p>Below are some details of how to set up the initial OS images which are downloaded. Each image must be enabled have input/output over the serial console, log in automatically at the serial console, detect if a second drive in QEMU is available, and if so mount it, run a script (it'll specifically be <code>run-qemu.sh</code> in this folder which is copied into the generated image talked about above), and then shut down.</p>
<h3>QEMU setup - FreeBSD</h3>
<ol type="1">
<li>Download CD installer (most minimal is fine)</li>
<li><code>qemu-img create -f qcow2 foo.qcow2 2G</code></li>
<li><code>qemu -cdrom foo.iso -drive if=virtio,file=foo.qcow2 -net nic,model=virtio -net user</code></li>
<li>run installer</li>
<li>`echo 'console="comconsole"' &gt;&gt; /boot/loader.conf<code> 6.</code>echo 'autoboot_delay="0"' &gt;&gt; /boot/loader.conf`</li>
<li>look at /etc/ttys, see what getty argument is for ttyu0</li>
<li>edit /etc/gettytab, look for ttyu0 argument, prepend <code>:al=root</code> to line beneath</li>
</ol>
<p>(note that the current image has a <code>freebsd</code> user, but this isn't really necessary)</p>
<p>Once that's done, arrange for this script to run at login:</p>
<div class="fragment"><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">sudo kldload ext2fs</div><div class="line">[ -e /dev/vtbd1 ] || exit 0</div><div class="line">sudo mount -t ext2fs /dev/vtbd1 /mnt</div><div class="line">sh /mnt/run.sh /mnt</div><div class="line">sudo poweroff</div></div><!-- fragment --><p>Helpful links</p>
<ul>
<li><a href="https://en.wikibooks.org/wiki/QEMU/Images">https://en.wikibooks.org/wiki/QEMU/Images</a></li>
<li><a href="https://blog.nekoconeko.nl/blog/2015/06/04/creating-an-openstack-freebsd-image.html">https://blog.nekoconeko.nl/blog/2015/06/04/creating-an-openstack-freebsd-image.html</a></li>
<li><a href="https://www.freebsd.org/doc/handbook/serialconsole-setup.html">https://www.freebsd.org/doc/handbook/serialconsole-setup.html</a></li>
</ul>
<h3>QEMU setup - OpenBSD</h3>
<ol type="1">
<li>Download CD installer</li>
<li><code>qemu-img create -f qcow2 foo.qcow2 2G</code></li>
<li><code>qemu -cdrom foo.iso -drive if=virtio,file=foo.qcow2 -net nic,model=virtio -net user</code></li>
<li>run installer</li>
<li>`echo 'set tty com0' &gt;&gt; /etc/boot.conf<code> 6.</code>echo 'boot' &gt;&gt; /etc/boot.conf<code></code></li>
<li><code>Modify /etc/ttys, change the</code>tty00` at the end from 'unknown off' to 'vt220 on secure'</li>
<li>Modify same line in /etc/ttys to have <code>"/root/foo.sh"</code> as the shell</li>
<li>Add this script to <code>/root/foo.sh</code></li>
</ol>
<div class="fragment"><div class="line">#!/bin/sh</div><div class="line">exec 1&gt;/dev/tty00</div><div class="line">exec 2&gt;&amp;1</div><div class="line"></div><div class="line">if mount -t ext2fs /dev/sd1c /mnt; then</div><div class="line">  sh /mnt/run.sh /mnt</div><div class="line">  shutdown -ph now</div><div class="line">fi</div><div class="line"></div><div class="line"># limited shell...</div><div class="line">exec /bin/sh &lt; /dev/tty00</div></div><!-- fragment --><ol type="1">
<li><code>chmod +x /root/foo.sh</code></li>
</ol>
<p>Helpful links:</p>
<ul>
<li><a href="https://en.wikibooks.org/wiki/QEMU/Images">https://en.wikibooks.org/wiki/QEMU/Images</a></li>
<li><a href="http://www.openbsd.org/faq/faq7.html#SerCon">http://www.openbsd.org/faq/faq7.html#SerCon</a></li>
</ul>
<h1>Questions?</h1>
<p>Hopefully that's at least somewhat of an introduction to everything going on here, and feel free to ping  with questions! </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
